# Linux之Shell

shell 脚本是由 Shell 命令组成的执行文件，将一些命令整合到一个文件中，进行处理业务逻辑，脚本不需要编译即可运行。通过解释器解释运行，所以速度相对来说比较慢。

shell 脚本中最重要的就是对 Shell 命令的组合和使用，再使用 Shell 脚本支持的一些语言特性，完成想要的功能。

## 注释

`#` 开头的就是注释，被编译器忽略。

- 单行注释：`#`
- 多行注释：`:<`

## 变量

### 变量类型

运行 shell 时，会同时存在三种变量：

- 局部变量：局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量。
- 环境变量：所有程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 shell 脚本也可以定义环境变量。
- shell 变量：shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行。

### 变量操作

- 创建普通变量：`name="test"` (`=` 两边不可以有空格)。
- 创建只可函数体使用的局部变量：`local name="test"` (使用 `local` 修饰的变量在函数体外无法访问，并且 `local` 只能在函数体内使用)。
- 使用变量：`echo $name` 或者 `echo ${name}` (推荐使用大括号版本)。
- 变量重新赋值：`name="new_test"` (将原值覆盖)。
- 只读变量：`name="only_read" -> readonly name` (使用 `readonly` 标识后的变量，不可被修改)。
- 删除变量：`unset name` (删除之后不可访问，删不掉只读变量)。

### 字符串变量

1. 单引号

   - 单引号变量 `var='test'`，只能原样输出，变量无效。
   - 单引号中不能出现一个单独的单引号，转义也不可以。

2. 双引号

   - 双引号变量 `var="my name is ${name}"`，变量有效。
   - 可出现转义符。

3. 拼接字符串

   - 双引号拼接

     ```shell
     # 有效
     name="this is"" my name";
     name="this is my name";
     name="this" is "my name";
     ```

   - 单引号拼接

     ```shell
     # 有效
     name='this is'' my name';
     name='this is my name';
     name='this' is 'my name';
     ```

4. 获取字符串长度

   - 在 `${}` 中使用 `#` 获取长度

     ```shell
     name="test";
     echo ${#name}; 
     # 输出为 4
     ```

5. 提取子字符串

   - `:1:4` 从第二个开始，往后截取 4 个字符。

   - `::4` 从第一个字符开始，往后截取 4 个字符。

     ```shell
     name="this is my name";
     echo ${name:1:4};
     # 输出 is i
     echo ${name::4};
     # 输出 this
     ```

### 数组

bash 只支持一维数组，不支持多维数组。

- 定义数组：`array_name=(li wang xiang zhang)` (小括号做边界、使用空格分离)。

- 单独定义数组的元素：`array_para[0]="w";array_para[3]="s"` (定义时下标不连续也可以)。

- 赋值数组元素：`array_name[0]="zhao"`。

- 获取数组元素：

  ```shell
  array_name[0]="li";
  array_name[3]="zhang";
  echo ${array_name[0]}; # 输出 "li"
  echo ${array_name[1]}; # 输出 ""
  echo ${array_name[3]}; # 输出 "zhang"
  echo ${array_name[@]}; # 输出 "li zhang" 输出数组所有元素，没有元素的小标省略
  ```

- 获取元素个数：`echo ${#array_name[@]}`。

- 取得单个元素长度：`${#array_name[1]}`。

## 参数传递

1. `$0`：代表执行的文件名。
2. `$1`：代表传入的第 1 个参数。
3. `$n`：代表传入的第 n 个参数。
4. `$#`：代表传递到脚本的参数个数。
5. `$*`：以一个单字符串显示所有向脚本传递的参数。以 `"$1 $2 $3 ... $n"` 的形式输出所有参数。
6. `$@`：跟 `$*` 同理，但是使用时加引号，并在引号中返回参数，如：`"$1" "$2" "$3" "$4"`。
7. `$$`：获取当前脚本运行的进程号。
8. `$!`：后台运行的最后一个进程 ID。
9. `$?`：显示最后命令的退出状态。0 表示没有错误，其他值表示有错误。

## 运算符

### 算数运算

- `+、-、*、/`：其中乘号必须添加 `\` 进行转义才可以进行乘法运算。

- 加法运算：

  ```shell
  val=`expr 2 + 2`; # 使用 Linux 命令进行 expr 辅助运算
  val=$[2+2];
  val=$((2+2));
  ```

### 数字关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

假定变量 `a` 为 10，变量 `b` 为 20。

- `-eq`：检测两个数是否相等，相等返回 `true`。`[ $a -eq $b ]` 返回 `false`。
- `-ne`：检测两个数是否不相等，不相等返回 `true`。`[ $a -ne $b ]` 返回 `true`。
- `-gt`：检测左边的数是否大于右边的，如果是，返回 `true`。`[ $a -gt $b ]` 返回 `false`。
- `-lt`：检测左边的数是否小于右边的，如果是，返回 `true`。`[ $a -lt $b ]` 返回 `true`。
- `-ge`：检测左边的数是否大于等于右边的，如果是，返回 `true`，`[ $a -ge $b ]` 返回 `false`。
- `-le`：检测左边的数是否小于等于右边的，如果是，返回 `true`，`[ $a -le $b ]` 返回 `true`。

### 字符串运算符

假定变量 `a` 为 `"abc"`，变量 `b` 为 `"efg"`。

- `=`：检测两个字符串是否相等，相等返回 `true`。`[ $a = $b ]` 返回 `false`。
- `!=`：检测两个字符串是否相等，不相等返回 `true`。`[ $a != $b ]` 返回 `true`。
- `-z`：检测字符串长度是否为 0，为 0 返回 `true`，`[ -z $a ]` 返回 `false`。
- `-n`：检测字符串长度是否为 0，不为 0 返回 `true`，`[ -n $a ]` 返回 `true`。
- `$`：检测字符串长度是否为空，不为空返回 `true`，`[ $a ]` 返回 `true`。

### 布尔运算符

假定变量 `a` 为 10，变量 `b` 为 20：

- `!`：非运算符，表达式为 `true`，则返回 `false`。`[ !false ]` 返回 `true`。
- `-o`：或运算，有一个表达式为 `true` 则返回 `true`。`[ $a -lt 20 -o $b -gt 100]` 返回 `true`。
- `-a`：与运算，两个表达式都为 `true` 才返回 `true`。`[ $a -lt 20 -a $b -gt 100]` 返回 `false`。

### 逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 `a` 为 10，变量 `b` 为 20。

- `&&`：逻辑的 AND `[[ $a -lt 100 && $b -gt 100 ]]` 返回 `false`。
- `||`：逻辑的 OR `[[ $a -lt 100 || $b -gt 100 ]]` 返回 `true`。

### 文件运算符

- `-b file`：检测文件是否是块设备文件，如果是，则返回 `true`。`[ -b $file ]` 返回 `false`。
- `-c file`：检测文件是否是字符设备文件，如果是，返回 `true`。`[ -c $file ]` 返回 `false`。
- `-d file`：检测文件是否是目录，如果是，则返回 `true`。`[ -d $file ]` 返回 `false`。
- `-f file`：检测文件是否是普通文件 (既不是目录，也不是设备文件)，如果是，则返回 `true`。`[ -f $file ]` 返回 `true`。
- `-g file`：检测文件是否设置了 SGID 位，如果是，则返回 `true`。`[ -g $file ]` 返回 `false`。
- `-k file`：检测文件是否设置了粘着位，如果设置了，则返回 `true`。`[ -k $file ]` 返回 `false`。
- `-p file`：检测文件是否是有名管道，如果是，则返回 `true`。`[ -p $file ]` 返回 `false`。
- 



