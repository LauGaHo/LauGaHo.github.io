# Sass学习笔记

## 1 CSS 功能拓展

### 1.1 嵌套规则

Sass 允许将一套 CSS 样式嵌进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：

```scss
#main p {
  color: #00ff00;
  width: 97%;
  
  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}
```

编译为：

```css
#main p {
  color: #00ff00;
  width: 97%;
}

#main p .redbox {
  background-color: #ff0000;
  color: #000000;
}
```

嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更加易于管理：

```scss
#main {
  width: 97%;
  
  p, div {
    font-size: 2em;
    a {
      font-weight: bold;
    }
  }
  
  pre {
    font-size: 3em;
  }
}
```

编译为：

```css
#main {
  width: 97%;
}

#main p, #main div {
  font-size: 2em;
}

#main p a, #main div a {
  font-weight: bold;
}

#main pre {
  font-size: 3em;
}
```

### 1.2 父选择器 `&`

在嵌套 CSS 规则时，有时需要使用嵌套外层的父选择器，例如，当给某个元素设定 `hover` 样式时，或者当 `body` 元素有某个 `classname` 时，可以用 `&` 代表嵌套规则外层的父选择器。

```scss
a {
  font-weight: bold;
  text-decoration: node;
  &:hover {
    text-decoration: underline;
  }
  body.firefox & {
    font-weight: normal;
  }
}
```

编译为：

```css
a {
  font-weight: bold;
  text-decoration: none;
  a:hover {
    text-decoration: underline;
  }
  body.firefox a {
    font-weight: normal;
  }
}
```

编译后的 CSS 文件中，`&` 将被替换成嵌套外层的父选择器，假设含有多层嵌套，最外层的父选择器会一层层往下传递：

```scss
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover {
      color: red;
    }
  }
}
```

编译为：

```css
#main {
  color: black;
}

#main a {
  font-weight: bold;
}

#main a:hover {
  color: red;
}
```

### 1.3 属性嵌套

有些 CSS 属性遵循相同的命名空间，比如 `font-family`、`font-size`、`font-weight` 都以 `font` 作为属性的命名空间。为了便于管理这种属性，同时为了避免重复输入，Sass 允许将属性嵌套在命名空间中，例如：

```scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```

编译为：

```css
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold;
}
```

命名空间也可以包含自己的属性值，如下：

```scss
.funky {
  font: 20px/24px {
  	family: fantasy;
    weight: bold;
  }
}
```

编译为：

```css
.funky {
  font: 20px/24px;
  font-family: fantasy;
  font-weight: bold;
}
```

### 1.4 占位符选择器 `%foo`

Sass 额外提供了一种特殊类型的选择器：占位符选择器。和常用的 `id` 和 `class` 选择器写法类似，只是 `#` 或 `.` 替换成了 `%`。这个必须通过 `@extend` 指令调用。

当占位符选择器单独使用，且为通过 `@extend` 调用，将不会编译到 CSS 文件中。

## 2 注释 `/* */` 和注释 `//`

Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会被完整输出到编译后的 CSS 文件中，而后者则不会，例如：

```scss
/* This comment is several lines long. */
body {
  color: black;
}

// This comment is several lines long.
a {
  color: green;
}
```

编译为：

```css
/* This comment is several lines long. */
body {
  color: black;
}

a {
  color: green;
}
```

将 `!` 作为多行注释的第一个字符标识在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。

插值语句也可以写入到多行注释中输出变量值：

```scss
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
```

编译为：

```css
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
```

## 3 SassScript

在 CSS 属性的基础上，Sass 提供了一些名为 SassScript 的新功能。SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。

### 3.1 变量 `$`

SassScript 最普遍的用法是变量，变量是以 `$` 作为开头，赋值方法和 CSS 属性的写法一样：

```scss
$width: 5em;
```

直接使用即调用变量：

```css
#main {
  width: $width;
}
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用 (局部变量)，不在嵌套规则内定义的变量可在任何地方使用 (全局变量)。将局部变量转换为全局变量可以添加 `!global` 声明：

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```

编译为：

```css
#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}
```

### 3.2 数据类型

SassScript 支持 6 种主要的数据类型：

- 数字：`1, 2, 13, 10px`
- 字符串：有引号字符串和无引号字符串，`"foo", 'bar', baz`
- 颜色：`blue, #04a3f9, rgba(255, 0, 0.5)`
- 布尔型：`true, false`
- 空值：`null`
- 数组：用空格或都好作为分隔符，`1.5em 1em 0 2em` 或者 `Helvetica, Arial, sans-serif`
- `maps`：相当于 JavaScript 中的 `Object`，`{key1: value1, key2: value2}`

#### 3.2.1 字符串

SassScript 支持 CSS 的两种字符串类型：有引号字符串，如：`"Lucida Grande" 'http://sass-lang.com'`；还有无引号字符串，如：`sans-serif bold`，在编译 CSS 文件时不会改变其类型。只有一种情况例外，那就是使用 `#{}` 时，有引号字符串将被编译成无引号字符串，这样就便于在 `mixin` 中引用选择器名：

```scss
@mixin firefox-message($selector) {
  body.firefox #{$selector}:before {
    content: "Hi, Firefox user!";
  }
}

@include firfox-message(".header");
```

编译为：

```css
body.firefox .header:before {
  content: "Hi, Firefox user!";
}
```

#### 3.2.2 数组

数组指 Sass 如何处理 CSS 中 `margin: 10px 15px 0 0` 或者 `font-face: Helvetica, Arial, sans-serif` 这样通过空格或者逗号分隔的一些列的值。事实上，独立的值也被视为数组—只包含一个值得数组。

数组本身没有太多功能，但是 Sass 中的 `list functions` 赋予了数组更多新功能：`nth` 函数可以直接访问数组中的某一项；`join` 函数可以将多个数组连接在一起；`append` 函数可以在数组中添加新值；而 `@each` 指令能够遍历数组中的每一项。

数组中可以包含子数组，比如 `1px 2px 5px 6px` 是包含 `1px 2px` 和 `5px 6px` 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要使用圆括号包裹内层，所以也可以写成 `(1px 2px) (5px 6px)`。变化是，之前的 `1px 2px, 5px 6px` 使用逗号分割了两个子数组，而 `(1px 2px) (5px 6px)` 则使用了空格切割。

当数组被编译为 CSS 时，Sass 不会添加任何圆括号 (CSS 中没有这种写法)，所以 `(1px 2px) (5px 6px)` 和 `1px 2px, 5px 6px` 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却又不同的意义。

用 `()` 表示不包含任何值得空数组 (Sass 3.3 版之后也视为空的 `map`)。空数组不可以直接编译成 CSS，比如编译 `font-family: ()`，Sass 将会报错。如果数组中包含空数组或空值，编译时将会被清除，比如 `1px 2px () 3px` 将会被编译成 `1px 2px null 3px`。

#### 3.2.3 Maps

Maps 可视为键值对的集合，键被用于定位值。在 CSS 中没有对应的概念。和 Lists 不同，Maps 必须被圆括号包围。Maps 中的 `keys` 和 `values` 可以是 SassScript 中的任何对象。和 Lists 一样 Maps 主要为 SassScript 函数服务，如 `map-get` 函数用于查找键值，`map-merge` 函数用于 `map` 和新加的键值融合，`@each` 命令可添加样式到一个 `map` 中的每个键值对。Maps 可用于任何 Lists 可用的地方，在 List 函数中 Map 会自动转换为 List，如 `(key1: value1, key2: value2)` 会被 List 函数转换为 `key1 value1, key2 value2`，反之则不能。

### 3.3 运算

所有数据类型均支持相等运算 `==` 或 `!=`，此外，每种数据类型也有其各自支持的运算的方式。

#### 3.3.1 数字运算

SassScript 支持数字的加减乘除、取整等运算 (`+, -, *, /, %`)，如果必要会在不同单位间转换值。

```scss
p {
  width: 1in + 8pt;
}
```

编译为：

```css
p {
  width: 1.111in;
}
```

关系运算 `<, >, <=, >=` 也可以用于数字运算，相等运算 `==`、`!=` 可用于所有数据类型。

##### 3.3.1.1 除法运算

`/` 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展也支持这个功能，同时也赋予 `/` 除法运算的功能。也就是说，如果 `/` 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。

以下三种情况 `/` 将被视为除法运算符号：

- 如果值，或值的一部分，是变量或者函数的返回值。
- 如果值被圆括号包裹。
- 如果值是算数表达式的一部分。

```scss
p {
  font: 10px/8px;											// Plain CSS, no division
  $width: 1000px;											
  width: $width/2;										// Uses a variable, does division
  width: round(1.5)/2;								// Uses a function, does division
  height: (500px/2);									// Uses parentheses, does division
  margin-left: 5px + 8px/2px;					// Uses +, does division
}
```

编译为：

```css
p {
  font: 10px/8px;
  width: 500px;
  height: 250px;
  margin-left: 9px;
}
```

如果需要使用变量，同时需要确保 `/` 不做除法运算而是完整编译到 CSS 文件中，只需要使用 `#{}` 插值语句将变量包裹。

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size} / #{line-height};
}
```

编译为：

```css
p {
  font: 12px/30px;
}
```

#### 3.3.2 颜色值运算

颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：

```scss
p {
  color: #010203 + #040506;
}
```

计算 `01 + 04 = 05`、`02 + 05 = 07`、`03 + 06 = 09`，然后编译为：

```css
p {
  color: #050709;
}
```

使用 `color functions` 比计算颜色值更方便。

数字和颜色值之间也可以进行算数运算，同样也是分段计算，比如：

```scss
p {
  color: #010203 * 2;
}
```

编译结果为：

```css
p {
  color: #020406;
}
```

需要注意的是，如果颜色值包含 `alpha channel` (`rgba` 或 `hsla` 两种颜色值)，必须拥有相等的 `alpha` 值才能进行运算，因为算术运算不会作用于 `alpha` 值。(`alpha channel` 一般代指透明度)

```scss
p {
  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
}
```

编译为：

```css
p {
  color: rgba(255, 255, 0, 0.75);
}
```

颜色值的 `alpha channel` 可以通过 `opacify` 或 `transparentize` 两个函数进行调整。

```scss
$translucent-red: rgba(255, 0, 0, 0.5);
p {
  color: opacify($translucent-red, 0.3);
  background-color: transparentize($translucent-red, 0.25);
}
```

编译为：

```css
p {
  color: rgba(255, 0, 0, 0.8);
  background-color: rgba(255, 0, 0, 0.25);
}
```

#### 3.3.3 字符串运算

`+` 可用于连接字符串。

```scss
p {
  cursor: e + -resize;
}
```

编译为：

```css
p {
  cursor: e-resize;
}
```

> 注意，如果有引号字符串 (位于 `+` 左侧) 连接无引号字符串，运算结果是有引号的，相反，无引号字符串 (位于 `+` 左侧) 连接有引号字符串，运算结果则没有引号。

```scss
p:before {
  content: "Foo " + Bar;
  font-family: sans- + "serif";
}
```

编译为：

```css
p:before {
  content: "Foo Bar";
  font-family: sans-serif;
}
```

运算表达式和其他值连用时，用空格做连接符：

```scss
p {
  margin: 3px + 4px auto;
}
```

编译为：

```css
p {
  margin 7px auto;
}
```

在有引号的文本字符中使用 `#{}` 插值语句可以添加动态的值：

```scss
p:before {
  content: "I ate #{5 + 10} pies!";
}
```

编译为：

```css
p:before {
  content: "I ate 15 pies!";
}
```

空的值被视为插入了空字符串：

```scss
$value: null;
p:before {
  content: "I ate #{$value} pies!";
}
```

编译为：

```css
p:before {
  content: "I ate pies!";
}
```

#### 3.3.4 布尔运算

SassScript 支持布尔型的 `and`、`or`、`not` 运算。

#### 3.3.5 数组运算

数组不支持任何运算方式，只能使用 `list functions` 控制。

### 3.4 圆括号

圆括号可以用来影响运算的顺序：

```scss
p {
  width: 1em + (2em * 3);
}
```

编译为：

```css
p {
  width: 7em;
}
```

### 3.5 函数

SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：

```scss
p {
  color: hsl(0, 100%, 50%);
}
```

编译为：

```css
p {
  color: #ff00000;
}
```

#### 3.5.1 关键词参数

Sass 函数允许使用关键词参数，上方例子可以写成：

```scss
p {
  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}
```

虽然不够简明，但是阅读起来会更加方便。关键词参数给函数提供了更灵活的接口，以及更容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以缺省，另外参数名被视为变量名，下划线，短横线可以互换使用。

### 3.6 插值语句 `#{}`

通过 `#{}` 插值语句可以在选择器或属性名中使用变量：

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

编译为：

```css
p.foo {
  border-color: blue;
}
```

`#{}` 插值语句也可以在属性值中插入 SassScript，大多数情况，这样不如直接使用变量方便，但是使用 `#{}` 可以避免 Sass 运行运算表达式，直接编译成 CSS。

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$lint-height};
}
```

编译为：

```css
p {
  font: 12px/30px;
}
```

### 3.7 变量定义 `!default`

可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。

```scss
$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}
```

编译为：

```css
#main {
  content: "First content";
  new-content: "First time reference";
}
```

变量是 `null` 空值时将被视为未被 `!default` 赋值。

```scss
$content: null;
$content: "Non-null content" !default;

#main {
  content: $content;
}
```

编译为：

```css
#main {
  content: "Non-null content";
}
```

## 

## 4 `@-Rules` 和指令

Sass 支持所有的 CSS3 `@-Rules`，以及 Sass 特有的指令。

### 4.1 `@import`

Sass 拓展了 `@import` 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 `mixin` 都可以在导入的文件中使用。

通常，`@import` 寻找 Sass 文件并将其导入，但是以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。

- 文件拓展名是 `.css`
- 文件名以 `http://` 开头
- 文件名是 `url()`
- `@import` 包含 `media queries`

如果不在上述情况内，文件的拓展名是 `.scss` 或 `sass`，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 `.scss` 或 `.sass` 的文件并将其导入。

```scss
@import "foo.scss";
// 或
@import "foo";
```

都会导入文件 `foo.scss`，但是

```scss
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

编译为：

```css
@import "foo.scss";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

Sass 允许同时导入多个文件，例如同时导入 `rounded-corners` 和 `text-shadow` 两个文件：

```scss
@import "rounded-corners", "text-shadow"
```

导入文件也可以使用 `#{}` 插值语句，但不是通过变量动态导入 Sass 文件，只能作用域 CSS 的 `url()` 导入方式：

```scss
$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}")
```

编译为：

```css
@import url("http://fonts.googleapis.com/css?family=Droid+Sans");
```

#### 4.1.1 分音

如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句却不需要添加下划线。

例如，将文件命名为 `_colors.scss`，便不会编译 `_colors.scss` 文件。

```scss
@import "colors"
```

上方例子中，导入的其实是 `_colors.scss` 文件。

> 注意，不可以同时存在添加下划线和未添加下划线的同名文件，添加下划线的文件将会被忽略。

#### 4.1.2 嵌套 `@import`

大多数情况下，一般在文件的最外层 (不在嵌套规则内) 使用 `@import`，其实，也可以将 `@import` 嵌套进 CSS 样式或者 `media` 中，和平时的用法相同，只是这样导入的样式只能出现在嵌套的层中。

假设 `examples.scss` 文件中包含一下样式：

```scss
.example {
  color: red;
}
```

然后导入到 `#main` 样式中：

```css
#main {
  @import "example";
}
```

将会被编译为：

```css
#main .example {
  color: red;
}
```

> 不可以在混合指令 `mixin` 或控制指令中嵌套 `@import`。