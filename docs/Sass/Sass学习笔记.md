# Sass学习笔记

## 1 CSS 功能拓展

### 1.1 嵌套规则

Sass 允许将一套 CSS 样式嵌进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：

```scss
#main p {
  color: #00ff00;
  width: 97%;
  
  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}
```

编译为：

```css
#main p {
  color: #00ff00;
  width: 97%;
}

#main p .redbox {
  background-color: #ff0000;
  color: #000000;
}
```

嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更加易于管理：

```scss
#main {
  width: 97%;
  
  p, div {
    font-size: 2em;
    a {
      font-weight: bold;
    }
  }
  
  pre {
    font-size: 3em;
  }
}
```

编译为：

```css
#main {
  width: 97%;
}

#main p, #main div {
  font-size: 2em;
}

#main p a, #main div a {
  font-weight: bold;
}

#main pre {
  font-size: 3em;
}
```

### 1.2 父选择器 `&`

在嵌套 CSS 规则时，有时需要使用嵌套外层的父选择器，例如，当给某个元素设定 `hover` 样式时，或者当 `body` 元素有某个 `classname` 时，可以用 `&` 代表嵌套规则外层的父选择器。

```scss
a {
  font-weight: bold;
  text-decoration: node;
  &:hover {
    text-decoration: underline;
  }
  body.firefox & {
    font-weight: normal;
  }
}
```

编译为：

```css
a {
  font-weight: bold;
  text-decoration: none;
  a:hover {
    text-decoration: underline;
  }
  body.firefox a {
    font-weight: normal;
  }
}
```

编译后的 CSS 文件中，`&` 将被替换成嵌套外层的父选择器，假设含有多层嵌套，最外层的父选择器会一层层往下传递：

```scss
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover {
      color: red;
    }
  }
}
```

编译为：

```css
#main {
  color: black;
}

#main a {
  font-weight: bold;
}

#main a:hover {
  color: red;
}
```

### 1.3 属性嵌套

有些 CSS 属性遵循相同的命名空间，比如 `font-family`、`font-size`、`font-weight` 都以 `font` 作为属性的命名空间。为了便于管理这种属性，同时为了避免重复输入，Sass 允许将属性嵌套在命名空间中，例如：

```scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```

编译为：

```css
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold;
}
```

命名空间也可以包含自己的属性值，如下：

```scss
.funky {
  font: 20px/24px {
  	family: fantasy;
    weight: bold;
  }
}
```

编译为：

```css
.funky {
  font: 20px/24px;
  font-family: fantasy;
  font-weight: bold;
}
```

### 1.4 占位符选择器 `%foo`

Sass 额外提供了一种特殊类型的选择器：占位符选择器。和常用的 `id` 和 `class` 选择器写法类似，只是 `#` 或 `.` 替换成了 `%`。这个必须通过 `@extend` 指令调用。

当占位符选择器单独使用，且为通过 `@extend` 调用，将不会编译到 CSS 文件中。

## 2 注释 `/* */` 和注释 `//`

Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会被完整输出到编译后的 CSS 文件中，而后者则不会，例如：

```scss
/* This comment is several lines long. */
body {
  color: black;
}

// This comment is several lines long.
a {
  color: green;
}
```

编译为：

```css
/* This comment is several lines long. */
body {
  color: black;
}

a {
  color: green;
}
```

将 `!` 作为多行注释的第一个字符标识在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。

插值语句也可以写入到多行注释中输出变量值：

```scss
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
```

编译为：

```css
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
```

## 3 SassScript

在 CSS 属性的基础上，Sass 提供了一些名为 SassScript 的新功能。SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。

### 3.1 变量 `$`

SassScript 最普遍的用法是变量，变量是以 `$` 作为开头，赋值方法和 CSS 属性的写法一样：

```scss
$width: 5em;
```

直接使用即调用变量：

```css
#main {
  width: $width;
}
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用 (局部变量)，不在嵌套规则内定义的变量可在任何地方使用 (全局变量)。将局部变量转换为全局变量可以添加 `!global` 声明：

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```

编译为：

```css
#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}
```

### 3.2 数据类型

SassScript 支持 6 种主要的数据类型：

- 数字：`1, 2, 13, 10px`
- 字符串：有引号字符串和无引号字符串，`"foo", 'bar', baz`
- 颜色：`blue, #04a3f9, rgba(255, 0, 0.5)`
- 布尔型：`true, false`
- 空值：`null`
- 数组：用空格或都好作为分隔符，`1.5em 1em 0 2em` 或者 `Helvetica, Arial, sans-serif`
- `maps`：相当于 JavaScript 中的 `Object`，`{key1: value1, key2: value2}`

#### 3.2.1 字符串

SassScript 支持 CSS 的两种字符串类型：有引号字符串，如：`"Lucida Grande" 'http://sass-lang.com'`；还有无引号字符串，如：`sans-serif bold`，在编译 CSS 文件时不会改变其类型。只有一种情况例外，那就是使用 `#{}` 时，有引号字符串将被编译成无引号字符串，这样就便于在 `mixin` 中引用选择器名：

```scss
@mixin firefox-message($selector) {
  body.firefox #{$selector}:before {
    content: "Hi, Firefox user!";
  }
}

@include firfox-message(".header");
```

编译为：

```css
body.firefox .header:before {
  content: "Hi, Firefox user!";
}
```

#### 3.2.2 数组

数组指 Sass 如何处理 CSS 中 `margin: 10px 15px 0 0` 或者 `font-face: Helvetica, Arial, sans-serif` 这样通过空格或者逗号分隔的一些列的值。事实上，独立的值也被视为数组—只包含一个值得数组。

数组本身没有太多功能，但是 Sass 中的 `list functions` 赋予了数组更多新功能：`nth` 函数可以直接访问数组中的某一项；`join` 函数可以将多个数组连接在一起；`append` 函数可以在数组中添加新值；而 `@each` 指令能够遍历数组中的每一项。

数组中可以包含子数组，比如 `1px 2px 5px 6px` 是包含 `1px 2px` 和 `5px 6px` 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要使用圆括号包裹内层，所以也可以写成 `(1px 2px) (5px 6px)`。变化是，之前的 `1px 2px, 5px 6px` 使用逗号分割了两个子数组，而 `(1px 2px) (5px 6px)` 则使用了空格切割。

当数组被编译为 CSS 时，Sass 不会添加任何圆括号 (CSS 中没有这种写法)，所以 `(1px 2px) (5px 6px)` 和 `1px 2px, 5px 6px` 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却又不同的意义。

用 `()` 表示不包含任何值得空数组 (Sass 3.3 版之后也视为空的 `map`)。空数组不可以直接编译成 CSS，比如编译 `font-family: ()`，Sass 将会报错。如果数组中包含空数组或空值，编译时将会被清除，比如 `1px 2px () 3px` 将会被编译成 `1px 2px null 3px`。

#### 3.2.3 Maps

Maps 可视为键值对的集合，键被用于定位值。在 CSS 中没有对应的概念。和 Lists 不同，Maps 必须被圆括号包围。Maps 中的 `keys` 和 `values` 可以是 SassScript 中的任何对象。和 Lists 一样 Maps 主要为 SassScript 函数服务，如 `map-get` 函数用于查找键值，`map-merge` 函数用于 `map` 和新加的键值融合，`@each` 命令可添加样式到一个 `map` 中的每个键值对。Maps 可用于任何 Lists 可用的地方，在 List 函数中 Map 会自动转换为 List，如 `(key1: value1, key2: value2)` 会被 List 函数转换为 `key1 value1, key2 value2`，反之则不能。

### 3.3 运算

所有数据类型均支持相等运算 `==` 或 `!=`，此外，每种数据类型也有其各自支持的运算的方式。

#### 3.3.1 数字运算

SassScript 支持数字的加减乘除、取整等运算 (`+, -, *, /, %`)，如果必要会在不同单位间转换值。

```scss
p {
  width: 1in + 8pt;
}
```

编译为：

```css
p {
  width: 1.111in;
}
```

关系运算 `<, >, <=, >=` 也可以用于数字运算，相等运算 `==`、`!=` 可用于所有数据类型。

##### 3.3.1.1 除法运算

`/` 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展也支持这个功能，同时也赋予 `/` 除法运算的功能。也就是说，如果 `/` 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。

以下三种情况 `/` 将被视为除法运算符号：

- 如果值，或值的一部分，是变量或者函数的返回值。
- 如果值被圆括号包裹。
- 如果值是算数表达式的一部分。

```scss
p {
  font: 10px/8px;											// Plain CSS, no division
  $width: 1000px;											
  width: $width/2;										// Uses a variable, does division
  width: round(1.5)/2;								// Uses a function, does division
  height: (500px/2);									// Uses parentheses, does division
  margin-left: 5px + 8px/2px;					// Uses +, does division
}
```

编译为：

```css
p {
  font: 10px/8px;
  width: 500px;
  height: 250px;
  margin-left: 9px;
}
```

如果需要使用变量，同时需要确保 `/` 不做除法运算而是完整编译到 CSS 文件中，只需要使用 `#{}` 插值语句将变量包裹。

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size} / #{line-height};
}
```

编译为：

```css
p {
  font: 12px/30px;
}
```

#### 3.3.2 颜色值运算

颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：

```scss
p {
  color: #010203 + #040506;
}
```

计算 `01 + 04 = 05`、`02 + 05 = 07`、`03 + 06 = 09`，然后编译为：

```css
p {
  color: #050709;
}
```

使用 `color functions` 比计算颜色值更方便。

数字和颜色值之间也可以进行算数运算，同样也是分段计算，比如：

```scss
p {
  color: #010203 * 2;
}
```

编译结果为：

```css
p {
  color: #020406;
}
```

需要注意的是，如果颜色值包含 `alpha channel` (`rgba` 或 `hsla` 两种颜色值)，必须拥有相等的 `alpha` 值才能进行运算，因为算术运算不会作用于 `alpha` 值。(`alpha channel` 一般代指透明度)

```scss
p {
  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
}
```

编译为：

```css
p {
  color: rgba(255, 255, 0, 0.75);
}
```

颜色值的 `alpha channel` 可以通过 `opacify` 或 `transparentize` 两个函数进行调整。

```scss
$translucent-red: rgba(255, 0, 0, 0.5);
p {
  color: opacify($translucent-red, 0.3);
  background-color: transparentize($translucent-red, 0.25);
}
```

编译为：

```css
p {
  color: rgba(255, 0, 0, 0.8);
  background-color: rgba(255, 0, 0, 0.25);
}
```

#### 3.3.3 字符串运算

`+` 可用于连接字符串。

```scss
p {
  cursor: e + -resize;
}
```

编译为：

```css
p {
  cursor: e-resize;
}
```

> 注意，如果有引号字符串 (位于 `+` 左侧) 连接无引号字符串，运算结果是有引号的，相反，无引号字符串 (位于 `+` 左侧) 连接有引号字符串，运算结果则没有引号。

```scss
p:before {
  content: "Foo " + Bar;
  font-family: sans- + "serif";
}
```

编译为：

```css
p:before {
  content: "Foo Bar";
  font-family: sans-serif;
}
```

运算表达式和其他值连用时，用空格做连接符：

```scss
p {
  margin: 3px + 4px auto;
}
```

编译为：

```css
p {
  margin 7px auto;
}
```

在有引号的文本字符中使用 `#{}` 插值语句可以添加动态的值：

```scss
p:before {
  content: "I ate #{5 + 10} pies!";
}
```

编译为：

```css
p:before {
  content: "I ate 15 pies!";
}
```

空的值被视为插入了空字符串：

```scss
$value: null;
p:before {
  content: "I ate #{$value} pies!";
}
```

编译为：

```css
p:before {
  content: "I ate pies!";
}
```

#### 3.3.4 布尔运算

SassScript 支持布尔型的 `and`、`or`、`not` 运算。

#### 3.3.5 数组运算

数组不支持任何运算方式，只能使用 `list functions` 控制。

### 3.4 圆括号

圆括号可以用来影响运算的顺序：

```scss
p {
  width: 1em + (2em * 3);
}
```

编译为：

```css
p {
  width: 7em;
}
```

### 3.5 函数

SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：

```scss
p {
  color: hsl(0, 100%, 50%);
}
```

编译为：

```css
p {
  color: #ff00000;
}
```

#### 3.5.1 关键词参数

Sass 函数允许使用关键词参数，上方例子可以写成：

```scss
p {
  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}
```

虽然不够简明，但是阅读起来会更加方便。关键词参数给函数提供了更灵活的接口，以及更容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以缺省，另外参数名被视为变量名，下划线，短横线可以互换使用。

### 3.6 插值语句 `#{}`

通过 `#{}` 插值语句可以在选择器或属性名中使用变量：

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

编译为：

```css
p.foo {
  border-color: blue;
}
```

`#{}` 插值语句也可以在属性值中插入 SassScript，大多数情况，这样不如直接使用变量方便，但是使用 `#{}` 可以避免 Sass 运行运算表达式，直接编译成 CSS。

```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$lint-height};
}
```

编译为：

```css
p {
  font: 12px/30px;
}
```

### 3.7 变量定义 `!default`

可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。

```scss
$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}
```

编译为：

```css
#main {
  content: "First content";
  new-content: "First time reference";
}
```

变量是 `null` 空值时将被视为未被 `!default` 赋值。

```scss
$content: null;
$content: "Non-null content" !default;

#main {
  content: $content;
}
```

编译为：

```css
#main {
  content: "Non-null content";
}
```

## 

## 4 `@-Rules` 和指令

Sass 支持所有的 CSS3 `@-Rules`，以及 Sass 特有的指令。

### 4.1 `@import`

Sass 拓展了 `@import` 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 `mixin` 都可以在导入的文件中使用。

通常，`@import` 寻找 Sass 文件并将其导入，但是以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。

- 文件拓展名是 `.css`
- 文件名以 `http://` 开头
- 文件名是 `url()`
- `@import` 包含 `media queries`

如果不在上述情况内，文件的拓展名是 `.scss` 或 `sass`，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 `.scss` 或 `.sass` 的文件并将其导入。

```scss
@import "foo.scss";
// 或
@import "foo";
```

都会导入文件 `foo.scss`，但是

```scss
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

编译为：

```css
@import "foo.scss";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```

Sass 允许同时导入多个文件，例如同时导入 `rounded-corners` 和 `text-shadow` 两个文件：

```scss
@import "rounded-corners", "text-shadow"
```

导入文件也可以使用 `#{}` 插值语句，但不是通过变量动态导入 Sass 文件，只能作用域 CSS 的 `url()` 导入方式：

```scss
$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}")
```

编译为：

```css
@import url("http://fonts.googleapis.com/css?family=Droid+Sans");
```

#### 4.1.1 分音

如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句却不需要添加下划线。

例如，将文件命名为 `_colors.scss`，便不会编译 `_colors.scss` 文件。

```scss
@import "colors"
```

上方例子中，导入的其实是 `_colors.scss` 文件。

> 注意，不可以同时存在添加下划线和未添加下划线的同名文件，添加下划线的文件将会被忽略。

#### 4.1.2 嵌套 `@import`

大多数情况下，一般在文件的最外层 (不在嵌套规则内) 使用 `@import`，其实，也可以将 `@import` 嵌套进 CSS 样式或者 `media` 中，和平时的用法相同，只是这样导入的样式只能出现在嵌套的层中。

假设 `examples.scss` 文件中包含一下样式：

```scss
.example {
  color: red;
}
```

然后导入到 `#main` 样式中：

```css
#main {
  @import "example";
}
```

将会被编译为：

```css
#main .example {
  color: red;
}
```

> 不可以在混合指令 `mixin` 或控制指令中嵌套 `@import`。

### 4.2 `@media`



### 4.3 `@extend`

在设计网页的时候经常会遇到这种情况：一个元素使用的样式和另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 `class`，一个是通用样式，一个是特殊样式。假设要设计一个普通错误样式和一个严重错误样式，一般会这样写：

```html
<div class="error seriousError">
  Oh no! You've been hacked!
</div>
```

样式如下：

```css
.error {
  border: 1px #foo;
  background-color: #fdd;
}

.seriousError {
  border-width: 3px;
}
```

使用 `@extend` 某种程度上可以告诉 Sass 将一个选择器下的所有样式集成给另一个选择器。

```scss
.error {
  border: 1px #foo;
  background-color: #fdd;
}

.serioudError {
  @extend .error;
  border-width: 3px;
}
```

上面代码的意思是将 `.error` 下的所有样式继承给 `.seriousError`，`border-width: 3px` 是单独给 `.seriousError` 设定的特殊样式，这样，使用 `.seriousError` 的地方可以不再使用 `.error`。

其他使用到 `.error` 样式也会同样继承给 `.seriousError`，例如，另一个样式 `.error.instrusion` 使用了 `hacked.png` 做背景，`<div class="seriousError instrusion"></div>` 也同样会使用 `hacked.png` 背景。

```scss
.error.instrusion {
  background-image: url("/image/hacked.png");
}
```

#### 4.3.1 `@extend` 原理

`@extend` 的作用是将重复使用的样式 `.error` 延伸给需要包含这个样式的特殊样式 `.seriousError`，刚刚的例子：

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.error.instrusion {
  background-image: url("/image/hacked.png");
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

编译为：

```css
.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd;
}

.error.instrusion, .seriousError.instrusion {
  background-image: url("/image/hacked.png");
}

.seriousError {
  border-width: 3px;
}
```

#### 4.3.2 `@extend` 复杂的选择器

`class` 选择器并不是唯一可以被 `extend` 的，Sass 允许 `extend` 任何定义给单个元素的选择器，比如 `.special.cool`、`a:hover` 或者 `a.user[href^="http://"]` 等，例如：

```scss
.hoverlink {
  @extend a:hover;
}

a:hover {
  text-decoration: underline;
}
```

编译为：

```css
a:hover, .hoverlink {
  text-decoration: underline;
}
```

和上方 `.error.instrusion` 的例子一样，所有 `a:hover` 的样式都将继承给 `.hoverlink`，包括其他使用到 `a:hover` 的样式，例如：

```scss
.hoverlink {
  @extend a:hover;
}

.comment a.user:hover {
  font-weight: bold;
}
```

编译为：

```css
.comment a.user:hover, .comment .hoverlink.user {
  font-weight: bold;
}
```

#### 4.3.3 多重 `@extend`

同一个选择器可以 `extend` 给多个选择器，它所包含的属性将继承给所有被 `extend` 的选择器：

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.attention {
  font-size: 3em;
  background-color: #f00;
}
.seriousError {
  @extend .error;
  @extend .attention;
  border-width: 3px;
}
```

编译为：

```css
.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd;
}
.attention, .seriousError {
  font-size: 3em;
  background-color: #f00;
}
.seriousError {
  border-width: 3px;
}
```

每个 `.seriousError` 将包含 `.error` 和 `.attention` 下的所有样式，这时，后定义的样式享有优先权：`.seriousError` 的背景颜色是 `#f00` 而不是 `#fdd`，因为 `.attention` 在 `.error` 之后定义。

多重 `extend` 可以使用逗号分隔选择器名，比如：

```scss
@extend .error, .attention;
```

和

```scss
@extend .error;
@extend .attention;
```

具有相同的效果。

#### 4.3.4 链式 `extend`

当一个选择器 `extend` 给第二个后，可以继续将第二个选择器 `extend` 给第三个，例如：

```scss
.error {
  border: 1px #f00;
}

.seriousError {
  @extend .error;
  border-width: 3px;
}

.criticalError {
  @extend .seriousError;
  position: fixed;
  top: 10%;
  bottom: 10%;
  left: 10%;
  right: 10%;
}
```

现在，每个 `.seriousError` 选择器将包含 `.error` 的样式，而 `.criticalError` 不仅包含 `.seriousError` 的样式也会同时包含 `.error` 的所有样式，上方的代码编译为：

```css
.error, .seriousError, .criticalError {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError, .criticalError {
  border-width: 3px;
}
.criticalError {
  position: fixed;
  top: 10%;
  bottom: 10%;
  left: 10%;
  right: 10%;
}
```

#### 4.3.5 选择器列

暂时不可以将选择器列 (`.foo .bar` 或 `.foo + .bar`) `extend` 给其他元素，但是，却可以将其他元素 `extend` 给选择器列：

```scss
#fake-links .link {
  @extend a;
}

a {
  color: blue;
  &:hover {
    text-decoration: underline;
  }
}
```

编译为：

```css
a, #fake-links .link {
  color: blue;
}
a:hover, #fake-links .link:hover {
  text-decoration: underline;
}
```

##### 4.3.5.1 合并选择器列

有时候会遇到更复杂的情况，比如选择器列中的某个元素需要 `extend` 给另一个选择器列，这种情况下，两个选择器列需要合并，比如：

```scss
#admin .tabbar a {
  font-weight: bold;
}
#demo .overview .fakelink {
  @extend a;
}
```

技术上能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有 10 中结果。所以，Sass 只会编译输出有用的选择器。

当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：

```scss
#admin .tabbar a {
  font-weight: bold;
}
#demo .overview .fakelink {
  @extend a;
}
```

编译为：

```css
#admin .tabbar a,
#admin .tabbar #demo .overview .fakelink,
#demo .overview #admin .tabbar .fakelink {
  font-weight: bold;
}
```

如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出，下方例子中，两个列都包含了 `#admin`，输出结果中它们合并在了一起：

```scss
#admin .tabbar a {
  font-weight: bold;
}
#admin .overview .fakelink {
  @extend a;
}
```

编译为：

```css
#admin .tabbar a,
#admin .tabbar .overview .fakelink,
#admin .overview .tabbar .fakelink {
  font-weight: bold;
}
```

#### 4.3.6 `@extend-Only` 选择器

有的时候需要定义一套样式并不是给某个元素用，而是通过 `@extend` 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。

如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易和其他样式名冲突，所以，Sass 引入了“占位符选择器”，看起来很想普通的 `id` 或 `class` 选择器，只是 `#` 或 `.` 被替换成了 `%`。可以像 `class` 或者 `id` 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。

```scss
// This ruleset won't be rendered on its own
#content a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}
```

占位符选择器时需要通过 `@extend` 指令进行使用，用法和 `class` 或者 `id` 选择器一样，被 `extend` 后，占位符选择器本身不会被编译。

```scss
.notice {
  @extend %extreme;
}
```

编译为：

```css
#content a.notice {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}
```

#### 4.3.7 `!optional` 声明

如果 `@extend` 失败会收到错误提示，比如，这样像如下的写法：

```scss
a.important {
  @extend .notice;
}
```

当没有 `.notice` 选择器时，将会报错，只有 `h1.notice` 包含 `.notice` 时也会报错，因为 `h1` 和 `a` 冲突，会生成新的选择器。

如果要求 `@extend` 不生成新选择器，可以通过 `!optional` 声明达到这个目的，例如：

```scss
a.important {
  @extend .notice !optional;
}
```

#### 4.3.8 在指令中使用 `@extend`

在指令中使用 `@extend` 时 (比如在 `@media` 中) 有一些限制：Sass 不可以将 `@media` 层外的 CSS 规则 `extend` 给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 `@media` (或者其他 CSS 指令) 中使用 `@extend`，必须 `extend` 给相同指令层中的选择器。

下方例子是可行的：

```scss
@media print {
  .error {
    border: 1px #f00;
    background-color: #fdd;
  },
  .seriousError {
    @extend .error;
    border-width: 3px;
  }
}
```

但不可以这样：

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
@media print {
  .seriousError {
    // INVALID EXTEND: .error is used outside of the "@media print" directive
    @extend .error;
    border-width: 3px;
  }
}
```

### 4.4 `@at-root`

`@at-root` 指令可以让一个或多个规则从文档的根部发出，而不是嵌套在它们的父选择器之下，它也可以和单个内联选择器一起使用：

```scss
.parent {
  ...
  @at-root .child {
    ...
  }
}
```

编译为：

```css
.parent {
  ...
}
.child {
  ...
}
```

或者它可以和包含多个选择器的块一起使用：

```scss
.parent {
  ...
  @at-root {
    .child1 { ... }
    .child2 { ... }
  }
  .step-child { ... }
}
```

编译为：

```css
.parent { ... }
.child1 { ... }
.child2 { ... }
.parent .step-child { ... }
```

#### 4.4.1 `@at-root(without: ...)` 和 `@at-root(with: ...)`

默认情况下，`@at-root` 只排除选择器。但是，也可以使用 `@at-root` 移出嵌套指令，例如 `@media` 指令，代码如下：

```scss
@media print {
  .page {
    width: 8in;
    @at-root (with-out: media) {
      color: red;
    }
  }
}
```

编译为：

```css
@media print {
  .page {
    width: 8in;
  }
}
.page {
  color: red;
}
```

## 5 控制指令

SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令时一种高级功能，日常编写过程并不常用到，主要和混合指令 `mixin` 配合使用，尤其是在样式库中。

### 5.1 `if()`

内置的 `if()` 函数允许根据条件进行分类并仅返回两种可能结果中的一种。它可以在任何脚本上下文中使用。`if()` 函数只评估和它将返回的参数有关的参数，这允许引用可能未定义的变量或进行可能导致错误的计算。

### 5.2 `@if`

当 `@if` 的表达式返回值不是 `false` 或者 `null` 时，条件成立，输出 `{}` 内的代码：

```scss
p {
  @if 1 + 1 == 2 { border: 1px solid; }
  @if 5 < 3 { border: 2px dotted; }
  @if null { border: 3px double; }
}
```

编译为：

```css
p {
  border: 1px solid;
}
```

`@if` 声明后面可以跟多个 `@else if` 声明，或者一个 `@else` 声明。如果 `@if` 声明失败，Sass 将逐条执行 `@else if` 声明，如果全部失败，最后执行 `@else` 声明，例如：

```scss
$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
```

编译为：

```css
p {
  color: green;
}
```

### 5.3 `@for`

`@for` 指令可以在限制的范围内重复输出格式，每次要求 (变量的值) 对输出结果做出变动。这个指令包含两种格式:

- `@for $var from <start> through <end>`
- `@for $var from <start> to <end>`
  

区别在于 `through` 和 `to` 的含义：当使用 `through` 时，条件范围包含 `<start>` 和 `<end>` 的值，而使用 `to` 时条件范围只包含 `<start>` 的值但不包含 `<end>` 的值，另外，`$var` 可以是任何变量，比如 `$i`；`<start>` 和 `<end>` 必须是整数值。

```scss
@for $i from 1 through 3 {
  .item-#{$i} {
    width: 2em * $i;
  }
}
```

### 5.4 `@each`

`@each` 指令的格式是 `$var in <list>`，`$var` 可以是任何变量名，比如 `$length` 或者 `$name`，而 `<list>` 是一连串的值，也就是值列表。

`@each` 将变量 `$var` 作用于值列表中的每一个项目，然后输出结果，例如：

```scss
@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}
```

编译为：

```css
.puma-icon {
  background-image: url('/images/puma.png');
}
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
}
.egret-icon {
  background-image: url('/images/egret.png');
}
.salamander-icon {
  background-image: url('/images/salamander.png');
}
```

#### 5.4.1 多重赋值



### 5.5 `@while`

`@while` 指令重复输出格式直到表达式返回结果为 `false`。这样可以实现比 `@for` 更复杂的循环，只是很少会用到。例如：

```scss
@while $i > 0 {
  .item-#{$i} {
    width: 2em * $i;
  }
  $i: $i - 2;
}
```

编译为：

```css
.item-6 {
  width: 12em;
}
.item-4 {
  width: 8em;
}
.item-2 {
  width: 4em;
}
```

## 6 混合指令 `mixin`

混合指令 `mixin` 用于定义可重复使用的样式，避免了使用无语义的 `class`，比如 `.float-left`。混合指令可以包含所有的 CSS 规则，绝大部分的 Sass 规则，甚至可以通过参数功能引入变量，输出多样化的样式。

### 6.1 定义混合指令 `@mixin`

混合指令的用法是在 `@mixin` 后添加名称和样式，比如名为 `large-text` 的混合通过下面的代码定义：

```scss
@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}
```

混合也需要包含选择器和属性，设置可以使用 `&` 引用父选择器：

```scss
@mixin clearfix {
  display: inline-block;
  &:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
  }
  * html & {
    height: 1px;
  }
}
```

### 6.2 引用混合样式 `@include`

使用 `@include` 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数 (可选)：

```scss
.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}
```

编译为：

```css
.page-title {
  font-family: Arial;
  font-size: 20px;
  font-weight: bold;
  color: #ff0000;
  padding: 4px;
  margin-top: 10px;
}
```

也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。

```scss
@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}
@include silly-links;
```

编译为：

```css
a {
  color: blue;
  background-color: red;
}
```

混合样式中也可以包含其他混合样式，比如：

```scss
@mixin compund {
  @include highlighted-background;
  @include header-text;
}
@mixin highlighted-background {
  background-color: #fc0;
}
@mixin header-text {
  font-size: 20px;
}
```

混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。

### 6.3 参数

参数用于给 `mixin` 指令中的样式设定变量，并赋值使用。在定义 `mixin` 指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号中，引用指令时，按照参数的顺序，再将所赋的值对应写进括号：

```scss
@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: $style;
  }
}
p {
  @include sexy-border(blue, 1in);
}
```

编译为：

```css
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed;
}
```

混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的使用，如果没有参数赋值，则自动使用默认值：

```scss
@mixin sexy-border($border, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p {
  @include sexy-border(blue);
}
h1 {
  @include sexy-border(blue, 2in);
}
```

编译为

```scss
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed;
}
h1 {
  border-color: blue;
  border-width: 2in;
  border-style: dashed;
}
```

#### 6.3.1 关键词参数

混合指令也可以使用关键词参数，上方的例子可以写成：

```scss
p {
  @include sexy-border($color: blue);
}
h1 {
  @include sexy-border($color: blue, $width: 2in);
}
```

虽然不够简明，但是阅读起来会更加方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以缺省，另外，参数名被视为变量名，下划线和短横线可以互相使用。

#### 6.3.2 参数变量

有时，不能确定混合指令需要多少个参数，比如一个关于 `box-shadow` 的混合指令不能确定有多少个 `shadow` 会被用到。这时可以使用参数变量 `...` 声明 (写在参数的最后方) 告诉 Sass 将这些参数视为值列表处理：

```scss
@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}
.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}
```

编译为：

```scss
.shadows {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}
```

参数变量也可以用在引用混合指令的时候 (`@include`)，和平时用法一样，将一串值列表的值逐条作为参数引用：

```scss
@mixin colors($text, $background, $border) {
  color: $text;
  background-color: $background;
  border-color: $border;
}
$value: #ff0000, #00ff00, #0000ff;
.primary {
  @include colors($values...);
}
```

编译为：

```css
.primary {
  color: #ff0000;
  background-color: #00ff00;
  border-color: #0000ff;
}
```

> You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do so, even keyword arguments will get passed through to the wrapped mixin. For example:

```scss
@mixin wrapped-stylish-mixin($args...) {
  font-weight: bold;
  @include stylish-mixin($args...);
}
.stylish {
  // The $width argument will get passed on to "stylish-mixin" as a keyword
  @include wrapped-stylish-mixin(#00ff00, $width: 100px);
}
```

上面注释内的意思是：`$width` 参数将会传递给 `stylish-mixin` 作为关键词。

### 6.4 向混合样式 `mixin` 导入内容 (`@content`)

在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 `@content` 标志的地方：

```scss
@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #logo {
    background-image: url(/logo.gif);
  }
}
```

编译为：

```css
* html #logo {
  background-image: url(/logo.gif);
}
```

为了便于书写，`@mixin` 可以使用 `=` 表示，而 `@include` 可以用 `+` 表示，所以上面的例子可以写成：

```scss
=apply-to-ie6-only
  * html
    @content

+apply-to-ie6-only
  #logo
    background-image: url(/logo.gif)
```

> 注意：当 `@content` 在指令中出现过多次或者出现在循环中时，额外的代码被导入到每一个地方。

#### 6.4.1 变量范围和内容块

传递给 `mixin` 的内容块的范围内进行评估，而不是在 `mixin` 的范围内。这意味着 `mixin` 的本地变量不能在传递的样式块中使用，并且变量将解析为全局值：

> 原文：The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin cannot be used within the passed style block and variables will resolve to the global value:

```scss
$color: white;
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}
.colors {
  @include colors {
    color: $color;
  }
}
```

编译为：

```css
.colors {
  background-color: blue;
  color: white;
  border-color: blue;
}
```

此外，这清楚地表明，在传递的块中使用的变量和 `mixin` 和定义块的其他样式相关。例如：

> 原文：Additionally, this makes it clear that the variables and mixins that are used within the passed block are related to the other styles around where the block is defined. For example:

```scss
#sidebar {
  $sidebar-width: 300px;
  width: $sidebar-width;
  @include smartphone {
    width: $sidebar-width / 3;
  }
}
```

## 7 函数指令

Sass 支持自定义函数，并能在任何属性值或 SassScript 中使用：

```scss
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $guttter-width;
}

#sidebar {
  width: grid-width(5);
}
```

编译为

```scss
#sidebar {
  width: 240px;
}
```

和 `mixin` 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 `@return` 输出结果。

自定义的函数也可以使用关键词参数，上方的例子可以这样写：

```scss
#sidebar {
  width: grid-width($n: 5);
}
```

建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码的时候也会知道这不是 Sass 或者 CSS 的子代功能。

自定义函数和 `mixin` 相同，都支持参数变量。

## 8 输出格式

Sass 提供了四种输出格式，可以通过 `:style option` 选项设定，或者在命令行中使用 `--style` 选项。

### 8.1 `:nested`

Nested 样式时 Sass 默认的输出格式，能够清晰反映 CSS 和 HTML 的结构关系。选择器和属性等单独占用一行，缩进量和 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这样格式可以很容易分析文件的主要结构。

```scss
#main {
  color: #fff;
  background-color: #000; }
  #main p {
    width: 10em; }

.huge {
  font-size: 10em;
  font-weight: bold;
  text-decoration: underline; }
```

### 8.2 `:expanded`

`:expanded` 的输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。

```scss
#main {
  color: #fff;
  background-color: #000;
}
#main p {
  width: 10em;
}
.huge {
  font-size: 10em;
  font-weight: bold;
  text-decoration: underline;
}
```

### 8.3 `:compact`

`:compact` 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。

```scss
#main { color: #fff; background-color: #000; }
#main p { width: 10em; }

.huge { font-size: 10em; font-weight: bold; text-decoration: underline; }
```

### 8.4 `:compressed`

`:compressed` 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如自动替换占用空间最小的颜色表达方式。