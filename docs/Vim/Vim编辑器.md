# Vim 编辑器

## 移动

- `h` 或 退格：左移一个字符
- `l` 或 空格：右移一个字符
- `j`：下移一行
- `k`：上移一行
- `gj`：移动到一段内的下一行
- `gk`：移动到一段内的上一行
- `+` 或 `Enter`：移动到下一行第一个非空白字符
- `-`：移动到上一行第一个非空白字符
- `w`：后移一个单词，光标停在下一个单词开头
- `W`：移动到下一个单词开头，但忽略一些标点，以空格作为参考
- `e`：后移一个单词，光标停在下一个单词的末尾
- `E`：移动到下一个单词的末尾
- `b`：前移一个单词，光标停在单词的开头
- `B`：移动到前一个单词开头，忽略一些标点
- `ge`：前移一个单词，光标停在上一个单词的末尾
- `gE`：同 ge ，不过单词包含相邻的标点
- `(`：前移一句
- `)`：后移一句
- `{`：前移一段
- `}`：后移一段
- `fc`：把光标移动到同一行的下一个 c 字符处
- `Fc`：把光标移动到同一行的上一个 c 字符处
- `tc`：把光标移动到同一行的下一个 c 字符前
- `Tc`：把光标移动到同一行的上一个 c 字符后
- `Ctrl + f`：向下滚动一页
- `Ctrl + b`：向上滚动一页
- `Ctrl + u`：向上滚动半屏
- `Ctrl + d`：向下滚动半屏

上面的操作都可以配合 n 使用，比如正常模式下输入 3h，则光标向左移动 3 个字符。

- `0`：移动到行首
- `g0`：移动到所在屏幕行行首
- `^`：移动到本行第一个非空白字符
- `g^`：移动到所在屏幕行第一个非空字符处
- `$`：移动到行尾
- `g$`：移动到所在屏幕行行尾
- `nl`：移动到第 n 列
- `nG`：移动到第 n 行
- `:n<cr>`：移动到第 n 行
- `:$<cr>`：移动到最后一行
- `H`：把光标移到屏幕最顶端一行
- `M`：把光标移到屏幕最底端一行
- `L`：把光标移到屏幕最底端一行
- `gg`：到文件头部
- `G`：到文件尾部
- `zz`：将当前光标所在的行移动到屏幕的中间

## 插入

### 基本插入

- `i`：在光标前插入；一个小技巧：按 8 ，再按 i，进入插入模式，输入 =，按 esc 进入命令模式，就会出现 8 个 =。这在插入分割线时非常有用，如：30 i + \<esc\> 插入了 30 个 + 组成的分割线
- `l`：在当前行第一个非空字符前插入
- `gl`：在当前行第一列插入
- `a`：在光标后插入
- `A`：在当前行最后插入
- `o`：在下面新建一行插入
- `O`：在上面新建一行插入
- `:r filename`：在当前位置插入另一个文件的内容
- `:[n] r filename`：在第 n 行插入另一个文件的内容
- `:r !date`：在光标处插入当前日期与时间。同理，:r !command 可以将其他 shell 命令的输出插入到当前文档

### 改写插入

- `c[n]w`：改写光标后的 1(n) 个词
- `c[n]l`：改写光标后的 1(n) 个字母
- `c[n]h`：改写光标前的 1(n) 个字母
- `ci{`：改写当前光标最近的 {} 中的所有内容
- `ca{`：改写当前光标最近的 {} 的所有内容，包含当前的 {} 符号
- `ci(`：改写当前光标最近的 () 中的所有内容
- `ca(`：改写当前光标最近的 () 中的所有内容，包含当前 () 符号
- `caw`：改写当前单词，即使光标不在鼠标的开头
- `[n]cc`：修改当前 1(n) 行
- `[n]s`：以输入的文本替代光标后的 1(n) 个字符，相当于 c[n]l
- `[n]S`：删除指定数目的行，并以所输入文本替代之，相当于 cc 命令

注意，类似 `cnw`、`dnw`、`ynw` 的形式同样可以写为 `ncw`、`ndw`、`nyw`

## 复制、黏贴和剪切

- `[n]x`：剪切光标右边 n 个字符，相当于 `d[n]l`
- `[n]X`：剪切光标左边 n 个字符，相当于 `d[n]h`
- `y`：复制可视模式下选中的文本
- `yy` or `Y`：复制整行文本
- `y[n]w`：复制 1(n) 个词
- `y[n]l`：复制光标右边 1(n) 个字符
- `y[n]h`：复制光标左边 1(n) 个字符
- `y$`：从光标当前位置复制到行尾
- `y0`：从光标当前位置复制到行首
- `:m,n<cr>`：复制 m 行到 n 行的内容
- `y1G` or `ygg`：复制光标以上的所有行
- `yG`：复制光标以下的所有行
- `yaw` or `yas`：复制一个词和复制一个句子，即使光标不在词首和句首也没有关系
- `d`：删除 (剪切)，在可视模式下选中的文本
- `d$` or `D`：删除 (剪切) 当前位置到行尾的内容
- `d[n]w`：删除 (剪切) 1(n)个单词
- `d[n]l`：删除 (剪切) 光标右边 1(n) 个字符
- `d[n]h`：删除 (剪切) 光标左边 1(n) 个字符
- `d0`：删除 (剪切) 当前位置到行首的内容
- `[n]dd`：删除 (剪切) 1(n) 行
- `m,nd<cr>`：剪切 m 行到 n 行的内容
- `d1G` or `dgg`：剪切光标以上的所有行
- `dG`：剪切光标以下的所有行
- `daw` 或 `das`：剪切一个词或者剪切一个句子，即使光标不在词首和句首也没有关系
- `d/f<cr>`：高级组合命令，它将删除当前位置到下一个 f 之间的内容
- `dfc`：删除当前光标到下一个 c 字符之间的内容 (包含 c)
- `dtc`：删除当前光标到下一个 c 字符之间的内容 (不包含 c)
- `p`：在光标之后黏贴
- `P`：在光标之前黏贴

## 寄存器

当你想要将多段文本从一个文件复制到另一个文件时，将每段文本复制到自己的寄存器可能会节省时间。

在这里，我们将使用命名为 `a` 到 `z` 的寄存器。若要将句子复制到命名为 `y` 的寄存器中，请键入 `"fyas`。命令 `yas` 会像以前一样复制一句话，然后 `"f` 的意思则是：将文本放到寄存器 `f` 中。

然后，你可以从寄存器中获取对应的文本并粘贴到正在编辑的行中，通过执行命令 `"fp`，文本会一直保留在寄存器中，直到你将其他内容放到对应的寄存器中，因此你可以根据你的需求多次放入它。

提醒一下，星号 (`*`) 寄存器是一个特殊的寄存器，允许复制并放入系统剪贴板，通过执行 `"*`。

另一个提醒，删除和更改文本也会将其保存到寄存器中。例如，你可以通过键入 `"fdaw` 以删除单词并将其保存到寄存器 `f` 中。

`register` 命令会显示每个寄存器上的文本，这个命令同样适用于 VSCode 和 JetBrains 两个 IDE。

## 宏

### 录制和回放命令：Vim 宏

在所有见过的 Vim 的功能中，宏应该是能给人最多的满足感的。

大家应该都知道 `.` 命令会重复上述更改。但是，如果想要重复任何事情，比如一系列的多个变化和动作，就可以使用宏，有三个步骤：

1. `q{register}` 命令将击键记录到寄存器中命名为 `{register}`。寄存器名称必须介于 `a` 和 `z` 的字母。

2. 键入命令。

3. 最后键入 `q` 就是完成录制。

现在，你就可以通过键入命令 `@{register}` 来执行宏。

可以看一个例子。你有一个如下所示的文件名列表：

```c
stdio.h
fcntl.h
unistd.h
stdlib.h
```

但是你希望它看起来像这样：

```c
#include "stdio.h"
#include "fcntl.h"
#include "unistd.h"
#include "stdlib.h"
```

很简单，只需要输入以下命令：

1. `qa`: 开始在寄存器 `a` 中录制宏。

2. `^`: 移动到行的开头。

3. `i#include "<ESC>`: 在行首插入字符串 `#include "`。

4. `$`: 移动到行的末尾。

5. `a"<ESC>`: 将双引号附加到行尾。

6. `j`: 转到下一行。

7. `q`: 停止录制宏。

现在你的寄存器中有一个宏，这个时候就可以通过键入 `@a` 命令三次来运行它了。`@a` 命令前可以有一个计数，因此在这种情况下，可以键入 `3@a`。

如果已经执行了 `@a` 一次操作，则可以使用 `@@` 再次运行该宏，这样打字就方便多了，如果现在使用 `@b` 执行寄存器 b，则下一个 `@@` 将使用寄存器 b。

顺便说一句，宏是可以递归的，你可以将宏放到宏里边，即使它是同一个宏。

### 宏和寄存器

或许你已经注意到了，寄存器既用于宏，也用于 yank 和 delete 命令。这有一些优点。

假设你在寄存器 `n` 中记录了几个命令。然后当你执行 `@n` 命令的时候，你会注意到你做错了某些事情，你可以再次尝试录制，但或许你会犯其他的错误，相反，你可以以下技巧：

- `G`: 转到文件末尾。

- `o<ESC>`: 创建一个空行。

- `"np`: 从寄存器 `n` 中拿出文本，并放置到当前行中，现在你可以在文件中看到以文本方式键入的命令了。

- `{edits}`: 更改错误的命令，这就像编辑文本一样。

- `0`: 转到行的开头。

- `"ny$`: 将更正的命令拉入寄存器 `n` 中。

- `dd`: 删除暂存线。

现在，你可以使用 `@n` 执行更正的命令。

这个技巧是 Unix 和 Vim 哲学的一个很好的例子：如果你知道如何修改文本，叠加一切都是由文本构成的，那么你可以做任何事情。

### 附加到 register

到目前为止，我们使用小写字母作为寄存器名称。若要追加到寄存器，可以使用大写字母。

假设你在寄存器 `c` 中录制了一个宏。它工作正常，但你想添加对单词的搜索。这可以通过 `qC` 来完成，它附加到寄存器 `c` 中：`qC/word<ENTER>q`。

这同样适用于宏，复制和删除命令，例如：`"AY` 将复制一行并将其附加到寄存器 `a` 中。

### 保存宏 `let` 命令

有两种方法可以保存宏供以后使用。

默认情况下，最简单的方法是 Vim 会自动保存你的寄存器，并在启动时恢复它们。(VSCode 不支持)。

第二种方法（特别是如果你认为你可能会意外覆盖它）是在你的 `.vimrc` 文件中使用命令 `:let`，例如：`let @a='0fa'`。

> 请记住，如果你的宏包含回车符或其他一些特殊字符，则需要在命令中 `:let` 显式编写它，例如 `<ENTER>`。但是具体请查阅编辑器和操作系统的文档，因为特殊字符很棘手。

JetBrains 支持 `:let` 命令，但是 VSCode 不支持 `:let` 命令。

## substitue 命令

通过 `:substitue` 命令，可以对整个行范围执行字符串替换。此命令的一般形式为：`:[range]substitue/from/to/[flags]`

这个命令的作用是：在指定的 `[range]` 范围中的行中，将指定的 `from` 字符串更改为 `to` 字符串。

`:substitute` 这个命令很少会有人完全拼写出来。大多数情况下，人们使用缩写版本 `:s`。

如果将 `%` 放置在 `[range]` 对应的位置上，那么 `:s` 命令就会在所有行上生效，但是如果 `[range]` 位置上没有任何内容，那么只会在当前行中生效。

默认情况下，该 `:substitute` 命令只会更改每一行的第一个匹配项，如果要更改一行中的每一个匹配项，你就需要添加全局标志 `g`，如：`:%s/from/to/g`。

当然，你也可以在宏中录制 `:substitute` 命令或者任何命令。

### 使用 substitute 命令中的 confirmation
