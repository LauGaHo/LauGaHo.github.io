<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/01/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-07-01T01:23:37.824Z" itemprop="datePublished">2021-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/01/hello-world/" data-id="ckqk8rdmr0009yg5ugbin5uk1" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：深入 JavaScript 继承原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/30/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%20JavaScript%20%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-30T09:29:09.945Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：深入-JavaScript-继承原理"><a href="#JS：深入-JavaScript-继承原理" class="headerlink" title="JS：深入 JavaScript 继承原理"></a>JS：深入 JavaScript 继承原理</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>我们回顾一下 ES6 /  TypeScript /  ES5 类的写法以做对比。首先我们创建一个 GithubUser 类，它拥有一个 login 方法，和一个静态方法 getPublicServices，用于获取 public 的方法列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GithubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getPublicServices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username</span><br><span class="line">        <span class="built_in">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + <span class="built_in">this</span>.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，ES6 这个类的写法有一个弊病，密码 password 应该是 Github 用户一个私有变量，接下来用 TypeScript 重写一下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GithubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getPublicServices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> username: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">private</span> password: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username</span><br><span class="line">        <span class="built_in">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> login(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + <span class="built_in">this</span>.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来，password 就只能在类的内部访问了。</p>
<p>结合原型讲解那一篇文章讲解的知识，来用 ES5 来实现这个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// private属性</span></span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="comment">// public属性</span></span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    <span class="comment">// public方法</span></span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">GithubUser.getPublicServices = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>值得注意的是，我们一般都会把共有的方法放在类的原型上，而不会采用 this.login = function () {} 这种写法。因为只有这样，才能让多个实例引用同一个共有方法，从而避免了重复创建方法的浪费。</strong></em></p>
<p>留下两个疑问：</p>
<p>1、如何实现 private 方法</p>
<p>2、能否实现 protected 属性 / 方法 </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果创建了一个 JuejinUser 来继承 GithubUser，那么 JuejinUser 及其实例就可以调用 Github 的login 方法了。首先，先写出这个简单的 JuejinUser 类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO need implementation</span></span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先概述几种继承方法：</p>
<ul>
<li>类式继承</li>
<li>构造函数式继承</li>
<li>组合式继承</li>
<li>原型继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ul>
<h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><p><em><strong>若通过 new Parent( ) 创建了 Child，则 Child.proto = Parent.prototype，而原型链则是顺着 proto 依次向上查找。因此，可以通过修改 子类的原型为父类的实例来实现继承</strong></em></p>
<p>第一直觉的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    JuejinUser.prototype = <span class="keyword">new</span> GithubUser(username, password)</span><br><span class="line">    JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br></pre></td></tr></table></figure>

<p>在浏览器中查看原型链：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/WMixMl.jpg" alt="alt"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/30/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%20JavaScript%20%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86/" data-id="ckqk8rdmp0006yg5u4rke3nf0" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：JavaScript 原型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/30/JS%EF%BC%9AJavaScript%20%E5%8E%9F%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-30T07:23:53.375Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：JavaScript-原型"><a href="#JS：JavaScript-原型" class="headerlink" title="JS：JavaScript 原型"></a>JS：JavaScript 原型</h1><h2 id="引入：普通对象与函数对象"><a href="#引入：普通对象与函数对象" class="headerlink" title="引入：普通对象与函数对象"></a>引入：普通对象与函数对象</h2><p>在 JavaScript 中，一直有一个说法，万物皆对象，事实上，对象也是有区别的，我们可以将其划分为 <em><strong>普通对象</strong></em> 和 <em><strong>函数对象</strong></em>。Object 和 Function 便是 JavaScript 自带的两个典型的函数对象，而函数对象就是一个纯函数，所谓的函数对象，其实就是使用 JavaScript 在模拟类。</p>
<p>那么究竟什么是普通对象，什么是函数对象，请看下方例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;language&#x27;</span>, <span class="string">&#x27;console.log(language)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ob1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ob2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">const</span> ob3 = <span class="keyword">new</span> fn1()</span><br></pre></td></tr></table></figure>

<p>打印以下结果，可以得到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob1); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob2); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob3); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn1); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn2); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn3); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，ob1、ob2、ob3为普通对象（均为 Object 的实例），而 fn1、fn2、fn3 均是 Function 的实例，称之为 函数对象。</p>
<p>如何区分，记住这句话就可以了：</p>
<p>所有的 Function 的实例都是函数对象，而其他的都是普通对象。</p>
<p>上面提到，Object 和 Function 均是函数对象，我们也说到了，所有的 Function 的实例都是函数对象，难道 Function 也是 Function 的实例？</p>
<p>保留这个疑问，我们做一个总结：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/S7IhPO.jpg" alt="alt"></p>
<p>从图中可以看出，对象本身的实现还是要依靠构造函数。那原型链到底是用来干嘛的？</p>
<p>众所周知，作为一门面向对象的语言，必定具有以下特征：</p>
<ul>
<li>对象唯一性</li>
<li>抽象性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<p>而原型链最大的目的，就是为了<strong>实现继承</strong>。</p>
<h2 id="进阶：prototype-和-proto"><a href="#进阶：prototype-和-proto" class="headerlink" title="进阶：prototype 和 proto"></a>进阶：prototype 和 proto</h2><p>原型链究竟是如何实现继承的？首先，先引入两兄弟：prototype 和 proto，这是在 JavaScript 中无处不在的两个变量（如果你经常调试的话），然而，这两个变量并不是在所有的对象上都存在，先看一张表：</p>
<p>​                    prototype           proto</p>
<p>普通对象            X                    V</p>
<p>函数对象            V                    V</p>
<p>首先，我们先给出结论：</p>
<p>1、只有函数对象具有 prototype 这个属性；</p>
<p>2、prototype 和 proto 都是 JavaScript 在定义一个函数对象时自动创建的预定义属性；</p>
<p>接下来我们验证上述的两个结论：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn.__proto__); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn.prototype); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ob = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob.__proto__); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob.prototype); <span class="comment">// undefined，哇！果然普通对象没有 prototype</span></span><br></pre></td></tr></table></figure>

<p>既然是语言层面的预置属性，那么两者究竟有什么区别？我们依然从结论出发，给出以下两个结论：</p>
<p>1、prototype 被实例的 proto 所指向（被动）</p>
<p>2、proto 指向构造函数的 prototype（主动）</p>
<p>也就是说以下代码成立：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ob.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>那么问题来了，既然 fn 是一个函数对象，那么 fn.prototype.proto到底等于什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>创建一个函数时，JavaScript 对该函数原型的初始化代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 自动执行</span></span><br><span class="line">fn1.protptype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: fn1,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="built_in">Object</span>.prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1.__proto__ = <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>

<p>普通对象就是通过函数对象实例化得到的，而一个实例不可能再次进行实例化，也就不会让另一个对象的 proto 指向它的 prototype，因此普通对象没有 prototype 属性这个结论就非常好理解了。而且我们也看出来了，fn1.prototype 就是一个普通对象，它也不存在 prototype 属性。</p>
<p>我们在上面还留下了一个疑问</p>
<ul>
<li>难道 Function 也是 Function 的实例？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="重点：原型链"><a href="#重点：原型链" class="headerlink" title="重点：原型链"></a>重点：原型链</h2><p>上面我们了解了 prototype 和 proto，实际上，这两兄弟主要就是为了构造原型链而存在的。</p>
<p>先看一段代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125; <span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125; <span class="comment">/* 2 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">&#125; <span class="comment">/* 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person(<span class="string">&#x27;ulivz&#x27;</span>, <span class="number">24</span>); <span class="comment">/* 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ulivz) <span class="comment">/* 5 */</span></span><br><span class="line"><span class="built_in">console</span>.log(ulivz.getName(), ulivz.getAge()) <span class="comment">/* 6 */</span></span><br></pre></td></tr></table></figure>

<p>解释一下执行细节：</p>
<ul>
<li>执行 1，创建了一个构造函数 Person，要注意，前面已经提到，此时 Person.prototype 已经被自动创建，它包含 constructor 和 proto这两个属性；</li>
<li>执行2，给对象 Person.prototype 增加了一个方法 getName()；</li>
<li>执行3，给对象 Person.prototype 增加了一个方法 getAge()；</li>
<li>执行4, 由构造函数 Person 创建了一个实例 ulivz，值得注意的是，一个构造函数在实例化时，一定会自动执行该构造函数。</li>
<li>在浏览器得到 5 的输出，即 ulivz 应该是：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;ulivz&#x27;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">     <span class="attr">__proto__</span>: <span class="built_in">Object</span> <span class="comment">// 实际上就是 `Person.prototype`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上面的结论，以下等式成立：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ulivz.__proto__ == Person.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行6的时候，由于在 ulivz 中找不到 getName() 和 getAge() 这两个方法，就会继续朝着原型链向上查找，也就是通过 proto 向上查找，于是，很快在 ulviz.proto 中，即 Person.prototype 中找到了这两个方法，于是停止查找并执行得到结果。</li>
</ul>
<p><em><strong>这便是 JavaScript 的原型继承。准确的说，JavaScript 的原型继承时通过 proto 并借助 prototype 来实现的。</strong></em></p>
<p>于是便有以下总结：</p>
<p>1、函数对象的 proto 指向 Function.prototype；</p>
<p>2、instance.proto 指向函数对象的 prototype；</p>
<p>3、普通对象的 proto 指向 Object.prototype；</p>
<p>4、普通对象没有 prototype 属性；</p>
<p>5、在访问一个对象的某个属性 / 方法的时候，如果在当前对象上没有找到，则会尝试 ob.proto，也就是访问该对象的构造函数的原型 obCtr.prototype，如果还是找不到，会继续查找 obCtr.prototype.proto，依次查找下去，若在某一刻，找到了该属性，则会立刻返回值并停止对原型链的搜索，若找不到，则返回 undefined。</p>
<p>为了加深理解，参考以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ulivz.proto == <span class="built_in">Function</span>.prototype);	<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.proto == <span class="built_in">Function</span>.prototype);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.proto == <span class="built_in">Object</span>.prototype);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.proto == <span class="built_in">Object</span>.prototype);	<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.proto == <span class="built_in">Function</span>.prototype);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="终极：原型链图"><a href="#终极：原型链图" class="headerlink" title="终极：原型链图"></a>终极：原型链图</h2><p>上面我们还遗留了一个问题：</p>
<ul>
<li>如果原型链一直找不到的话，那么什么时候停止，原型链的尽头在哪？</li>
</ul>
<p>我们可以用代码验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(ulivz.name);</span><br></pre></td></tr></table></figure>

<p>很明显，会输出 undefined。简述查找过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ulivz                <span class="comment">// 是一个对象，可以继续 </span></span><br><span class="line">ulivz[<span class="string">&#x27;name&#x27;</span>]           <span class="comment">// 不存在，继续查找 </span></span><br><span class="line">ulivz.__proto__            <span class="comment">// 是一个对象，可以继续</span></span><br><span class="line">ulivz.__proto__[<span class="string">&#x27;name&#x27;</span>]        <span class="comment">// 不存在，继续查找</span></span><br><span class="line">ulivz.__proto__.__proto__          <span class="comment">// 是一个对象，可以继续</span></span><br><span class="line">ulivz.__proto__.__proto__[<span class="string">&#x27;name&#x27;</span>]     <span class="comment">// 不存在, 继续查找</span></span><br><span class="line">ulivz.__proto__.__proto__.__proto__       <span class="comment">// null !!!! 停止查找，返回 undefined</span></span><br></pre></td></tr></table></figure>

<p>最后来看一下上一节的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125; <span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125; <span class="comment">/* 2 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">&#125; <span class="comment">/* 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person(<span class="string">&#x27;ulivz&#x27;</span>, <span class="number">24</span>); <span class="comment">/* 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ulivz) <span class="comment">/* 5 */</span></span><br><span class="line"><span class="built_in">console</span>.log(ulivz.getName(), ulivz.getAge()) <span class="comment">/* 6 */</span></span><br></pre></td></tr></table></figure>

<p>我们来画一个原型链图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/MbRe8T.jpg" alt="alt"></p>
<p>画完这张图，所有疑问都已经得到了解答了。</p>
<h2 id="调料：Constructor"><a href="#调料：Constructor" class="headerlink" title="调料：Constructor"></a>调料：Constructor</h2><p>前面已经有所提及了，只有原型对象才具有 constructor 这个属性，constructor 用来指向引用它的函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor === Person <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor.prototype.constructor === Person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这是一种循环引用。</p>
<h2 id="补充：JavaScript-中的-6-大内置（函数）对象的原型继承"><a href="#补充：JavaScript-中的-6-大内置（函数）对象的原型继承" class="headerlink" title="补充：JavaScript 中的 6 大内置（函数）对象的原型继承"></a>补充：JavaScript 中的 6 大内置（函数）对象的原型继承</h2><p>通过前文的论述，结合相应的代码验证，整理出以下原型链图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/dsJdGM.jpg" alt="alt"></p>
<p>由此可见，我们更加强化了这两个观点；</p>
<p>1、任何内置函数对象（类）本身的 proto 都指向 Function 的原型对象；</p>
<p>2、除了 Object 的原型对象的 proto 指向 null，其他所有内置函数对象的原型对象的 proto 都指向 Object.prototype；</p>
<p>请看以下代码：</p>
<p><em><strong>Array</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];		</span><br><span class="line">		<span class="built_in">console</span>.log(arr.__proto__)</span><br><span class="line">		<span class="built_in">console</span>.log(arr.__proto__ == <span class="built_in">Array</span>.prototype)   <span class="comment">// true </span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__== <span class="literal">null</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>RegExp</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(reg.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(reg.__proto__ == <span class="built_in">RegExp</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>Date</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(date.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(date.__proto__ == <span class="built_in">Date</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>Boolean</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boo = <span class="keyword">new</span> <span class="built_in">Boolean</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(boo.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(boo.__proto__ == <span class="built_in">Boolean</span>.prototype) <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>Number</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Number</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>String</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(str.__proto__ == <span class="built_in">String</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>若 A 通过 new 创建了 B，那么 B.proto == A.prototype；</li>
<li>proto 是原型链查找的起点；</li>
<li>执行 B.a，若在 B 中找不到 a，则会在 B.proto 中，也就是 A.prototype 中查找，若 A.prototype 中仍然没有，则会继续向上查找，最终，一定会找到 Object.prototype，倘若还找不到，因为 Object.prototype.proto 指向 null，因此一定会返回 undefined。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/30/JS%EF%BC%9AJavaScript%20%E5%8E%9F%E5%9E%8B/" data-id="ckqk8rdmg0000yg5u0fip96b6" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：从执行上下文视角讲 this" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/30/JS%EF%BC%9A%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%86%E8%A7%92%E8%AE%B2%20this/" class="article-date">
  <time class="dt-published" datetime="2021-06-30T02:43:36.122Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：从执行上下文视角讲-this"><a href="#JS：从执行上下文视角讲-this" class="headerlink" title="JS：从执行上下文视角讲 this"></a>JS：从执行上下文视角讲 this</h1><p>观察以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    <span class="attr">myName</span>:<span class="string">&quot;time.geekbang.com&quot;</span>,</span><br><span class="line">    <span class="attr">printName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myName)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">return</span> bar.printName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line"><span class="keyword">let</span> _printName = foo()</span><br><span class="line">_printName()</span><br><span class="line">bar.printName()</span><br></pre></td></tr></table></figure>

<p>这里其实是个障眼法，只需要确定好函数调用栈就可以轻松地回答，调用了 foo( ) 后，返回的是 bar.printName，后续就跟 foo 函数没有关系了，所以结果就是调用了两次 bar.printName( ) 函数，根据词法作用域，结果都是 “极客邦”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构确定的。</p>
<p>不过按照常理来说，调用 bar.printName 方法时，该方法内部的变量 myName 应该使用 bar 对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的。所以在对象内部的方法中使用对象内部的属性是一种非常普遍的的需求，但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出了另外一套 this 机制。</p>
<p>所以在 JavaScript 中可以使用 this 实现在 printName 函数中访问到 bar 对象中的 myName 属性了。具体的代码，如下显示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-中的-this"><a href="#JavaScript-中的-this" class="headerlink" title="JavaScript 中的 this"></a>JavaScript 中的 this</h2><p>关于 this，我们还是得从执行上下文说起，其实执行上下文中包含了变量环境、词法环境、外部环境，但其实还有一个 this 没有提及，具体可以参考下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/VZ8Dym.jpg" alt="alt"></p>
<p>从图中可以看出，this 是和执行上下文绑定的，也就是说每个执行上下文都有一个 this。执行上下文包含了：全局执行上下文、函数执行上下文、eval执行上下文。</p>
<h2 id="全局执行上下文中的-this"><a href="#全局执行上下文中的-this" class="headerlink" title="全局执行上下文中的 this"></a>全局执行上下文中的 this</h2><p>全局执行上下文中输入 console.log( this )，最终输出的是 window 对象，这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。</p>
<h2 id="函数执行上下文中的-this"><a href="#函数执行上下文中的-this" class="headerlink" title="函数执行上下文中的 this"></a>函数执行上下文中的 this</h2><p>重点分析函数执行上下文，先看代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这段代码打印出来的也是 window 对象，这说明在默认情况下调用一个函数，其执行上下文也是指向 window 对象的。但是我们可以设置执行上下文中的 this 来指向其他对象，通常有三种方式来设置函数执行上下文中的 this 值。</p>
<h3 id="1、通过函数的-call-方法设置"><a href="#1、通过函数的-call-方法设置" class="headerlink" title="1、通过函数的 call 方法设置"></a>1、通过函数的 call 方法设置</h3><p>可以通过函数的 call 方法来设置函数执行上下文的 this 指向，比如下面的这段代码，我们就并没有直接调用 foo 函数，而是调用了 foo 的call 函数，并将 bar 对象作为 call 方法的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot; 极客邦 &quot;</span>,</span><br><span class="line">  <span class="attr">test1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar)</span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="built_in">console</span>.log(myName)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，观察输出，就可以发现 foo 函数内部的 this 已经指向了 bar 对象，因为通过打印 bar 对象，可以看出 bar 的 myName 属性已经由 “极客邦” 变为 “极客时间” 了，同时在全局执行上下文中打印 myName，JavaScript 引擎提示该变量未定义。</p>
<p>其实除了 call 方法，还可以使用 bind 和 apply 方法来设置函数执行上下文的 this，它们在使用上还是有一些区别的。</p>
<h3 id="2、通过对象调用方法设置"><a href="#2、通过对象调用方法设置" class="headerlink" title="2、通过对象调用方法设置"></a>2、通过对象调用方法设置</h3><p>要改变函数执行上下文中的 this 指向，除了通过函数的 call 方法来实现以外，还可以通过对象调用的方式，比如下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们定义了一个 myObj 对象，该对象是由一个 name 属性和一个 showThis 方法组成的，然后再通过 myObj 对象来调用 showThis 方法。执行这段代码，你可以看到，最终输出的 this 值是指向 myObj 的。</p>
<p>所以，你可以得出这样的结论：使用对象来调用其内部的方法，该方法的 this 是指向对象本身的。</p>
<p>也可以这样认为 JavaScript 引擎在执行 myObject.showThis( ) 时，将其转化为了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.showThis.call(myObj)</span><br></pre></td></tr></table></figure>

<p>接下来我们稍微改变下调用方式，把 showThis 赋给一个全局对象，然后再调用该对象，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot; 极客邦 &quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>执行这段代码，你会发现 this 指向又是全局 window 对象。</p>
<p>所以通过以上两个例子的对比，你可以得出下面这样的结论：</p>
<p>在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。</p>
<p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。</p>
<h3 id="3、通过构造函数中设置"><a href="#3、通过构造函数中设置" class="headerlink" title="3、通过构造函数中设置"></a>3、通过构造函数中设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;极客时间&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObje = <span class="keyword">new</span> CreateObj();</span><br></pre></td></tr></table></figure>

<p>在这段代码中，使用了 new 创建了对象 myObj。</p>
<p>其实，当执行 new CreateObj( ) 的时候，JavaScript 引擎做了如下四件事：</p>
<ul>
<li>首先创建了一个空对象 tempObj；</li>
<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；</li>
<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>
<li>最后返回 tempObj 对象；</li>
</ul>
<p>为了直观理解，我们用代码来演示一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>

<p>这样，我们就通过 new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。</p>
<h2 id="this-的设计缺陷以及应对方案"><a href="#this-的设计缺陷以及应对方案" class="headerlink" title="this 的设计缺陷以及应对方案"></a>this 的设计缺陷以及应对方案</h2><p>this 并不是一个很好的设计，因为它很多使用方法都冲击人的直觉，在使用过程中比较多坑，下面来看看 this 的设计缺陷</p>
<h3 id="1、嵌套函数中的-this-不会从外层函数中继承"><a href="#1、嵌套函数中的-this-不会从外层函数中继承" class="headerlink" title="1、嵌套函数中的 this 不会从外层函数中继承"></a>1、嵌套函数中的 this 不会从外层函数中继承</h3><p>分析一段代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>我们在这段代码的 showThis 方法中添加了一个 bar 方法，然后接着在 showThis 函数中调用了 bar 函数，那么现在的问题是：bar 函数中的 this 是什么？</p>
<p>如果是刚刚接触 JavaScript，那么会很自然地觉得，bar 中的 this 应该和其外层 showThis 函数中的 this 是一致的都是指向 myObj 对象，这很符合人的直觉。但是实际情况却并非如此，执行这段代码后，发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象，这就是 JavaScript 中容易让人迷惑的地方之一，也是很多问题的源头。</p>
<p>可以通过一个小技巧来解决这一个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      self.name = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，你会发现它也输出了我们想要的结果，最终 myObj 中的 name 属性值变成了 “极客邦”。其实这个方法的本质就是把 this 体系转换成了作用域体系。</p>
<p>同样的也可以使用 ES6 中的箭头函数来解决这个问题，结合一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，会发现它也输出了我们想要的结果，也就是说箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p>
<p>通过上面的讲解，你应该知道了 this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。解决这个问题，有两种思路：</p>
<ul>
<li>把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。</li>
<li>继续使用 this，但是需要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。</li>
</ul>
<h3 id="2、普通函数中的-this-默认指向全局对象-window"><a href="#2、普通函数中的-this-默认指向全局对象-window" class="headerlink" title="2、普通函数中的 this 默认指向全局对象 window"></a>2、普通函数中的 this 默认指向全局对象 window</h3><p>在默认情况下，调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。</p>
<p>不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式就是说通过 call 方法来实现调用。</p>
<p>这个问题可以通过设置 JavaScript 的 “严格模式” 来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是undefined，这就解决上面的问题了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/30/JS%EF%BC%9A%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%86%E8%A7%92%E8%AE%B2%20this/" data-id="ckqk8rdmo0004yg5u98jiajd3" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/30/JS%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8CJS%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T16:13:09.185Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择"><a href="#JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择" class="headerlink" title="JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择"></a>JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择</h1><p>理解作用域链时理解闭包的基础，而闭包在 JavaScript 中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。</p>
<p>首先先来看这一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>你觉得这段代码中的 bar 函数和 foo 函数打印出来的是什么吗？</p>
<p>分析代码，当代码执行到 bar 函数内部，调用栈的状态如图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/7amvbs.jpg" alt="alt"></p>
<p>从图中可以看出，全局执行上下文和 foo 函数的执行上下文中都包含变量 myName，那 bar 函数中的 myName应该选择哪一个呢？这里就需要了解作用域链了。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>其实每一个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部因你用哪个称为 outer。</p>
<p>当一段代码使用了一个变量，JavaScript 引擎首先会在“当前执行上下文”中查找该变量，比如上面的那段代码在查找 myName 变量时，如果在当前的变量环境中没有查到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以直接看下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/zRdlhw.jpg" alt="alt"></p>
<p>从图中可以看到，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎就会去全局执行上下文中查找。我们把这个查找的链条就称作为作用域链。</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><em><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong></em></p>
<p>可以直接看下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/zcmf66.jpg" alt="alt"></p>
<p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域 -&gt; bar 函数作用域 -&gt; main 函数作用域 -&gt; 全局作用域。</p>
<p>回过头看上边的代码，foo 函数调用了 bar 函数，但是 bar 函数的外部引用是全局执行上下文。</p>
<p>因为词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个没有定义的变量，那么它们就会到全局作用域中寻找，故，词法作用域是代码阶段就决定好的，和函数的调用没有关系。</p>
<h2 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客世界 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> myName = <span class="string">&quot;Chrome 浏览器 &quot;</span></span><br><span class="line">        <span class="built_in">console</span>.log(test)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">        bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中，对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，调用栈的情况如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/%E4%B8%8B%E8%BD%BD.png" alt="alt"></p>
<p>现在是执行到 bar 函数的 if 语句块之内，需要打印出来的变量 test，那么久需要查找到 test 变量的值，其查找过程我已经在上图中使用了序号1、2、3、4、5标记出来了。</p>
<p>下面我就来解释一下这个过程。首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有 定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>了解了作用域链，接着就可以了解闭包了。关于闭包，理解起来稍微有一点难度。结合以下代码就可以理解什么是闭包了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>首先我们看看当执行到 foo 函数内部的 return innerBar 这行代码时，调用栈的情况你可以参考此图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/uPznOY.jpg" alt="alt"></p>
<p>从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。</p>
<p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数结束了，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/20NJwJ.jpg" alt="alt"></p>
<p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然存在在内存当中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p>
<p>之所以时专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。</p>
<p>最后给闭包完整的定义，在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合统称为闭包。比如外部函数 foo，那么这些变量的集合就称为 foo 函数的闭包。</p>
<p>闭包的使用。当执行到 bar.setName 方法中的 myName = “极客邦” 这句代码时，JavaScript 引擎会沿着 “当前执行上下文 -&gt; foo 函数闭包 -&gt; 全局执行上下文” 的顺序来查找 myName 变量，你可以参考下面调用栈状态图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/RxMYdM.jpg" alt="alt"></p>
<p>从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以当调用 setName 时，会修改 foo 闭包中的 myName 变量的值。</p>
<p>同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。</p>
<p>可以通过 “开发者工具” 来看看闭包的情况，打开 Chrome 的 “开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/cEAEuG.jpg" alt="alt"></p>
<p>从图中可以看出来，当调用 bar.getName 的时候，右边 Scope 就体现了作用域链的情况：Local 就是当前的 getName 函数的作用域，Closure( foo )是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从 “Local -&gt; Closure( foo ) -&gt; Global” 就是一个完整的作用域链。</p>
<p>所以，可以通过 Scope 来查看实际代码作用域链的情况。</p>
<h2 id="闭包的回收"><a href="#闭包的回收" class="headerlink" title="闭包的回收"></a>闭包的回收</h2><p>通常如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但是如果这个闭包以后不再使用就会导致内存泄漏。</p>
<p>所以在使用闭包的时候，尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存比较大的话，那就尽量让它成为一个局部变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/30/JS%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8CJS%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/" data-id="ckqk8rdmn0002yg5u26oxf8up" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：块级作用域，var缺陷以及为什么引入let、const" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/25/JS%EF%BC%9A%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cvar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5let%E3%80%81const/" class="article-date">
  <time class="dt-published" datetime="2021-06-25T09:45:12.951Z" itemprop="datePublished">2021-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：块级作用域，var缺陷以及为什么引入let、const"><a href="#JS：块级作用域，var缺陷以及为什么引入let、const" class="headerlink" title="JS：块级作用域，var缺陷以及为什么引入let、const"></a>JS：块级作用域，var缺陷以及为什么引入let、const</h1><h2 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h2><p><strong>作用域是指在程序中定义变量的区域，该位置决定了变量的声明周期，通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</strong></p>
<p>在 ES6 之前，ES 的作用域只有两种，全局作用域和函数作用域。</p>
<ul>
<li>全局作用域中的对象在代码中的任何地方都能访问，其声明周期伴随着页面的声明周期。</li>
<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或函数只能在函数内部被访问。函数执行结束后，函数内部定义的变量就会被销毁。</li>
</ul>
<p>在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则普遍支持块级作用域。块级作用域就是使用一对大括号包裹的代码，比如函数、判断语句、循环语句、甚至单独的一个 { } 都可以被看作一个块级作用域。</p>
<p>为了更好地理解块级作用域，参考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if块</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while块</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//for循环块</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独一个块</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，如果一个语言支持块级作用域，那么其代码块内部定义的变量在代码块外是访问不到的，并且等该代码块执行完成后，代码块中定义的变量会被销毁。</p>
<h2 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h2><p>由于变量提升的问题，使用 JavaScript 来编写和其他语言相同的逻辑的代码，都有可能产生不一样的结果。主要有以下两种原因</p>
<h3 id="1、变量容易在不被察觉的情况下被覆盖掉"><a href="#1、变量容易在不被察觉的情况下被覆盖掉" class="headerlink" title="1、变量容易在不被察觉的情况下被覆盖掉"></a>1、变量容易在不被察觉的情况下被覆盖掉</h3><p>比如我们使用 JavaScript 实现以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot;极客时间&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> myname = <span class="string">&quot;极客邦&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">&#125;</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure>

<p>打印出来的结果是 undefined 。</p>
<p>直接展示最终的调用栈状态如下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/iZeQCb.jpg" alt="alt"></p>
<p>showName 函数的执行上下文创建后，JavaScript 引擎便开始执行 showName 函数内部的代码了。首先执行的是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myname);</span><br></pre></td></tr></table></figure>

<p>JavaScript 会优先从当前的执行上下文中查找变量，由于变量提升，所以当前执行上下文就包括了变量 myname，并且值是 undefined。所以获取得到的值就是 undefined。</p>
<h3 id="2、本应销毁的变量没有销毁"><a href="#2、本应销毁的变量没有销毁" class="headerlink" title="2、本应销毁的变量没有销毁"></a>2、本应销毁的变量没有销毁</h3><p>再看看这一段误解更大的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>如果使用 C语言或者其他大部分的语言实现类似的代码，在for循环结束之后，i 就已经被销毁了，但是在JavaScript 代码中，i 的值未被销毁，所以最后打印出来的值为 7 。</p>
<h2 id="ES6-如何解决变量提升带来的问题"><a href="#ES6-如何解决变量提升带来的问题" class="headerlink" title="ES6 如何解决变量提升带来的问题"></a>ES6 如何解决变量提升带来的问题</h2><p>为了解决变量提升带来的问题，ES6 引入了 let 和 const 关键字，使得 JavaScript 也像其他语言一般拥有了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">6</span></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">y = <span class="number">9</span> <span class="comment">//报错，const声明的变量不可以修改</span></span><br></pre></td></tr></table></figure>

<p>从这段代码中，可以看出使用 let 关键字的变量可以改变值，使用 const 关键字的变量则不可以改变的。</p>
<p>参考一段存在变量提升的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有两个地方定义了变量 x，由于使用 var 关键字，在编译阶段会生成如下的执行上下文</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/6r82N9.jpg" alt="alt"></p>
<p>最终只生成了一个 x 值，并且函数体内所有对 x 的赋值操作都会直接改变变量环境中的 x 值。所以上述代码最后通过console.log( x )输出的应该是 2 。而其他语言最后一步输出的应该是 1。如果要让他支持块级作用域只需要将 var 关键字改成 let 关键字即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码的输出结果就和我们的预期是一致的。</p>
<h2 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h2><p>观察以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当执行上面这段代码的时候，JavaScript 引擎线对其进行编译并创建上下文，然后再按照顺序执行代码，关于如何创建上下文已经分析过了，但是现在的情况有点不一样，let 关键字会创建块级作用域，那么 let 关键字如何影响执行上下文的，接下来一步步分析</p>
<p><strong>第一步、编译并创建执行上下文</strong></p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/ZuNPJi.jpg" alt="alt"></p>
<p>通过上图，可以得出结论：</p>
<ul>
<li>函数内部通过 <strong>var</strong> 声明的变量，在编译阶段全被存到变量环境当中。</li>
<li>通过 <strong>let</strong> 声明的变量，在编译阶段会存放到 <strong>词法环境（Lexical Environment）</strong>中。</li>
<li>在函数的作用域内部，通过 <strong>let</strong> 声明的变量没有被存放到词法环境中。</li>
<li>继续执行代码，当执行到代码块中，变量环境中的a已经设置为1，词法环境中的b设置为了2。</li>
</ul>
<p>这时函数的执行上下文就如下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/yjmTSJ.jpg" alt="alt"></p>
<p>从图中可以看出，当进入了函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</p>
<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是最外层的变量，进入了一个作用域中，就会把该作用域内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意一下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>再接下来，当执行到作用域块中的console.log( a )这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方法：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有找到，那么继续在变量环境中查找。</p>
<p>这样一个变量查找的过程就完成了，你可以参考下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/ChGluo.jpg" alt="alt"></p>
<p>从上图可以清晰看到查找变量的流程，不过要完整理解查找变量或者查找函数的流程，就需要涉及到作用域链了。</p>
<p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/vpNfIR.jpg" alt="alt"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/25/JS%EF%BC%9A%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cvar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5let%E3%80%81const/" data-id="ckqk8rdmn0003yg5u6zm86pzc" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：深入理解 JavaScript - 执行上下文" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/25/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20JavaScript%20-%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" class="article-date">
  <time class="dt-published" datetime="2021-06-25T08:30:27.703Z" itemprop="datePublished">2021-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：深入理解-JavaScript-执行上下文"><a href="#JS：深入理解-JavaScript-执行上下文" class="headerlink" title="JS：深入理解 JavaScript - 执行上下文"></a>JS：深入理解 JavaScript - 执行上下文</h1><p>JS 每次执行回调函数，会把方法以 <strong>执行上下文</strong> 的方式压入 <strong>执行栈</strong> ，执行完会被弹出执行栈。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>而 <strong>执行上下文</strong> 的结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/Wm3r0E.jpg" alt="alt"></p>
<p>从上图可以了解到，执行上下文分为了两个环境，一个是 <strong>变量环境（VariableEnvironment）</strong>，另一个是 <strong>词法环境（LexicalEnvironment）</strong>，其中这两个环境之间的差别就在于，<strong>变量环境</strong> 是登记对应的 <strong>var、function</strong> 的声明。而另外的 <strong>词法环境</strong> 是用来登记对应的 <strong>let、const、class</strong> 等变量声明。<strong>词法环境</strong> 的出现是为了实现块级作用域的同时不影响 <strong>var、function</strong> 声明。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>先看一段代码，观察其输出结果是什么</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname);</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot;极客时间&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数showName被执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数showName被执行</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>按照顺序执行的逻辑来看，这段代码是无法执行的，但是结果这段代码不但没有报错，并且能够正常输出。</p>
<p>出现这个非正常的现象的原因就在于一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成后，才会进入执行阶段。</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><h3 id="第一部分：变量提升的代码。"><a href="#第一部分：变量提升的代码。" class="headerlink" title="第一部分：变量提升的代码。"></a>第一部分：变量提升的代码。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数showName被执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二部分：执行部分代码。"><a href="#第二部分：执行部分代码。" class="headerlink" title="第二部分：执行部分代码。"></a>第二部分：执行部分代码。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname);</span><br><span class="line">myname = <span class="string">&quot;极客时间&quot;</span></span><br></pre></td></tr></table></figure>

<p>下图就是把 Javascript 的执行流程细化，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/vNRkwQ.jpg" alt="alt"></p>
<p>你可以简单认为变量环境对象是如下结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; <span class="literal">undefined</span>, </span><br><span class="line">     showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>

<p>我们详细分析一下代码是如何生成变量环境对象的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;极客时间&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;函数showName被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第1行和第2行，由于这两行代码不是声明操作，所以JavaScript引擎不会做任何处理；</li>
<li>第3行，由于这行是经过var声明的，因此JavaScript引擎将在环境对象中创建一个名为myname的属性，并使用undefined对其初始化；</li>
<li>第4行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建一个showName的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript的执行堆和执行栈我会在后续文章中介绍）。 这样就生成了变量环境对象。接下来JavaScript引擎会把声明以外的代码编译为字节码，至于字节码的细节，我也会在后面文章中做详细介绍，你可以类比如下的模拟代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line">myname = <span class="string">&#x27;极客时间&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><ul>
<li>当执行到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出“函数showName被执行”结果。</li>
<li>接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。</li>
<li>接下来执行第3行，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”，变量环境如下所示：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; <span class="string">&quot;极客时间&quot;</span>, </span><br><span class="line">     showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/25/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20JavaScript%20-%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" data-id="ckqk8rdmq0007yg5u846dbyjp" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：深入理解JavaScript - 词法环境" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/25/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%20-%20%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/" class="article-date">
  <time class="dt-published" datetime="2021-06-25T03:20:05.832Z" itemprop="datePublished">2021-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：深入理解JavaScript-词法环境"><a href="#JS：深入理解JavaScript-词法环境" class="headerlink" title="JS：深入理解JavaScript - 词法环境"></a>JS：深入理解JavaScript - 词法环境</h1><p>JS引擎中的栈桢有一个专业名称叫做**执行上下文 (Execution Context)**，紧接着就是一大串的名词：Lexical Environment Execution Context 变量对象 作用域链 原型链 this 闭包等等。</p>
<h2 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h2><p>V8引擎JS的编译执行过程，大致上分为了三个阶段：</p>
<ul>
<li>第一步：V8刚拿到执行上下文的时候，会将代码从上到下一行一行的先做分词 / 词法分析。分词指的是：比如 var a =    2；这段代码，会被分词成：var a 2和；这样的原子符号；词法分析是指：登记变量声明，函数声明，函数声明的行参。</li>
<li>第二步：在分词结束后，会做代码解析，引擎将token解析翻译成一个AST (抽象语法树)，这一步的时候，如果发现语法错误，就会直接报错，不再往下执行。</li>
<li>第三步：引擎生成 CPU 可以执行的机器码</li>
</ul>
<p>在第一步有个词法分析，它用来登记变量声明，函数声明，函数声明的形参，后续代码执行的时候就知道去哪里拿变量的值和函数了，这个登记的地方就是<strong>Lexical Environment (词法环境)</strong></p>
<p>词法环境有两个组成部分：</p>
<ul>
<li><strong>1：环境记录（Environment Record）</strong>，这个就是真正登记变量的地方<ul>
<li><strong>1.1：声明式环境记录（Declarative Environment Record）</strong>，用来记录直接有标识符定义的元素，比如变量、常量、let、class、module、import以及函数声明。</li>
<li><strong>1.2：对象式环境记录（Object Environment Record）</strong>，主要用于with、global的词法环境。</li>
</ul>
</li>
<li><strong>2：对外部词法环境的引用（outer）</strong>，它是作用域链能够连起来的关键。</li>
</ul>
<p>其中 <strong>声明式环境记录（Declarative Environment Record）</strong>，又分为两种类型：</p>
<ul>
<li><strong>函数环境记录（Function Environment Record）</strong>：用于函数作用域。</li>
<li><strong>模块环境记录（Module Environment Record）</strong>：模块环境记录用于体现一个模块的外部作用域，即模块 export 所在环境</li>
</ul>
<p>词法环境与我们自己写的代码结构相对应，也就是我们自己代码写成什么样子，词法环境就成什么样子。词法环境式在代码定义的时候决定的，跟代码在哪调用没有关系，所以说JavaScript采用的是词法作用域（静态作用域）。</p>
<p>我们来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a * b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure>

<p>它的词法环境关系图如下：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/qvxwBg.jpg" alt="alt"></p>
<p>我们可以用伪代码来模拟上面代码的词法环境：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局词法环境</span></span><br><span class="line">GlobalEnvironment = &#123;</span><br><span class="line">    <span class="attr">outer</span>: <span class="literal">null</span>, <span class="comment">//全局环境的外部环境引用为null</span></span><br><span class="line">    <span class="attr">GlobalEnvironmentRecord</span>: &#123;</span><br><span class="line">        <span class="comment">//全局this绑定指向全局对象</span></span><br><span class="line">        [[GlobalThisValue]]: ObjectEnvironmentRecord[[BindingObject]],</span><br><span class="line">        <span class="comment">//声明式环境记录，除了全局函数和var，其他声明都绑定在这里</span></span><br><span class="line">        <span class="attr">DeclarativeEnvironmentRecord</span>: &#123;</span><br><span class="line">            <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">y</span>: <span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//对象式环境记录，绑定对象为全局对象</span></span><br><span class="line">        <span class="attr">ObjectEnvironmentRecord</span>: &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">foo</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span><br><span class="line"><span class="function">            <span class="title">baz</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="function">            <span class="title">isNaNl</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">            <span class="title">isFinite</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">parseInt</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">parseFloat</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">Array</span>: &lt;&lt; <span class="title">construct</span> <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">Object</span>: &lt;&lt; <span class="title">construct</span> <span class="function"><span class="keyword">function</span>&gt;&gt;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            ...</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            ...</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        &#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">foo</span>函数词法环境</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">fooFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">GlobalEnvironment</span>,//外部词法环境引用指向全局环境</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        <span class="title">bar</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt; </span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">bar</span>函数词法环境</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">barFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">fooFunctionEnviroment</span>,//外部词法环境引用指向<span class="title">foo</span>函数词法环境</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        <span class="title">b</span>: 3</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">baz</span>函数词法环境</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">bazFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">GlobalEnvironment</span>,//外部词法环境引用指向全局环境</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">        <span class="title">a</span>: 10</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span><br></pre></td></tr></table></figure>

<p>我们可以看到词法环境和我们定义代码定义一一对应，每个词法环境都有一个outer指向上一层的词法环境，当运行上方的代码，函数 bar 的词法环境里没有变量 a，所以就会到它的上一层词法环境去找（foo 词法环境）。foo 函数词法环境中也没有 a。然后沿着 foo词法环境一直往上找，在全局词法环境中找到了 var a = 2，沿着 outer 一层层找变量的值就是作用域链。如果找到第一个就会停止，如果在全局词法环境还是找不到，就会停止查找并返回 null，因为全局词法环境里的 outer 是 null。就会报 ReferenceError。</p>
<h2 id="变量提升-vs-函数提升"><a href="#变量提升-vs-函数提升" class="headerlink" title="变量提升 vs 函数提升"></a>变量提升 vs 函数提升</h2><p>V8 引擎执行代码分为三步，先做分词和词法分析，然后解析生成AST，最后生成机器码执行代码，词法分析时会生成词法环境登记变量，对于变量声明和函数声明，词法环境的处理不一样的。</p>
<p>在词法分析的时候：</p>
<ul>
<li>对于变量声明，<strong>var a = 2；</strong>，<strong>let x = 1；</strong>，给变量分配内存并初始化为 undefined，赋值语句是在第三步生成机器码真正执行代码的时候才执行的。</li>
<li>对于函数声明，**function foo ( ) { . . . }**，会在内存里创建函数对象，并且直接初始化为该函数对象。</li>
</ul>
<p>这就是 JS 的<strong>变量提升和函数提升</strong>，我们来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionDec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functionDec();</span><br></pre></td></tr></table></figure>

<p>最后运行的结果是：undefined</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/5eLpjb.jpg" alt="alt"></p>
<p>如果整个变量就没有定义，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionDec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functionDec();</span><br></pre></td></tr></table></figure>

<p>运行代码，结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">ReferenceError</span>: c is not defined</span><br><span class="line">    at functionDec (&lt;anonymous&gt;:<span class="number">4</span>:<span class="number">17</span>)</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">8</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/25/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%20-%20%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/" data-id="ckqk8rdmr0008yg5udw4d2ql4" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：展开运算符" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/24/JS%EF%BC%9A%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time class="dt-published" datetime="2021-06-24T09:50:41.735Z" itemprop="datePublished">2021-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：展开运算符"><a href="#JS：展开运算符" class="headerlink" title="JS：展开运算符"></a>JS：展开运算符</h1><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符 ( . . . )"></a>展开运算符 ( . . . )</h2><p>展开运算符，是 ES6 中的新语法，是把可迭代的对象 ( string, object, 数组 )展开，可以用在函数调用 / 数组构造的时候，将数组表达式 / string 在语法层面展开，还可以将对象表达式按照 key-value 的方式展开。</p>
<p>展开运算符只能用于可迭代对象。</p>
<p><strong>函数调用：</strong></p>
<p>假如你把 . . . 放在函数的参数里，就说明这个参数必须是 interable object，然后这个对象就会被展开成为函数的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> someIterable = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">func(...someIterable);</span><br><span class="line"><span class="comment">// same as func(&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(-<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(...[-<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(-<span class="number">1</span>, ...[-<span class="number">5</span>, <span class="number">11</span>], <span class="number">3</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr1.push(...arr2); <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>数组构造或字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...numbers, <span class="string">&#x27;4&#x27;</span>, ...<span class="string">&#x27;hello&#x27;</span>, <span class="number">6</span>];) <span class="comment">// Array [1, 2, 3, &quot;4&quot;, &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parts = [<span class="string">&#x27;shoulders&#x27;</span>, <span class="string">&#x27;knees&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> lyrics = [<span class="string">&#x27;head&#x27;</span>, ...parts, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;toes&#x27;</span>]; <span class="comment">//  [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr];</span><br><span class="line">arr2.push(<span class="number">4</span>); <span class="comment">// arr2 此时变成了 [1,2,3,4]. arr不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接多个数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2]; <span class="comment">// [0,1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象拷贝（浅拷贝，并且不包含prototype）和合并</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>:<span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">foo</span>:<span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>:<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> cloneObj = &#123;...obj1&#125;; <span class="comment">// &#123;foo:&#x27;bar&#x27;, x:42&#125;</span></span><br><span class="line"><span class="keyword">var</span> mergeObj = &#123;...obj1, ...obj2&#125;; <span class="comment">// &#123;foo:&#x27;baz&#x27;, x:42, y:13&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>函数参数收集</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 foo([1, 2, 3, 4, 5, 6])</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p><strong>为对象增加属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> basicSquirtle = &#123; <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> fullSquirtle = &#123;</span><br><span class="line">  ...basicSquirtle,</span><br><span class="line">  <span class="attr">species</span>: <span class="string">&#x27;Tiny Turtle&#x27;</span>,</span><br><span class="line">  <span class="attr">evolution</span>: <span class="string">&#x27;Wartortle&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullSquirtle); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, species: &#x27;Tiny Turtle&#x27;, evolution: &#x27;Wartortle&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>复制具有嵌套结构的数据 / 对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span>,</span><br><span class="line">  <span class="attr">abilities</span>: [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain Dish&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon &#125;;</span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">&#x27;Charmander&#x27;</span>;</span><br><span class="line">pokemon.abilities.push(<span class="string">&#x27;Surf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squirtleClone); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, abilities: [ &#x27;Torrent&#x27;, &#x27;Rain Dish&#x27;, &#x27;Surf&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p>当我们修改原对象的 name 属性时，我们的克隆对象的 name 属性没有受到影响，这个符合预期。</p>
<p>但是当我们修改原对象的 abilities 属性时，我们的克隆对象也被修改了。</p>
<p>原因很简单，因为复制过来的 abilities 时一个引用类型，原数据改了，用到它的地方也会跟着改。</p>
<p>知道原因，再解决就很简单了</p>
<p><strong>复制引用类型的数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span>,</span><br><span class="line">  <span class="attr">abilities</span>: [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain Dish&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon, <span class="attr">abilities</span>: [...pokemon.abilities] &#125;;</span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">&#x27;Charmander&#x27;</span>;</span><br><span class="line">pokemon.abilities.push(<span class="string">&#x27;Surf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squirtleClone); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, abilities: [ &#x27;Torrent&#x27;, &#x27;Rain Dish&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>增加条件属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abilities = [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain dish&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPokemon = abilities ? &#123; ...pokemon, abilities &#125; : pokemon;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullPokemon);</span><br></pre></td></tr></table></figure>

<p><strong>短路</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abilities = [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain dish&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPokemon = &#123;</span><br><span class="line">  ...pokemon,</span><br><span class="line">  ...(abilities &amp;&amp; &#123; abilities &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullPokemon);</span><br></pre></td></tr></table></figure>

<p>如果 abilities 为 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullPokemon = &#123;</span><br><span class="line">  ...pokemon,</span><br><span class="line">  ...&#123; abilities &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/24/JS%EF%BC%9A%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/" data-id="ckqk8rdmp0005yg5u1upcfxuq" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JS：Map 和 Set" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/24/JS%EF%BC%9AMap%20%E5%92%8C%20Set/" class="article-date">
  <time class="dt-published" datetime="2021-06-24T09:36:19.860Z" itemprop="datePublished">2021-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS：Map-和-Set"><a href="#JS：Map-和-Set" class="headerlink" title="JS：Map 和 Set"></a>JS：Map 和 Set</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map是JS(ES6)的一种字典数据结构，key值不重复，如果有重复，就会覆盖前面的，任何值都可以作为Map的key，包括对象，字符，数字，NaN，symbol。</p>
<p>Map跟Object很像，但是Object只能用string / symbol作为key，Map可以通过size获取键值个数，而Object只能手动计算。</p>
<p>在JS中，NaN === NaN是false，不过在Map中，NaN却被认为是同一个key：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>但是对于Object的Key，不同的对象，代表的key值不同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().set(&#123;&#125;, <span class="number">1</span>).set(&#123;&#125;, <span class="number">2</span>).size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>Map有以下3种创建方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emptyMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">.set(<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">.set(<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>复制Map：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">.set(<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="keyword">new</span> <span class="built_in">Map</span>(original);</span><br></pre></td></tr></table></figure>

<p>通过 key 拿到 value：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 123</span></span><br><span class="line">map.get(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>其他 Map 的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .has() checks if a Map has an entry with a given key</span></span><br><span class="line">map.has(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .delete() remove entries</span></span><br><span class="line">map.delete(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">map.has(<span class="string">&#x27;foo&#x27;</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .size retrun the number of entries in a Map</span></span><br><span class="line">map1.size; <span class="comment">//2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .clear() removes all entries of a Map</span></span><br><span class="line">map1.clear();</span><br><span class="line">map1.size; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">  .set(<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .keys() returns an iterable over the keys of a Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">of</span> map2.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// output: false true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we can use spreading(...) to convert iterable returned by .keys() to an Array</span></span><br><span class="line">[... map2.keys()] <span class="comment">// [false, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .values() quite like .keys(), but for values instead of keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.entries() return an interable over the entries of a Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map2.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">//output:</span></span><br><span class="line">    <span class="comment">//[false, &#x27;no&#x27;]</span></span><br><span class="line">    <span class="comment">//[ture, &#x27;yes&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we can use sperading(...) to convert iterable returned by .entries() to an Array;</span></span><br><span class="line">[...map.entries()] <span class="comment">// [[false, &#x27;no&#x27;], [true, &#x27;yes&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we also can use below way to access key and value</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">    <span class="comment">// output:</span></span><br><span class="line">    <span class="comment">//false, &#x27;no&#x27;</span></span><br><span class="line">    <span class="comment">//true, &#x27;yes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只要 Map 只含有 strings 和 symbols 作为 key，那么就可以直接把这个 Map 转为 Object：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map); <span class="comment">// &#123; a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以把 Object 转换为 Map：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// new Map([[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]])</span></span><br></pre></td></tr></table></figure>

<p>应用：计算字符串中，字符出现的次数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countChars</span>(<span class="params">chars: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> charsCounts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> chars) &#123;</span><br><span class="line">    ch = ch.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> prevCount = charCounts.get(ch);</span><br><span class="line">    charCounts.set(ch, prevCount ? prevCount + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> charsCounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要像数组一样，map 和 filter，那么就必须要把 Map 先转化成为数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">		.set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">		.set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">		.set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mappedMap = <span class="keyword">new</span> <span class="built_in">Map</span>( <span class="comment">//step 3</span></span><br><span class="line">		[...originalMap] <span class="comment">// step 1</span></span><br><span class="line">  			.map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v]) <span class="comment">// step 2</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 相当于：new Map([[2, &#x27;_a&#x27;], [4, &#x27;_b&#x27;], [6, &#x27;_c&#x27;]])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredMap = <span class="keyword">new</span> <span class="built_in">Map</span>( <span class="comment">// step 3</span></span><br><span class="line">		[...originalMap] <span class="comment">// step 1</span></span><br><span class="line">  			.filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>) <span class="comment">// step 2</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 相当于：new Map([[1, &#x27;a&#x27;], [2, &#x27;b&#x27;]])</span></span><br></pre></td></tr></table></figure>

<p>如果想要合并两个 Map：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">		.set(<span class="number">1</span>, <span class="string">&#x27;1a&#x27;</span>)</span><br><span class="line">		.set(<span class="number">2</span>, <span class="string">&#x27;1b&#x27;</span>)</span><br><span class="line">		.set(<span class="number">3</span>, <span class="string">&#x27;1c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">		.set(<span class="number">2</span>, <span class="string">&#x27;2b&#x27;</span>)</span><br><span class="line">		.set(<span class="number">3</span>, <span class="string">&#x27;2c&#x27;</span>)</span><br><span class="line">		.set(<span class="number">4</span>, <span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combinedMap = <span class="keyword">new</span> <span class="built_in">Map</span>([...map1, ...map2]);</span><br><span class="line"><span class="comment">// 相当于：new Map([[1, &#x27;1a&#x27;], [2, &#x27;2b&#x27;], [3, &#x27;2c&#x27;], [4, &#x27;2d&#x27;]])</span></span><br></pre></td></tr></table></figure>

<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 跟 Map 非常像，只不过多了以下限制：</p>
<ul>
<li><p>WeakMap 就是一个黑盒子</p>
<ul>
<li>我们不能直接通过 keys / values / entries 来 iterate 或者是 loop WeakMap，并且不能计算它的size。</li>
<li>我们不能清除 WeakMap，如有需要，只能重新创建一个。</li>
</ul>
</li>
<li><p>WeakMap 的 key，必须是 objects</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(<span class="number">123</span>, <span class="string">&#x27;test&#x27;</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure></li>
<li><p>WeakMap 的 key 是弱饮用</p>
<ul>
<li><p>正常来说，如果有对象还被引用，那么就不会被垃圾回收。但是 WeakMap 不一样，在 object 作为 key 的时候，是可以被垃圾回收的，这会导致整个 entry 也被删掉，并且这个没有办法检测到这种行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  vm.set(obj, <span class="string">&#x27;attachedValue&#x27;</span>); <span class="comment">// (A)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (Bc)</span></span><br></pre></td></tr></table></figure>

<p>在 (A) 这一行我们给 obj 这个 key 赋值，但是在 (B) 这一行，obj 这个 entry 就有可能被垃圾回收掉了，但是 vm 还在，并且没有办法手动删掉 vm</p>
</li>
</ul>
<p>应用：</p>
<ul>
<li><p>用 WeakMap 来保存计算结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countOwnKeys</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(obj))  &#123;</span><br><span class="line">    <span class="keyword">return</span> [cache.get(obj), <span class="string">&#x27;cached&#x27;</span>];</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">    cache.set(obj, count);</span><br><span class="line">    <span class="keyword">return</span> [count, <span class="string">&#x27;computed&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用 WeakMap 来保存 private data</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">counter, action</span>)</span> &#123;</span><br><span class="line">        _counter.set(<span class="built_in">this</span>, counter);</span><br><span class="line">        _action.set(<span class="built_in">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = _counter.get(<span class="built_in">this</span>);</span><br><span class="line">        counter--;</span><br><span class="line">        _counter.set(<span class="built_in">this</span>, counter);</span><br><span class="line">        <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">            _action.get(<span class="built_in">this</span>)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WeakMap 的方法有：</p>
</li>
<li><p>new WeakMap( )</p>
</li>
<li><p>.delete( key )</p>
</li>
<li><p>.get( key )</p>
</li>
<li><p>.has( key )</p>
</li>
<li><p>.set( key, value )</p>
</li>
</ul>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 跟数组很像，但是成员的值都是唯一的，没有重复的值，并且 Set 对象允许存储任何类型的值，无论是原始值或者是对象引用。Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<p>有以下三种方式创建 Set：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emptySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">		.add(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">		.add(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">		.add(<span class="string">&#x27;blue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>常用的 Set 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .add() adds an element to a Set</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> set();</span><br><span class="line">set.add(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .has() checks if an elements is a member of a Set</span></span><br><span class="line">set.has(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .delete() removes an element from a Set</span></span><br><span class="line">set.delete(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">set.has(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .size contains the number of elements in a Set</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  .add(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  .add(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">set1.size; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .clear() removes all elements of a Set</span></span><br><span class="line">set1.clear(); </span><br><span class="line">set1.size; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterating over Sets</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> set2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="comment">//outouts:</span></span><br><span class="line">    <span class="comment">//&#x27;red&#x27;</span></span><br><span class="line">    <span class="comment">//&#x27;green&#x27;,</span></span><br><span class="line">    <span class="comment">//&#x27;blue&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use spreading(...) to convert set to array</span></span><br><span class="line"><span class="keyword">const</span> set3 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...set3]; <span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>应用</p>
<p>移除数组中的重复项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set4 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...set4]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>字符串是 iterable，所以也可以作为 Set 的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]); <span class="comment">// 这两个是一样的</span></span><br></pre></td></tr></table></figure>

<p>NaN 对于 Set 来说也是一个值，对于任何 Object 都是不同的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]);</span><br><span class="line">set.size; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([&#123;&#125;, &#123;&#125;]);</span><br><span class="line">set1.size; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>Union 两个 Set：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]); <span class="comment">// new Set([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>

<p>Intersection 两个 Set：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(</span><br><span class="line">		[...a]</span><br><span class="line">  	.filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x))</span><br><span class="line">); <span class="comment">// new Set([2, 3])</span></span><br></pre></td></tr></table></figure>

<p>Difference 两个 Set：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>(</span><br><span class="line">  [...a]</span><br><span class="line">  .filter(<span class="function"><span class="params">x</span>=&gt;</span> !b.has(x))</span><br><span class="line">); <span class="comment">// new Set([1, 4])</span></span><br></pre></td></tr></table></figure>

<p>Mapping over Set:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> mappedSet = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span>=&gt;</span>x*<span class="number">2</span>)); <span class="comment">// new Set([2,4,6])</span></span><br></pre></td></tr></table></figure>

<p>Filtering Set:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> filteredSet = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">x</span>=&gt;</span>(x%<span class="number">2</span>)===<span class="number">0</span>)); <span class="comment">// new Set([2,4])</span></span><br></pre></td></tr></table></figure>

<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 跟 Set 很像，只不过多了下面的限制：</p>
<ul>
<li>WeakSet 是个黑盒子<ul>
<li>我们不能直接通过 keys / values / entries 来 iterate 或者 loop WeakMap，并且不能计算它的size。</li>
<li>我们不能清除 WeakSet，如有需要，只能重新创建一个。</li>
</ul>
</li>
<li>WeakSet 的 key 是弱引用<ul>
<li>正常来说，如果有对象还被引用，那么就不会 被垃圾回收。但是 WeakSet 不一样，在 object 作为 key 的时候，是可以被垃圾回收的，这会导致整个 entry 也被删掉，并且这个没有办法检测到这种行为</li>
</ul>
</li>
</ul>
<p>WeakSet 的方法有：</p>
<ul>
<li>new WeakSet( )</li>
<li>.delete( value )</li>
<li>.get( value )</li>
<li>.has( value )</li>
<li>.set( value )</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/24/JS%EF%BC%9AMap%20%E5%92%8C%20Set/" data-id="ckqk8rdml0001yg5ubgi4e6v1" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/01/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/06/30/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%20JavaScript%20%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/30/JS%EF%BC%9AJavaScript%20%E5%8E%9F%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/30/JS%EF%BC%9A%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%86%E8%A7%92%E8%AE%B2%20this/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/30/JS%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8CJS%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>