<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue 笔记</title>
      <link href="/2021/11/22/Vue%20%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/22/Vue%20%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-笔记"><a href="#Vue-笔记" class="headerlink" title="Vue 笔记"></a>Vue 笔记</h1><h2 id="Object-defineProperty-方法"><a href="#Object-defineProperty-方法" class="headerlink" title="Object.defineProperty 方法"></a><code>Object.defineProperty</code> 方法</h2><ul><li>通过 <code>Object.defineProperty</code> 方法为对象生成的属性是不可被枚举的 (也就是不可以被遍历的) ，不可被修改，不可被删除</li><li>若想通过 <code>Object.defineProperty</code> 方法为对象生成的属性可以被枚举，就需要进行以下的操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">//默认值为 false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>若想通过 <code>Object.defineProperty</code> 方法为对象生成的属性可以被修改，就需要进行以下的操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//默认值为 false</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">//默认值为 false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>若想通过 <code>Object.defineProperty</code> 方法为对象生成的属性可以被删除，就需要进行以下的操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//默认值为 false</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">//默认值为 false</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">//默认值为 false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>若想通过 <code>Object.defineProperty</code> 方法为对象的属性绑定一个对象的地址，需要进行以下操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当有人读取 person.age 就会调用 get 函数，且返回值是 age 的值</span></span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当有人修改 person.age 就会调用 set 函数，且会收到修改的具体值</span></span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  number = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue-中的数据代理"><a href="#Vue-中的数据代理" class="headerlink" title="Vue 中的数据代理"></a>Vue 中的数据代理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;宏福科技园&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建了数据代理之后，就可以通过下面的方式来访问 data 中的数据</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.name);</span><br><span class="line"><span class="built_in">console</span>.log(vm.address);</span><br></pre></td></tr></table></figure><ul><li>上方的代码中，初始化 Vue 实例的参数对象中的 <code>data</code> 属性对应的对象地址是存放在 Vue 实例中的 <code>_data</code> 属性当中的。然后读取 <code>_data</code> 中的属性，为里边的属性创建数据代理。在上方的例子中就是在 Vue 实例中创建 <code>name</code> 属性和 <code>address</code> 属性的数据代理，意思就是在 Vue 中增加了 <code>name</code> 和 <code>address</code> 属性。Vue 创建数据代理的方式就是使用 <code>Object.defineProperty</code> 这个方法。总结来说 Vue 的数据代理就是通过 vm 对象来代理 <code>data</code> 对象中的属性操作。</li></ul><h2 id="Vue-事件处理"><a href="#Vue-事件处理" class="headerlink" title="Vue 事件处理"></a>Vue 事件处理</h2><ul><li>使用 <code>v-on:xxx</code> 或 <code>@xxx</code> 绑定事件，其中  <code>xxx</code> 是事件名</li><li>事件的回调需要配置在 <code>methods</code> 对象中，最终会在 vm 上</li><li><code>methods</code> 中配置的函数，不要用箭头函数，否则 <code>this</code> 就不是 vm 了</li><li><code>methods</code> 中配置的函数，都是被 Vue 所管理的函数，<code>this</code> 的指向是 vm 或组件实例对象</li><li><code>@click = &quot;demo&quot;</code> 和 <code>@click = &quot;demo($event)&quot;</code> 效果一致，但后者可以传参</li></ul><h2 id="Vue-事件修饰符"><a href="#Vue-事件修饰符" class="headerlink" title="Vue 事件修饰符"></a>Vue 事件修饰符</h2><ul><li>prevent：阻止默认事件</li><li>stop：阻止事件冒泡</li><li>once：事件只触发一次</li><li>capture：使用事件的捕获模式</li><li>self：只有 <code>event.target</code> 是当前操作的元素才触发事件</li><li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕</li></ul><h2 id="Vue-计算属性"><a href="#Vue-计算属性" class="headerlink" title="Vue 计算属性"></a>Vue 计算属性</h2><ul><li><p>计算属性：需要用到的属性不存在，要通过已有属性计算得来</p></li><li><p>原理：底层借助了 <code>Object.defineProperty</code> 方法提供的 <code>getter</code> 和 <code>setter</code></p></li><li><p><code>get</code> 函数在初次读取时会执行一次；当依赖数据发生改变时会被再次调用</p></li><li><p>与 <code>methods</code> 相比，计算属性具有缓存机制，效率更高</p></li><li><p>计算属性最终会出现在 vm 上，直接读取使用即可</p></li><li><p>如果计算属性要被修改，那必须写 <code>set</code> 函数去响应修改，且 <code>set</code> 中要引起计算时依赖的数据发生改变</p></li><li><p>Vue 计算属性响应式更新原理：</p><ul><li><p>计算属性更新过程</p><ul><li>首先 b 属性会被处理成存取器属性，访问 b 就会触发其 <code>get</code> 函数，从而会执行 <code>this.b</code>，于是就触发了 b 的 <code>get</code> 函数。</li><li>b 的 <code>get</code> 函数会添加 b 属性的依赖项，而刚才在处理计算属性的过程中，a 已经作为依赖项传给了一个全局变量，b 的 <code>get</code> 函数会检测到这个全局变量，并将其添加到自身的订阅者列表中。</li><li>对 b 赋予新的值时，会触发其 <code>set</code> 函数，<code>set</code> 函数中会遍历执行订阅者，a 的值就是在这个时候更新的。</li></ul></li><li><p>计算属性初始化及响应式更新代码</p><ul><li><p><strong>实现 <code>defineReactive</code></strong></p><ul><li><p>它用于初始化 <code>data</code> 中的数据，转为存取器。<code>get</code>：该函数通过闭包，维护每一个属性单独的 <code>deps</code>，定义计算属性时，计算属性绑定的函数引用了哪些 <code>data</code> 中的属性，就会触发对应的 <code>get</code> 函数，向该属性的 <code>deps</code> 中添加响应函数。设置 <code>data</code> 值时，会将闭包的 <code>deps</code> 中所有函数，全部遍历执行一遍</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义全局属性，用于向dep传送计算属性函数</span></span><br><span class="line"><span class="keyword">var</span> Dep = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deps = [];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Dep) &#123;</span><br><span class="line">        deps.push(Dep)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      val = newVal;</span><br><span class="line">      deps.forEach(<span class="function"><span class="params">func</span> =&gt;</span> func())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实现 <code>defineComputed</code></p><ul><li><p>它用于在定义计算属性时，如果绑定函数引用了 Vue 实例 <code>data</code> 对象中的属性，则会向该属性 <code>deps</code> 中添加绑定函数的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span>(<span class="params">obj, key, func</span>) </span>&#123;</span><br><span class="line">  func = func.bind(obj);</span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="comment">// 首次定义计算属性，会将第一次的函数执行结果返回给该计算属性，</span></span><br><span class="line">  <span class="comment">// 此后由于闭包，以后该计算属性的value值，会由deps中的函数返回值来决定。</span></span><br><span class="line">  Dep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    value = func();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Dep中value&#x27;</span>,value)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 执行一次func，函数引用了哪些data中属性，就会触发get方法，向该属性的dep中添加响应函数</span></span><br><span class="line">  <span class="comment">// 在这又使用了闭包，保存计算结果，在get中返回出去</span></span><br><span class="line">  value = func();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;defineComputed中value&#x27;</span>,value)</span><br><span class="line">  <span class="comment">// 销毁Dep</span></span><br><span class="line">  Dep = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 获取计算属性时，返回函数计算结果</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 返回函数结果</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h2 id="Vue-监视属性"><a href="#Vue-监视属性" class="headerlink" title="Vue 监视属性"></a>Vue 监视属性</h2><ul><li>当监视的属性变化时，回调函数自动调用，进行相关操作</li><li>监视的属性必须存在，才能进行监视，<code>data</code> 属性和 <code>computed</code> 属性都可以被监视</li><li>监视属性的两种写法：<code>new Vue</code> 时传入 <code>watch</code> 配置；通过 <code>vm.$watch</code> 监视</li></ul><h2 id="Vue-深度监视"><a href="#Vue-深度监视" class="headerlink" title="Vue 深度监视"></a>Vue 深度监视</h2><ul><li>Vue 中的 <code>watch</code> 默认不监视对象内部值的改变 (一层)</li><li>配置 <code>deep: true</code> 可以监视对象内部值的改变 (多层)</li><li>Vue 自身可以监测对象内部值的改变，但 Vue 提供的 <code>watch</code> 默认不可以</li><li>使用 <code>watch</code> 时根据数据的具体结构，决定是否采用深度监视</li></ul><h2 id="Vue-watch-对比-computed"><a href="#Vue-watch-对比-computed" class="headerlink" title="Vue watch 对比 computed"></a>Vue watch 对比 computed</h2><ul><li><code>computed</code> 能完成的功能，<code>watch</code> 都可以完成</li><li><code>watch</code> 能完成的功能，<code>computed</code> 不一定能完成，例如：<code>watch</code> 可以进行异步操作</li><li>所有被 Vue 管理的函数，最好写成普通函数，这样 <code>this</code> 的指向才是 <code>vm</code> 或者组件示例对象</li><li>所有不被 Vue 所管理的函数 (定时器的回调函数、ajax 的回调函数等) ，最好写成箭头函数，这样 <code>this</code> 的指向才是 <code>vm</code> 或者组件实例对象</li></ul><h2 id="Vue-style-和-class-绑定"><a href="#Vue-style-和-class-绑定" class="headerlink" title="Vue style 和 class 绑定"></a>Vue style 和 class 绑定</h2><ul><li>class 样式：<ul><li>字符串写法：适用于类名不确定，要动态获取</li><li>对象写法：适用于要绑定多个样式，个数不确定，名字也不确定</li><li>数组写法：适用于要绑定多个样式，个数确定，名字也确定，但不确定用还是不用</li></ul></li><li>style 样式：<ul><li><code>:style = &quot;&#123;fontSize: xxx&#125;&quot;</code> 其中 xxx 是动态值</li><li><code>:style = &quot;[a, b]&quot;</code> 其中 a、b 是样式对象</li></ul></li></ul><h2 id="Vue-条件渲染"><a href="#Vue-条件渲染" class="headerlink" title="Vue 条件渲染"></a>Vue 条件渲染</h2><ul><li><code>v-if</code><ul><li><code>v-if = &quot;xxx&quot;</code></li><li><code>v-else-if = &quot;xxx&quot;</code></li><li><code>v-else = xxx</code></li><li>适用于切换频率比较低的场景，不展示的 DOM 元素直接被移除掉，配合使用时不能被打断</li></ul></li><li><code>v-show</code><ul><li><code>v-show = &quot;xxx&quot;</code></li><li>适用于切换频率较高的场景，不展示的 DOM 元素不会被移除，仅仅是使用样式隐藏掉</li></ul></li><li>使用 <code>v-if</code> 的时候，元素可能无法获取到，但使用 <code>v-show</code> 就能被获取到</li></ul><h2 id="Vue-列表渲染"><a href="#Vue-列表渲染" class="headerlink" title="Vue 列表渲染"></a>Vue 列表渲染</h2><ul><li><code>v-for</code> <ul><li>用于展示列表数据</li><li>语法：<code>v-for = &quot;(item, index) in xxx&quot; :key = &quot;yyy&quot;</code></li><li>可遍历：数组、对象、字符串 (用得少)、指定次数 (用得少)</li></ul></li></ul><h2 id="Vue-中-key-的作用与原理"><a href="#Vue-中-key-的作用与原理" class="headerlink" title="Vue 中 key 的作用与原理"></a>Vue 中 key 的作用与原理</h2><ul><li>虚拟 DOM 中 key 的作用<ul><li>key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据新数据生成新的虚拟 DOM，随后 Vue 进行新虚拟 DOM 与旧虚拟 DOM 的差异比较。比较规则在下面说明</li></ul></li><li>对比规则<ul><li>旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key<ul><li>若虚拟 DOM 中内容没有发生改变，直接使用之前的真实 DOM</li><li>若虚拟 DOM 中内容发生了改变，则直接生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li></ul></li><li>旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key<ul><li>创建新的真实 DOM，随后渲染到页面</li></ul></li></ul></li><li>用 index 作为 key 可能会引发的问题<ul><li>若对数据进行：逆序添加、逆序删除等操作会产生没有必要的真实 DOM 更新，导致效率低下</li><li>如果结构中还包含输入类 DOM 会产生错误 DOM 更新，导致界面有问题</li></ul></li><li>开发中如何选择 key<ul><li>最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。</li></ul></li></ul><h2 id="Vue-监视数据的原理"><a href="#Vue-监视数据的原理" class="headerlink" title="Vue 监视数据的原理"></a>Vue 监视数据的原理</h2><ul><li>Vue 会监视 data 中所有层次的数据</li><li>如何监测对象中的数据<ul><li>通过 <code>setter</code> 实现监测，且要在 <code>new Vue</code> 时就传入要监测的数据<ul><li>对象中后追加的属性，Vue 默认不做响应式处理</li><li>如需给后添加的属性做响应式，请使用如下的 API：<code>Vue.set(target, propertyName/index, value)</code> 或 <code>vm.$set(target, propertyName/index, value)</code></li></ul></li></ul></li><li>如何监测数组中的数据<ul><li>通过包裹数组更新元素的方法实现，本质上就是做了两件事情<ul><li>调用原生对应的方法对数组进行更新</li><li>重新解析模板，进而更新页面</li></ul></li></ul></li><li>在 Vue 修改数组中的某个元素一定要用如下方法<ul><li>使用这些 API：<code>push(), pop(), shift(), unshift(), splice(), sort(), reverse()</code></li><li>或者使用：<code>Vue.set()</code> 或者 <code>vm.$set()</code></li><li>特别注意，<code>Vue.set()</code> 和 <code>vm.$set()</code> 不能给 vm 或者 vm 的根数据对象添加属性</li></ul></li></ul><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><ul><li><code>&lt;input type=&quot;text&quot;/&gt;</code>。则 <code>v-model</code> 收集的是 value 值，用户输入的就是 value 值</li><li><code>&lt;input type=&quot;radio&quot;/&gt;</code>。则 <code>v-model</code> 收集的是 value 值，且要给标签配置 value 值。</li><li><code>&lt;input type=&quot;checkbox&quot;/&gt;</code><ul><li>没有配置 <code>input</code> 的 value 值，那么收集的就是 checked (布尔值)</li><li>配置 <code>input</code> 的 value 属性：<ul><li><code>v-model</code> 的初始值是非数组，那么收集的就是 checked (布尔值)</li><li><code>v-model</code> 的初始值是数组，那么收集的就是 value 组成的数组</li></ul></li><li>备注：<code>v-model</code> 的三个修饰符<ul><li><code>lazy</code>：失去焦点再收集数据</li><li><code>number</code>：输入字符串转为有效的数字</li><li><code>trim</code>：输入首尾空格过滤</li></ul></li></ul></li></ul><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul><li>定义：对要显示的数据进行特定格式化后再显示 (适用于一些简单逻辑的处理)</li><li>语法：<ul><li>注册过滤器：<code>Vue.filter(name, callback)</code> 或 <code>new Vue(filters: &#123;&#125;)</code></li><li>使用过滤器：<code>&#123;&#123;xxx | 过滤器名&#125;&#125;</code> 或 <code>v-bind: 属性 = &quot;xxx | 过滤器名&quot;</code></li></ul></li><li>备注<ul><li>过滤器也可以接收额外的参数、多个过滤器也可以串联</li><li>并没有改变原来的数据，是产生新的对应的数据</li></ul></li></ul><h2 id="已学的-Vue-指令"><a href="#已学的-Vue-指令" class="headerlink" title="已学的 Vue 指令"></a>已学的 Vue 指令</h2><ul><li><code>v-bind</code> ：单向绑定解析表达式，可简写为 <code>:xxx</code></li><li><code>v-model</code>：双向数据绑定</li><li><code>v-for</code>：遍历数组、对象、字符串</li><li><code>v-on</code>：绑定事件监听，可简写为 <code>@xxx</code></li><li><code>v-if</code>：条件渲染 (动态控制节点是否存在)</li><li><code>v-else</code>：条件渲染 (动态控制节点是否存在)</li><li><code>v-show</code>：条件渲染  (动态控制节点是否展示)</li></ul><h2 id="v-html-指令"><a href="#v-html-指令" class="headerlink" title="v-html  指令"></a>v-html  指令</h2><ul><li>作用：向指定节点中渲染包含 html 结构的内容</li><li>与插值语法的区别<ul><li><code>v-html</code> 会替换掉节点中所有的内容，<code>&#123;&#123;xx&#125;&#125;</code> 则不会</li><li><code>v-html</code> 可以识别 html 结构</li></ul></li><li>严重注意，<code>v-html</code> 有安全性问题<ul><li>在网站上动态渲染任意 html 是非常危险的，容易导致 XSS 攻击</li><li>一定要在可信的内容上使用 v-html，永不要用在用户提交的内容上</li></ul></li></ul><h2 id="v-cloak-指令"><a href="#v-cloak-指令" class="headerlink" title="v-cloak 指令"></a>v-cloak 指令</h2><ul><li>本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 <code>v-cloak</code> 属性</li><li>使用 css 配合 <code>v-cloak</code> 可以解决网速慢时页面展示出 <code>&#123;&#123;xxx&#125;&#125;</code> 的问题</li></ul><h2 id="v-once-指令"><a href="#v-once-指令" class="headerlink" title="v-once 指令"></a>v-once 指令</h2><ul><li><code>v-once</code> 所在节点在初次动态渲染后，就视为静态内容了</li><li>以后数据的改变不会引起 <code>v-once</code> 所在结构的更新，可以用于优化性能</li></ul><h2 id="v-pre-指令"><a href="#v-pre-指令" class="headerlink" title="v-pre 指令"></a>v-pre 指令</h2><ul><li>跳过其所在节点的编译过程</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译</li></ul><h2 id="Vue-模板语法"><a href="#Vue-模板语法" class="headerlink" title="Vue 模板语法"></a>Vue 模板语法</h2><ul><li>插值语法<ul><li>功能：用于解析标签体内容</li><li>写法：<code>&#123;&#123;xxx&#125;&#125;</code> 其中 <code>xxx</code> 是 JS 表达式，且可以直接读取到 data 中的所有属性</li></ul></li><li>指令语法<ul><li>功能：用于解析标签 (包括：标签属性、标签体内容、绑定事件)</li><li>举例：<code>v-bind:href=&quot;xxx&quot;</code> 或简写为 <code>:href=&quot;xxx&quot;</code>，<code>xxx</code> 同样要写 JS 表达式，且可以直接读取到 data 中的所有属性</li><li>备注：Vue 中有很多指令，且形式都是 <code>v-??????</code>，此处我们只是拿  <code>v-bind</code> 举个例子</li></ul></li></ul><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><ul><li><p>定义语法</p><ul><li><p>局部指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">指令名: 配置对象</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="function"><span class="title">directives</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>全局指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(指令名, 配置对象) 或者 Vue.directive(指令名, 回调函数)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置对象中常用的 3 个回调</p><ul><li><code>.bind</code>：指令和元素成功绑定时调用</li><li><code>.inserted</code>：指令所在元素被插入页面时调用</li><li><code>.update</code>：指令所在模板结构被重新解析时调用</li></ul></li><li><p>备注</p><ul><li>指令定义时不加 <code>v-</code>，但使用时要加 <code>v-</code></li><li>指令名如果是多个单词，要是用 <code>kekab-case</code> 命名方式，不要使用 <code>camelCase</code> 方式命名</li><li>配置对象中的常用 3 个回调函数中的 <code>this</code> 指向都是指向 <code>window</code></li></ul></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>生命周期又名生命周期回调函数、生命周期函数、生命周期钩子</li><li>Vue 在关键时刻帮我们调用的一些特殊名称的函数</li><li>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的</li><li>生命周期函数中的 this 指向是 vm 或 组件实例对象</li><li>Vue 的生命周期：<ul><li>将要创建 ==&gt; 调用 <code>beforeCreate</code> 函数</li><li>创建完毕 ==&gt; 调用 <code>created</code> 函数</li><li>将要挂载 ==&gt; 调用 <code>beforeMount</code></li><li><u><strong>(重要)</strong></u> 挂载完毕 ==&gt; 调用 <code>mounted</code> 函数 ==========&gt; 重要的钩子</li><li>将要更新 ==&gt; 调用 <code>beforeUpdate</code> 函数</li><li>更新完毕 ==&gt; 调用 <code>updated</code> 函数</li><li><strong><u>(重要)</u></strong> 将要销毁 ==&gt; 调用 <code>beforeDestroy</code> 函数 ==========&gt; 重要的钩子</li><li>销毁完毕 ==&gt; 调用 <code>destroyed</code> 函数</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="alt"></p><ul><li>常用的生命周期钩子<pre><code>- `mounted`：发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等 (初始化操作)- `beforeDestroy`：清除定时器、解绑自定义事件、取消订阅消息等 (收尾工作)</code></pre></li><li>关于销毁 Vue 实例<pre><code>- 销毁后借助 Vue 开发者工具看不到任何信息- 销毁后自定义事件会失效，但原生 DOM 事件依然有效- 一般不会在 `beforeDestroy` 操作数据，因为即便操作数据，也不会再触发更新流程了</code></pre></li></ul><h2 id="Vue-使用组件的三大步骤"><a href="#Vue-使用组件的三大步骤" class="headerlink" title="Vue 使用组件的三大步骤"></a>Vue 使用组件的三大步骤</h2><ul><li>定义组件<ul><li>使用 <code>Vue.extend(options)</code> 创建，其中 <code>options</code> 和 <code>new Vue(options)</code> 时传入的那个 <code>options</code> 几乎一样，但也有点区别，区别如下：<ul><li><code>el</code> 不要写 — 最终所有的组件都要经过一个 vm 的管理，由 vm 中的 <code>el</code> 决定服务哪个容器。</li><li><code>data</code> 必须写成函数  — 避免组件复用时，数据存在引用关系</li></ul></li><li>备注：使用 <code>template</code> 可以配置组件结构</li></ul></li><li>如何注册组件<ul><li>局部注册：靠 <code>new Vue</code> 的时候传入 <code>component</code> 选项</li><li>全局注册：靠 <code>Vue.component(&#39;组件名&#39;, 组件)</code></li></ul></li><li>编写组件标签<ul><li><code>&lt;school&gt;&lt;/school&gt;</code></li></ul></li></ul><h2 id="Vue-组件注意的点"><a href="#Vue-组件注意的点" class="headerlink" title="Vue 组件注意的点"></a>Vue 组件注意的点</h2><ul><li>关于组件名<ul><li>一个单词<ul><li>第一种写法 (首字母小写)：school</li><li>第二种写法 (首字母大写)：School</li></ul></li><li>多个单词<ul><li>第一种写法 (kekab-case)：my-school</li><li>第二种写法 (CamelCase)：MySchool (需要 Vue 脚手架支持)</li></ul></li><li>备注<ul><li>组件名尽可能回避 HTML 中已有的元素名称，例如：h2 和 H2 都不行</li><li>可以使用 name 配置项指定组件在开发者工具中呈现的名字</li></ul></li></ul></li><li>关于组件标签<ul><li>第一种写法：<code>&lt;school&gt;&lt;/school&gt;</code></li><li>第二种写法：<code>&lt;/school&gt;</code></li><li>备注：不使用脚手架时，<code>&lt;/school&gt;</code> 会导致后续组件不能渲染</li></ul></li><li>一个简写方式<ul><li><code>const school = Vue.extend(options)</code> 可简写为：<code>const school  = options</code></li></ul></li></ul><h2 id="关于-VueComponent"><a href="#关于-VueComponent" class="headerlink" title="关于 VueComponent"></a>关于 VueComponent</h2><ul><li>school  组件的本质是一个名为 <code>VueComponent</code>  的构造函数，且不是程序员定义的，是 <code>Vue.extend</code> 生成的</li><li>我们只需要写 <code>&lt;school&gt;&lt;/school&gt;</code> 或 <code>&lt;/school&gt;</code>，Vue 解析时会为我们创建 school 组件的实例对象，即 Vue 帮我们执行 <code>new VueComponent(options)</code></li><li>特别注意：每次调用 <code>Vue.extend</code> ，返回的都是一个全新的 <code>VueComponent</code>！！！！！！！！！！</li><li>关于 <code>this</code> 指向：<ul><li>组件配置中：<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等函数他们的 <code>this</code> 指向都是 <code>VueComponent</code> 实例对象</li><li><code>new Vue()</code> 配置中：<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等函数他们的 <code>this</code> 指向都是 <code>Vue</code> 实例对象</li></ul></li><li><code>VueComponent</code> 的实例对象，以后简称 <code>vc</code> 。<code>Vue</code> 的实例对象，以后简称 <code>vm</code> 。</li></ul><h2 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h2><ul><li><code>VueComponent.prototype.__proto__ === Vue.prototype</code></li><li>上述的关系是为了能够让组件实例 (vc) 可以访问到 Vue 原型上的属性和方法</li></ul><h2 id="关于不同版本的-Vue"><a href="#关于不同版本的-Vue" class="headerlink" title="关于不同版本的 Vue"></a>关于不同版本的 Vue</h2><ul><li><code>vue.js</code> 和 <code>vue.runtime.xxx.js</code> 的区别：<ul><li><code>vue.js</code> 是完整版的 Vue，包含：核心功能和模板解析器</li><li><code>vue.runtime.xxx.js</code> 是运行版的 Vue，只包含核心功能，没有模板解析器</li></ul></li><li>因为 <code>vue.runtime.xxx.js</code> 没有模板解析器，所以不能使用 <code>template</code> 配置项，需要使用 <code>render</code> 函数接收到的 <code>createElement</code> 函数去指定具体内容</li></ul><h2 id="ref-属性-相当于-Angular-中的-ViewChild"><a href="#ref-属性-相当于-Angular-中的-ViewChild" class="headerlink" title="ref 属性 (相当于 Angular 中的 @ViewChild)"></a>ref 属性 (相当于 Angular 中的 @ViewChild)</h2><ul><li>被用来给元素或子组件注册引用信息 (id 的替代者)</li><li>应用在 HTML 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象 (vc)</li><li>使用方式：<ul><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;......&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ul></li></ul><h2 id="props-配置项-相当于-Angular-中的-Input"><a href="#props-配置项-相当于-Angular-中的-Input" class="headerlink" title="props 配置项 (相当于 Angular 中的 @Input)"></a>props 配置项 (相当于 Angular 中的 @Input)</h2><ul><li><p>功能：让组件接收外部传过来的数据</p><ul><li><p>传递数据</p><ul><li><code>&lt;Demo name=&quot;xxx&quot;/&gt;</code> 或者 <code>&lt;Demo :name=&quot;xxx&quot;&gt;</code>。两者的区别在于：前者传入的是一个字符串，后者传入的是一个名为 xxx 的变量</li></ul></li><li><p>接收数据</p><ul><li><p>第一种方式 (只接收)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;name&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>第二种方式 (限制类型)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三种方式 (限制类型、限制必要性、指定默认值)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">String</span>, <span class="comment">//类型</span></span><br><span class="line">  <span class="attr">required</span>: <span class="literal">true</span>,<span class="comment">//必要性</span></span><br><span class="line">    <span class="attr">default</span>: <span class="string">&#x27;老王&#x27;</span><span class="comment">//默认值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>props</code> 是只读的，Vue 底层会检测你对 <code>props</code> 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 <code>props</code> 的内容到 <code>data</code> 中一份，然后去修改 <code>data</code> 中的数据。<code>VueComponent</code> 加载的过程中，是先加载 <code>props</code> 然后再加载 <code>data</code> 的，所以在初始化加载 <code>data</code> 的时候，已经能够获取对应 <code>props</code> 的值了。</p></li></ul><h2 id="mixin-混入-相当于-Angular-中子类继承父类"><a href="#mixin-混入-相当于-Angular-中子类继承父类" class="headerlink" title="mixin 混入 (相当于 Angular 中子类继承父类)"></a>mixin 混入 (相当于 Angular 中子类继承父类)</h2><ul><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><ul><li><p>第一步定义混合，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;...&#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;...&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二步使用混合，例如：</p><ul><li>全局混入：<code>Vue.mixin(xxx)</code></li><li>局部混入：<code>mixins: [&#39;xxx&#39;]</code></li></ul></li></ul></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><p>功能：用于增强 Vue</p></li><li><p>本质：包含 <code>intall</code> 方法的一个对象，<code>install</code> 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据</p></li><li><p>定义插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">对象.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//添加全局过滤器</span></span><br><span class="line">  Vue.filter(...)</span><br><span class="line">            </span><br><span class="line">  <span class="comment">//添加全局指令</span></span><br><span class="line">  Vue.directive(...)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//配置全局混入</span></span><br><span class="line">  Vue.mixin(...)</span><br><span class="line">            </span><br><span class="line">  <span class="comment">//添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line">  Vue.prototype.$myProperty = xxx</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用插件</span></span><br><span class="line">Vue.use(plugin);</span><br><span class="line"><span class="comment">// 此外，还可以在后边添加参数</span></span><br><span class="line">Vue.use(plugin, xxx, yyy)</span><br><span class="line"><span class="comment">// 多出来的参数可以在上方的 options 中获取</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h2><ul><li>作用：让样式在局部生效，防止冲突</li><li>写法：<code>&lt;style scoped&gt;&lt;/style&gt;</code></li><li>注意：一般情况下，<code>AppComponent</code> 中不是用局部样式，<code>AppComponent</code> 中一般使用的都是全局样式</li></ul><h2 id="总结-TodoList-案例"><a href="#总结-TodoList-案例" class="headerlink" title="总结 TodoList 案例"></a>总结 TodoList 案例</h2><ul><li>组件化编码流程<ul><li>拆分静态组件：组件要按照功能点进行拆分，命名不要和 <code>html</code> 元素冲突</li><li>实现动态组件：考虑好数据的存放位置，数据是一个组件在用还是一些组件在用：<ul><li>一个组件在用：放在组件自身即可</li><li>一些组件再用：放在他们共同的父组件上 (<em>状态提升</em>)</li></ul></li><li>实现交互：从绑定事件开始</li></ul></li><li><code>props</code> 使用于<ul><li>父组件 ==&gt; 子组件</li><li>子组件 ==&gt; 父组件 (要求：需要父组件先给子组件传一个函数，具体可以参考 ezlearn 项目中的 <code>crossGet</code>)</li></ul></li><li>使用 <code>v-model</code> 时需要切记：<code>v-model</code> 绑定的值不能是 <code>props</code> 传过来的值，因为 <code>props</code> 是不可以修改的！(其实这里 Vue 跟 Angular 是有点类似的，在 Angular 中如果存在 <code>@Input</code> 这种父传值给子的情况，一旦在子组件中改变对应 <code>@Input</code> 的值就很容易会导致 Angular 变更检测的时候无法检测到数据的变化，所以两个框架的道理都是相通的，如果存在父传子的数据绑定，一定需要在数据源的地方进行修改数据，不要直接在子组件对数据进行修改！！！！！！！！这个是代码规范的问题！！！！)</li><li><code>props</code> 传过来的若是类型的值，修改对象中的属性时，Vue 不会报错，但是不推荐这样做，因为这样违背了上一条中所说的规范，关于所有 父传子的绑定，都需要在数据源的地方进行修改，切勿随意在子组件对数据进行修改</li></ul><h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><ul><li>存储内容大小一般支持 5MB 左右 (不同浏览器可能还不一样)</li><li>浏览器通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制</li><li>相关 API<ul><li><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;)</code> ：该方法接收一个键和值作为参数，会把键和值添加到存储中，如果键名存在，则更新其对应的值</li><li><code>xxxxxStorage.getItem(&#39;person&#39;)</code> ：该方法接收一个键名作为参数，返回键名对应的值</li><li><code>xxxxxStorage.removeItem(&#39;key&#39;)</code> ：该方法接收一个键名作为参数，并把键名从存储中删除</li><li><code>xxxxxStorage.clear()</code> ： 该方法会清空存储中的所有数据</li></ul></li><li>备注：<ul><li>SessionStorage 中存储的内容会随着浏览器窗口关闭而消失</li><li>LocalStorage 中存储的内容，需要手动清除才会消失</li><li><code>xxxxxStorage.getItem(xxx)</code> 如果对应 xxx 的 value 获取不到，那么 <code>getItem</code> 的返回值是 null</li><li><code>JSON.parse(null)</code> 的结果依然是 null</li></ul></li></ul><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ul><li><p>一种组件间的通信方式，适用于：子组件 ===&gt; 父组件</p></li><li><p>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件 (事件回调在 A 中)</p></li><li><p>绑定自定义事件：</p><ul><li><p>第一种方式：在父组件中 <code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code> 或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式：在父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo ref=&quot;demo&quot;/&gt;</span><br><span class="line">.............</span><br><span class="line">mounted() &#123;</span><br><span class="line">this.$ref.xxx.$on(&#x27;atguigu&#x27;, this.test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>  -  若想自定义事件只触发一次，可以使用 `once` 修饰符，或 `$once` 方法</code></pre></li></ul></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;, data)</code></p></li><li><p>解绑自定义事件：<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生 DOM 事件，需要使用 <code>native</code> 修饰符</p></li><li><p>注意：通过 <code>this.$ref.xxx.$on(&#39;atguigu&#39;, callback)</code> 绑定自定义事件时，回调如果要使用 <code>function()&#123;...&#125;</code> 这种方式定义的话，就需要定义在 <code>methods</code> 属性当中，才能确保 <code>this</code> 指针正常，又或者可以直接使用箭头函数</p></li></ul><h2 id="全局事件总线-GlobalEventBus"><a href="#全局事件总线-GlobalEventBus" class="headerlink" title="全局事件总线 (GlobalEventBus)"></a>全局事件总线 (GlobalEventBus)</h2><ul><li><p>一种组件间通信的方式，适用于任意组件间通信</p></li><li><p>安装全局事件总线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  Vue.prototype.$bus = <span class="built_in">this</span> <span class="comment">// 安装全局事件总线，$bus 就是当前应用的 vm</span></span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用事件总线</p><ul><li><p>接收数据：A 组件想接收数据，则在 A 组件中给 <code>$bus</code> 绑定自定义事件，事件的回调留在 A 组件自身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods() &#123;</span><br><span class="line">  demo(data) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">mounted() &#123;</span><br><span class="line">this.$bus.$on(&#x27;xxx&#x27;, this.demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxx&#39;, data)</code></p></li></ul></li><li><p>最好再 <code>beforeDestroy</code> 钩子中，用 <code>$off</code> 去解绑当前组件所用到的事件</p></li></ul><h2 id="消息订阅与发布-pubsub"><a href="#消息订阅与发布-pubsub" class="headerlink" title="消息订阅与发布 (pubsub)"></a>消息订阅与发布 (pubsub)</h2><ul><li><p>一种组件间通信的方式，适用于任意组件间的通信</p></li><li><p>使用步骤</p><ul><li><p>安装 pubsub：<code>yarn add pubsub-js</code></p></li><li><p>引入：<code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的回调留在 A 组件自身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">demo(data) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">mounted() &#123;</span><br><span class="line">this.pid = pubsub.subscribe(&#x27;xxx&#x27;, this.demo) // 订阅消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;, data)</code></p></li><li><p>最好再 <code>beforeDestroy</code> 钩子中，用 <code>Pubsub.unsubscribe(pid)</code> 去取消订阅</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS：垂直居中引发的思考</title>
      <link href="/2021/11/22/CSS%EF%BC%9A%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2021/11/22/CSS%EF%BC%9A%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS：垂直居中引发的思考"><a href="#CSS：垂直居中引发的思考" class="headerlink" title="CSS：垂直居中引发的思考"></a>CSS：垂直居中引发的思考</h1><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul><li><p>横向格式化属性：他包含七个属性：margin-left、border-left-width、padding-left、width、padding-left、border-right-width、margin-right，这七个属性影响着块级框的横向布局。他们七个的值加起来要等于元素容纳块的宽度，而这个宽度通常就是块级父元素的 width 值。用公式来表示就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right = father-width</span><br></pre></td></tr></table></figure><p>这七个值中可以设置为 auto 的值只有三个，margin-left、margin-right、width，如果把其中一个值设置为 auto，其他两个值设置为具体值，那么设置为 auto 的那个属性具体长度要能满足元素框的宽度等于父元素的宽度，即满足那个等式，那么如果把其中的两个设置为 auto，下面我们就来讨论这个情况：</p><ul><li><p>把 margin-left 和 margin-right 全部设置为 auto，width 设置为具体值，这个时候两个外边距的长度相等，具体表现就是元素在父元素中居中显示，也就是我们想要的水平居中效果</p></li><li><p>把某一边的外边距和 width 设置为 auto，此时设置为 auto 的外边距等于 0，宽度根据等式计算，举个简单的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们将 margin-right 设置为了 auto，那它就会变成 0，由于没有设置 border 和 padding，那么他们默认为 0，所以 <code>width + margin-left</code> 应该等于父元素的宽度，这里我的父元素就是 body，所以表现出来应该就是 <code>margin-left</code> 等于  <code>100px</code> 然后 <code>div</code> 占满了剩下的空间，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/TIua17.jpg" alt="alt"></p></li><li><p>还有一种情况，我们把三个值全部都设置为 auto，这时候会把左右边距全部设置为 0，width 则是要多宽就有多宽。显示的效果如下图。因为去掉宽度后宽度的默认值为 auto，你又把左右边距设置成了 auto，那么左右边距自然变成 0 了，这也是为什么居中失效的原因。接下来你可能会想，如果我一个 auto 都不设置，全部设置成具体值，那上面的那个等式不就不成立了吗？这种情况在 css 中被称为过约束，在这种情况下 margin-right 会被强制设置为 auto</p></li></ul></li></ul><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>了解完水平居中，我们探讨一下垂直居中，有了上面的结论，很容易会想到，垂直居中不就设置为 <code>margin: auto 0</code> 不就行了吗</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: auto <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        hello world</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码产生的效果是下面这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/ba9Gbz.jpg" alt="alt"></p><p>这里为什么不会自动设置上边距和下边距？这里是跟 auto 的默认行为有关，上下外边距如果都被设置为 auto，最终会变成 0，就像跟没有外边距是一样的效果。这很容易想明白，父元素的高度都是不确定的，如何去自动居中？所以不可能像横向 margin 那样计算，这也就解释了为什么我们不能使用 auto 来垂直居中元素。那么我们如何实现垂直居中？通常我们的代码是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们为 center 元素加上绝对定位，并且把他的各个值全部都设置为 0，这个时候神奇的事情发生了，我们成功居中了子元素了，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/GNavip.jpg" alt="alt"></p><ul><li>纵向格式化属性<ul><li>在纵向同样也是存在一个式子：<code>top + margin-top + border-top-width + padding-top + height + padding-bottom + border-bottom-width + margin-bottom + bottom = father-height </code> 在前方的式子中，top 和 bottom 都被设置为了 0，margin 等于 auto，这时候浏览器为了满足这个等式会把上下的距离均匀分给 margin，即达到我们想要的居中效果。同时横向也是一样的道理，所以我们可以看到其实这个元素时水平垂直居中的，如果此时存在过约束，一般会忽略 right 属性。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3.js：绘制树图</title>
      <link href="/2021/11/22/D3.js%EF%BC%9A%E7%BB%98%E5%88%B6%E6%A0%91%E5%9B%BE/"/>
      <url>/2021/11/22/D3.js%EF%BC%9A%E7%BB%98%E5%88%B6%E6%A0%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="D3-js：绘制树图"><a href="#D3-js：绘制树图" class="headerlink" title="D3.js：绘制树图"></a>D3.js：绘制树图</h1><h2 id="原理阐述"><a href="#原理阐述" class="headerlink" title="原理阐述"></a>原理阐述</h2><p>使用 <code>d3.js</code> 构建树图主要是用到的是如下几个 <code>API</code></p><ul><li><code>const hierarchyData = d3.hierarchy(data)</code> ：将层级数据进一步精细化</li><li><code>const treeLayout = d3.tree()</code> ：获取 Layout</li><li><code>const nodesData = treeLayout(hierarchyData)</code> ：通过 Layout 获得易于 d3 方便绘图的数据</li></ul><p>以上的 <code>API</code> 会在后文进行解释</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/cXECSc.jpg" alt="alt"></p><p>以上流程图是对整个逻辑的简单展示</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="初始标签及数据"><a href="#初始标签及数据" class="headerlink" title="初始标签及数据"></a>初始标签及数据</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">&quot;chart&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;二级节点1&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&quot;叶子节点&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&quot;叶子节点&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;二级节点2&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;C&quot;</span>,</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&quot;叶子节点&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;D&quot;</span>,</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&quot;叶子节点&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是本次实验的初始数据，以 <code>root</code> 为根节点，<code>children</code> 中放置子节点，子节点也有其后裔节点。此例中以三层为例。后文中，<code>d3.hierarchy</code> 函数默认处理数据中节点属性名为 <code>children</code>，此处我们直接将子节点数组属性设置为 <code>children</code>。</p><p>接下来就是设置宽度、高度、及 <code>g</code> 容器。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = <span class="number">1366</span>;</span><br><span class="line"><span class="keyword">const</span> height = <span class="number">580</span>;</span><br><span class="line"><span class="keyword">const</span> svg = d3.select(<span class="string">&#x27;.chart&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;width&#x27;</span>, width)</span><br><span class="line">    .attr(<span class="string">&#x27;height&#x27;</span>, height);</span><br><span class="line"><span class="keyword">const</span> g = svg.append(<span class="string">&#x27;g&#x27;</span>).attr(<span class="string">&#x27;transform&#x27;</span>, <span class="string">&#x27;translate(0, 20)&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="获得进一步层级化的数据"><a href="#获得进一步层级化的数据" class="headerlink" title="获得进一步层级化的数据"></a>获得进一步层级化的数据</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hierarchyData = d3.hierarchy(data);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;——————d3.hierarchy(data)——————&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hierarchyData);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/jN76w0.jpg" alt="alt"></p><p>我们可以看到，相对初始数据，经过 <code>d3.hierarchy</code> 处理后，节点的数据类型变为了 <code>Node(Object)</code>  ，同时返回了相应的 <code>depth</code> 及 <code>height</code>。</p><p>接下来我们来获取 <code>layout</code></p><h3 id="获取-Layout"><a href="#获取-Layout" class="headerlink" title="获取 Layout"></a>获取 Layout</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeLayout = d3.tree()</span><br><span class="line">    .size([width, height - <span class="number">30</span>])  <span class="comment">//设置tree的大小</span></span><br><span class="line">    .separation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;      <span class="comment">// 根据是否为同一父节点设置节点距离比例</span></span><br><span class="line">        <span class="keyword">return</span> a.parent === b.parent ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;——————treeLayout——————&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(treeLayout);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/WUjdXO.jpg" alt="alt"></p><p>我们可以看到 <code>d3.tree()</code> 返回的就是一个函数</p><p>接下来就是把 <code>hierarchyData</code> 交给 <code>treeLayout</code> 处理获得便于绘图的数据</p><h3 id="使用-treeLayout-获取易于绘图的数据"><a href="#使用-treeLayout-获取易于绘图的数据" class="headerlink" title="使用 treeLayout 获取易于绘图的数据"></a>使用 treeLayout 获取易于绘图的数据</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodesData = treeLayout(hierarchyData);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;——————nodesData——————&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(nodesData);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/EncDFg.jpg" alt="alt"></p><p>我们可以看到经过 treeLayout 处理返回的数据多了 x、y 属性，它们定位了在图中的位置，绘图时我们会用到它们。</p><p>同时也注意 Layout 函数并不是纯函数，由于是引用，原先的 <code>hierarchyData</code> 数据也会变得如上图所示，大家可以在控制台中自行查看。</p><h3 id="开始绘图"><a href="#开始绘图" class="headerlink" title="开始绘图"></a>开始绘图</h3><p>现在我们已经有定位了位置的数据了，接下来要做的非常简单，就是根据这些 x、y 来画线，画节点</p><p>先画线</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> links = g.selectAll(<span class="string">&#x27;.links&#x27;</span>)</span><br><span class="line">    .data(nodesData.descendants().slice(<span class="number">1</span>)) <span class="comment">//nodesData.descendants()返回所有节点的数据，利于我们绑定数据，slcie(1)截取root后的全部节点，防止重绘</span></span><br><span class="line">    .enter().append(<span class="string">&#x27;path&#x27;</span>) <span class="comment">//用path画线</span></span><br><span class="line">    .attr(<span class="string">&#x27;fill&#x27;</span>, <span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;stroke&#x27;</span>, <span class="string">&#x27;#313131&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;stroke-width&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;d&#x27;</span>, <span class="function">(<span class="params">d</span>) =&gt;</span> &#123;<span class="comment">//通过三次贝塞尔曲线设置连线的弯曲程度。M：move to，即到控制点 C后设置两个控制点及终点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        M<span class="subst">$&#123;d.x&#125;</span>,<span class="subst">$&#123;d.y&#125;</span></span></span><br><span class="line"><span class="string">        C<span class="subst">$&#123;d.x&#125;</span>,<span class="subst">$&#123;(d.y + d.parent.y) / <span class="number">2</span>&#125;</span></span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;d.parent.x&#125;</span>,<span class="subst">$&#123;(d.y + d.parent.y) / <span class="number">2.5</span>&#125;</span></span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;d.parent.x&#125;</span>,<span class="subst">$&#123;d.parent.y&#125;</span>`</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>最后结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/ahbVlN.jpg" alt="alt"></p><p>接下来是画图</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个节点中有多个子元素时(比如本例中有text和circle)，我个人喜欢用g作为容器</span></span><br><span class="line"><span class="keyword">const</span> nodes = g.selectAll(<span class="string">&#x27;.node&#x27;</span>)</span><br><span class="line">    .data(nodesData.descendants()) <span class="comment">//同样是获得所有节点，便于数据绑定</span></span><br><span class="line">    .enter().append(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;transform&#x27;</span>, <span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`translate(<span class="subst">$&#123;d.x&#125;</span>, <span class="subst">$&#123;d.y&#125;</span>)`</span>;<span class="comment">//位移</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//画圆 </span></span><br><span class="line">nodes.append(<span class="string">&#x27;circle&#x27;</span>)</span><br><span class="line">    .style(<span class="string">&#x27;fill&#x27;</span>, <span class="string">&#x27;#c03027&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;r&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//插入文字</span></span><br><span class="line">nodes.append(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;dx&#x27;</span>, <span class="string">&#x27;.9em&#x27;</span>)</span><br><span class="line">    .text(<span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.data.name;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/peXPPw.jpg" alt="alt"></p><p>至此，已经完成一个基本的树图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> D3.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular：@Host 装饰器和元素注入器</title>
      <link href="/2021/11/22/Angular%EF%BC%9A@Host%20%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E5%85%83%E7%B4%A0%E6%B3%A8%E5%85%A5%E5%99%A8/"/>
      <url>/2021/11/22/Angular%EF%BC%9A@Host%20%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E5%85%83%E7%B4%A0%E6%B3%A8%E5%85%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：-Host-装饰器和元素注入器"><a href="#Angular：-Host-装饰器和元素注入器" class="headerlink" title="Angular：@Host 装饰器和元素注入器"></a>Angular：@Host 装饰器和元素注入器</h1><p>Angular 依赖注入机制包含 <code>@Optional</code> 和 <code>@Self</code> 等影响依赖解析过程的装饰器，尽管它们字面意思就直接解释了作用，但是 <code>@Host</code> 却困扰了我好久，其源码对于该装饰器的描述</p><blockquote><p>Specifies that an injector should retrieve a dependency from any injector until reaching the host element of the current component.</p></blockquote><p>由于网上大多教程都提到 Angular 的模块注入器和组件注入器，所以我认为 <code>@Host</code> 应该和多级注入器有关。<code>@Host</code> 可以用在子组件内，来限制只能在它自身和其父组件注入器解析依赖，所以我做了一个小示例来验证这个假设</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;a-comp&gt;&lt;/a-comp&gt;`</span>,</span><br><span class="line">    <span class="attr">providers</span>: [MyAppService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;<span class="attr">selector</span>: <span class="string">&#x27;a-comp&#x27;</span>, ...&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="meta">@Host</span>() s: MyAppService</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里报错 No provider for MyAppService，有意思的是，如果我移除了 <code>@Host</code> 装饰器，<code>MyAppService</code> 就可以顺利从父组件注入器内解析出来，下面一探究竟。</p><p>关键就在于上文 <code>@Host</code> 装饰器描述的 ‘until’ 一词上：</p><blockquote><p>…retrieve a dependency from any injector <strong>until</strong> reaching the host element</p></blockquote><p>它意思是 <code>@Host</code> 装饰器会让依赖解析过程限制在当前组件模板，甚至都不包括其宿主元素 (注：在宿主元素 <code>a-comp</code> 上绑定含有 <code>MyService</code> 服务的指令 <code>ADirective</code>，是可以在 <code>AComponent</code> 的构造函数中解析出被 <code>@Host</code> 装饰的 <code>MyAppService</code> 服务)。这就是上面示例报错的原因 — Angular 不会从其宿主父组件注入器中解析依赖。</p><p>所以现在我们知道 <code>@Host</code> 装饰器不可以用来在子组件中解析来自父组件的依赖提供者，意味着该装饰器的依赖解析机制不可以用于多级组件注入器</p><blockquote><p>所以应该使用什么样的多级注入器</p></blockquote><p>实际上，除了模块注入器和组件注入器，Angular 还提供了第三种注入器，即多级元素注入器，它是由 HTML 元素和指令共同创建的。</p><h2 id="元素注入器"><a href="#元素注入器" class="headerlink" title="元素注入器"></a>元素注入器</h2><p>Angular 会按照三个阶段来解析依赖，起始阶段就是使用多级元素注入器，然后当时多级组件注入器，最后是多级模块注入器。</p><p>对组件和模块注入器解析依赖的后两个阶段，应该很熟悉了，当延迟加载模块的时候，Angular 会创建多级模块注入器，多级组件注入器是模板中嵌套组件创建的，就内部实现而言，组件注入器也可以称为视图注入器，稍后会解释原因。</p><p>另外，多级元素注入器是 Angular 依赖注入系统中很少知道的功能，因为文档中没有写，但是这种注入器在依赖注入的起始阶段就使用了，这些多级元素注入器被用来解析由 <code>@Host</code> 装饰的依赖，所以让我们仔细研究一下这种注入器。</p><h3 id="一个元素注入器"><a href="#一个元素注入器" class="headerlink" title="一个元素注入器"></a>一个元素注入器</h3><p>Angular 内部使用一种叫视图或组件视图的数据结构来表示组件 (注：可查看源码中 <code>ViewDefinition</code> 接口)。实际上，这就是把组件注入器称为视图注入器的由来，视图对象主要用来表示模板中有 HTML 元素创建的 DOM 节点的集合 (注：<code>@angular/compiler</code> 会编译你写的组件，生成结果由 <code>ViewDefinition</code> 接口来表示，不需要知道编译过程，只需要知道你写的带有 <code>@Component</code> 装饰的类不编译为新的类是无法直接运行的，且 HTML 模板就存在于薪类的属性中，即 Compiler HTML + Class into New Class，正因为 <code>@angular/compiler</code> 编译功能强大，所以可以在 HTML 模板里写很多不符合 HTML 语法的 HTML 代码，比如绑定指令等等)。所以每一个视图对象内部是有不同种类的视图节点组成的 (注：<code>ViewDefinition</code> 表示编译后的视图对象，视图又是由节点组成的，<code>@angular/core</code> 使用 <code>NodeDef</code> 接口表示所有节点，而节点又分很多种，使用 <code>NodeFlags</code> 来表示，其中最常见的 <code>TypeElement</code> 类型就是来标识 HTML 元素，使用 <code>ElementDef</code> 接口来表示)，最常见的视图节点类型是元素节点，用来表示对应的 <code>DOM</code> 元素，下图表示视图和 <code>DOM</code> 两者之间的关系</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/68WH7Y.jpg" alt="alt"></p><p>每个视图节点都是由节点定义对象实例化后创建的，节点定义对象包含描述节点的元数据，比如，像 <code>element</code> 类型的节点通常用来表示 DOM 元素，而这些元数据是有 <code>@angular/compiler</code> 的编译器编译组件模板和附着在模板上的指令生成的，下图表示视图节点定义与其对象的之间的关系</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/QprKnL.jpg" alt="alt"></p><p>元素节点定义描述了一个有趣的功能</p><blockquote><p>In Angular, a node definition that describes an HTML element defines its own injector. In other words, an HTML element in a component’s template defines its own element injector. And this injector can populated with providers by applying one or more directives on the corresponding HTML element.</p></blockquote><p>直接看示例</p><p>假设组件模板中有个 <code>div</code> 元素，并且有两个指令挂载到上面</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div a b&gt;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123; <span class="attr">selector</span>: <span class="string">&#x27;[a]&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ADirective</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123; <span class="attr">selector</span>: <span class="string">&#x27;[b]&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BDirective</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>@angular/compiler</code> 的编译器会编译模板生成视图，该视图中 DOM 元素 <code>div</code> 对应的元素节点定义对象包含如下元数据 (注：可查看 <code>ElementDef</code> 接口中的 <code>name</code> 和 <code>publicProvider</code> 属性)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DivElementNodeDefinition = &#123;</span><br><span class="line">    <span class="attr">element</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">        <span class="attr">publicProviders</span>: &#123;</span><br><span class="line">            <span class="attr">ADirective</span>: referenceToADirectiveProviderDefinition,</span><br><span class="line">            <span class="attr">BDirective</span>: referenceToBDirectiveProviderDefinition</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所见，节点对象定义了 <code>element.publicProviders</code> 属性，包含两个服务提供者 <code>ADirective</code> 和 <code>BDirective</code>，该属性作用类似于一个注入器，而 <code>referenceToADirectiveProviderDefinition</code> 和 <code>referenceToBDirectiveProviderDefinition</code> 就是附着在 <code>div</code> 元素上两个指令的实例。由于它们是由同一个元素注入器解析，所以你可以把其中一个指令注入到另外一个指令当中。当然，你不能在两个指令中相互注入依赖，因为这会导致依赖死锁。</p><p>所以下图说明了我们现在拥有的东西</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/dMcyU9.jpg" alt="alt"></p><p>注意宿主元素 <code>my-app</code> 存在于 <code>AppComponentView</code> 之外，因为它是属于父组件视图内的。</p><p>现在如果 <code>ADirective</code> 也包含服务提供者会发生什么？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;[a]&#x27;</span>,</span><br><span class="line">    <span class="attr">providers</span>: [ADirService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ADirective</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>正如你所料，这个服务会被包含进由 <code>div</code> 创建的元素注入器中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divElementNodeDefinition = &#123;</span><br><span class="line">    <span class="attr">element</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">        <span class="attr">publicProviders</span>: &#123;</span><br><span class="line">            <span class="attr">ADirService</span>: referenceToADirServiceProviderDefinition</span><br><span class="line">            <span class="attr">ADirective</span>: referenceToADirectiveProviderDefinition,</span><br><span class="line">            <span class="attr">ADirective</span>: referenceToADirectiveProviderDefinition</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再放一次图，下图是现在的结果</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/MCJ7Kz.jpg" alt="alt"></p><h3 id="多级元素注入器"><a href="#多级元素注入器" class="headerlink" title="多级元素注入器"></a>多级元素注入器</h3><p>上文我们只有一个 HTML 元素，嵌套 HTML 元素组成了 DOM 元素层级，组件视图内这些 DOM 元素组成了 Angular 依赖注入系统内多级元素注入器。</p><p>直接看示例</p><p>假设组件模板中有父子元素 <code>div</code>，同时还有两个指令 <code>A</code> 和 <code>B</code>。<code>A</code> 指令附着在父元素 <code>div</code> 上并提供 <code>ADirService</code> 服务，<code>B</code> 指令附着在子元素 <code>div</code> 上，但不提供任何服务。</p><p>代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div a&gt;</span></span><br><span class="line"><span class="string">            &lt;div b&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;[a]&#x27;</span>,</span><br><span class="line">    <span class="attr">providers</span>: [ADirService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ADirective</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Directive</span>(&#123; <span class="attr">selector</span>: <span class="string">&#x27;[b]&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BDirective</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果我们去探究 <code>@angular/compiler</code> 编译模板创建的元素节点定义对象，会发现存在两个 <code>element</code> 类型节点来描述 <code>div</code> 元素</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> viewDefinitionNodes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// element definition for the parent div</span></span><br><span class="line">        <span class="attr">element</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">`div`</span>,</span><br><span class="line">            <span class="attr">publicProviders</span>: &#123;</span><br><span class="line">                <span class="attr">ADirective</span>: referenceToADirectiveProviderDefinition,</span><br><span class="line">                <span class="attr">ADirService</span>: referenceToADirServiceProviderDefinition,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// element definition for the child div</span></span><br><span class="line">        <span class="attr">element</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">`div`</span>,</span><br><span class="line">            <span class="attr">publicProviders</span>: &#123;</span><br><span class="line">                <span class="attr">BDirective</span>: referenceToBDirectiveProviderDefinition</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>正如上文发现的，每一个 <code>div</code> 元素定义都有一个 <code>publicProviders</code> 作为依赖注入容器。由于附着在父 <code>div</code> 元素还提供了 <code>ADirService</code> 服务，所以该服务也被加到父元素 <code>div</code> 的元素注入器内。</p><blockquote><p>嵌套 HTML 结构创建了多级元素注入器</p></blockquote><p><code>ADirective</code> 指令提供一个服务，创建了两个层级元素注入器 — 上层级父注入器创建在 <code>div</code> 元素上，下层级子注入器创建在 <code>AppComponent</code> 上，这并不奇怪，因为组件也仅仅是带有指令的 HTML 元素。</p><h3 id="创建元素注入器"><a href="#创建元素注入器" class="headerlink" title="创建元素注入器"></a>创建元素注入器</h3><p>当 Angular 为嵌套 HTML 元素创建注入器时，该注入器要么会继承父注入器，要么直接把父注入器复制给子注入器。如果子元素上挂载指令且该指令提供依赖服务，则子注入器会继承父注入器，也就是说，有挂载指令并提供服务的子元素创建的元素注入器，是会继承父注入器。另外，没有必要为子组件单独创建一个注入器，如有必要，可以直接使用父注入器来解析依赖。</p><p>下图说明了这个过程</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/Sizo1r.jpg" alt="alt"></p><h4 id="依赖解析过程"><a href="#依赖解析过程" class="headerlink" title="依赖解析过程"></a>依赖解析过程</h4><p>安装组件视图内的多级元素注入器，会大大简化依赖解析过程。Angular 使用 JavaScript 的原型链的属性查询机制来解析依赖，而不是一层层去查找父注入器去解析依赖</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elDef.element.publicProviders[tokenKey]</span><br></pre></td></tr></table></figure><p>由于 JavaScript 的工作方式，访问 <code>publicProviders</code> 对象 <code>key</code> 对应的值，会直接从父元素注入器或原型链中解析出来。</p><h2 id="Host-装饰器"><a href="#Host-装饰器" class="headerlink" title="@Host 装饰器"></a>@Host 装饰器</h2><p>我们之所以讨论元素注入器而不是 <code>@Host</code> 装饰器，是因为 <code>@Host</code> 会把元素注入器依赖解析过程限制在当前组件视图中。在一般依赖解析过程中，如果组件视图内的元素注入器不能解析一个令牌，Angular 依赖解析系统会遍历父视图，去使用组件/视图注入器来解析令牌，如果还没找到依赖，则遍历模块注入器去查找依赖。但一旦使用了 <code>@Host</code> 装饰器，整个依赖解析过程就会在第一阶段完成后停止解析，也就是说，元素注入器只在组件视图内解析依赖，然后就停止解析工作。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><code>@Host</code> 在表单指令中大量使用，比如，往 ngModel 指令里注入一个表单容器，并把由该指令实例化的表单控件对象 (FormControl) 注入到表单对象内，典型的模板驱动表单代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">ngModel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上，NgForm 指令的选择器与 form DOM 元素匹配，该指令包含一个服务提供者，把自身注册为 ControlContainer 令牌指向的服务</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;form&#x27;</span>,</span><br><span class="line">    <span class="attr">providers</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">provide</span>: ControlContainer,</span><br><span class="line">            <span class="attr">useExisting</span>: NgForm</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NgForm</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular：Angular 路由器之懒加载、AOT、及预加载</title>
      <link href="/2021/11/22/Angular%EF%BC%9AAngular%20%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81AOT%E3%80%81%E5%8F%8A%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
      <url>/2021/11/22/Angular%EF%BC%9AAngular%20%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81AOT%E3%80%81%E5%8F%8A%E9%A2%84%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：Angular-路由器之懒加载、AOT、及预加载"><a href="#Angular：Angular-路由器之懒加载、AOT、及预加载" class="headerlink" title="Angular：Angular 路由器之懒加载、AOT、及预加载"></a>Angular：Angular 路由器之懒加载、AOT、及预加载</h1><p>对于更快的首页加载来说，懒加载是一种有用的技术。通过懒加载，你的应用只需要将必要的启动代码发送到浏览器，就可以更快地加载。其他代码放在功能模块中，这些功能按需加载。</p><p>本文将深入了解路由器是如何实现懒加载的。</p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><ul><li>懒路由配置是如何合并到根配置中的</li><li>懒加载如何与 AOT 与 JIT 编译一起工作的</li><li>路由器中的预加载是如何运作的</li></ul><h2 id="Webpack-SystemJS-等类"><a href="#Webpack-SystemJS-等类" class="headerlink" title="Webpack, SystemJS 等类"></a>Webpack, SystemJS 等类</h2><p>当你使用像 Angular 这样的大型框架时，很容易忽略动态加载模块的真正含义。我们真正要做的是使用 Webpack 这样的工具将应用分割成不同的包 (Angular CLI 为我们处理这些包)，然后将这些包 pull 到我们应用中。</p><p>在本文中，我们不会重点讨论代码切割技术和模块加载器。</p><h2 id="懒加载和路由器配置"><a href="#懒加载和路由器配置" class="headerlink" title="懒加载和路由器配置"></a>懒加载和路由器配置</h2><p>要使用延迟加载，必须将应用分解为独立的 <code>NgModule</code> ，通常称为功能模块。</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/TvGoRH.jpg" alt="alt"></p><p>假设你已经将应用拆成功能模块，那么设置懒加载非常简单。<code>loadChildren</code> 属性用于路由器配置内部，指示模块应该懒加载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ROUTES = [</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;lazy&#x27;</span>,</span><br><span class="line">   <span class="attr">loadChildren</span>: <span class="string">&#x27;./lazy-module/lazy.module#LazyModule&#x27;</span>,</span><br><span class="line"> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>传给 <code>loadChildren</code> 的值是字符串。在 <code>#</code> 左边的所有字符串都是懒加载加载模块的路径，在 <code>#</code> 右侧的是 <code>NgModule</code> 的名字。</p><p>当用户导航到此路由时 (例如：<code>localhost: 4200/lazy</code>)，路由器将看到 <code>loadChildren</code> 属性，并开始加载功能模块 (在本例中为 <code>LazyModule</code>)。</p><blockquote><p>必须小心避免在主包的任何位置添加任何类型的对功能模块的引用。否则，它将创建一个编译时依赖项，编译器将在主包中包含功能模块，而不是懒加载它。这就是为什么我们传递字符串作为 <code>loadChildren</code> 的值，而不是功能模块引用。</p></blockquote><p>一旦功能模块加载完毕，它的路由器配置必须与应用主路由器配置 (在 <code>RouterModule.forRoot()</code> 中定义，通常位于 <code>app.module</code> 或者专用的 <code>app-routing.module</code> 中) 合并。</p><p>作为参考，我们 <code>LazyModule</code> 在路由中只有一条路由：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lazy.module.ts</span></span><br><span class="line"><span class="keyword">const</span> ROUTES = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: LazyComponent &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    LazyComponent</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    RouterModule.forChild(ROUTES)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在导航的应用重定向阶段 (除非预加载，稍后会详细介绍)，使用 <code>forChild</code> 的功能模块中指定的配置被合并到 <code>_loadedConfig</code> 属性下的路由配置中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply_redirect.ts</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.configLoader.load(ngModule.injector, route)</span><br><span class="line">                  .pipe(map(<span class="function">(<span class="params">cfg: LoadedRouterConfig</span>) =&gt;</span> &#123;</span><br><span class="line">                    route._loadedConfig = cfg;</span><br><span class="line">                    <span class="keyword">return</span> cfg;</span><br><span class="line">                  &#125;));</span><br></pre></td></tr></table></figure><p>这可以通过检查路由器服务的 <code>config</code> 属性来验证</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/VfH8Nr.jpg" alt="alt"></p><p>这里的要点是，路由器必须加载任何懒模块，然后将它们的配置与应用的根路由器配置合并。一旦配置被合并，我们的应用程序就可以像往常一样访问懒模块中的路由。</p><h3 id="AOT-和懒加载"><a href="#AOT-和懒加载" class="headerlink" title="AOT 和懒加载"></a>AOT 和懒加载</h3><p>不管你是使用 Angular 的即时编译 (JIT) 还是提前编译 (AOT)，懒加载都能很好地运行。如果您正在使用 Angular CLI 构建应用，请运行</p><p><code>ng serve --aot</code></p><p>将使用 AOT 编译来构建和服务应用程序。你的所有功能模块都将提前编译，但它们仍然不会加载到应用中，直到它们被路由到。</p><p>你可以使用此命令</p><p><code>ng build --aot=true</code></p><p>然后你可以检查 <code>/dist</code> 文件夹来查看编译的文件。如果你使用的是我的示例库，你会看到：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/yUQXCT.jpg" alt="alt"></p><p><code>lazy-module-lazy-module-ngfactory.js</code> 就是要懒加载到应用中的文件。它是一个预先编译成模块工厂的 <code>NgModule</code> 。这意味着我们的应用可以在加载后立即使用它，而不必在运行时编译成模块。</p><p><code>ng serve</code> 和 <code>ng build</code> 默认使用 JIT 而不是 AOT。当我们不使用 AOT 构建时，<code>/dist</code> 会有模块而不是工厂</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/VlUdjD.jpg" alt="alt"></p><p>这意味着在懒加载期间，路由器必须将 <code>NgModule</code> 编译为工厂，然后才能使用它。</p><p>不管你使用 AOT 还是 JIT，在懒加载期间，都会影响 Angular 在运行时所采用的的一些步骤。要了解它是如何工作的，我们必须查看 <code>SystemJsNgModuleLoader</code> 的 <code>load</code> 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system_js_ng_module_factory_loader.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemJsNgModuleLoader</span> <span class="title">implements</span> <span class="title">NgModuleFactoryLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  load(path: <span class="built_in">string</span>): <span class="built_in">Promise</span>&lt;NgModuleFactory&lt;<span class="built_in">any</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> offlineMode = <span class="built_in">this</span>._compiler <span class="keyword">instanceof</span> Compiler;</span><br><span class="line">    <span class="comment">// offlineMode === true means AOT. The module is already compiled into a factory ahead of time</span></span><br><span class="line">    <span class="keyword">return</span> offlineMode ? <span class="built_in">this</span>.loadFactory(path) : <span class="built_in">this</span>.loadAndCompile(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 AOT 时，<code>offlineMode</code> 被设置为 <code>true</code> ，编译后的工厂被加载到应用程序中。否则 <code>NgModule</code> 将被下载并使用 <code>loadAndCompile</code> 进行编译，<code>loadAndCompile</code> 使用 Angular 的 <code>Compiler</code> 服务。</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/d3mqxt.jpg" alt="alt"></p><p>两者之间唯一的区别是，使用 JIT 时，懒模块必须在运行时编译为模块工厂。</p><p>不管你选择什么时候编译应用程序，懒加载都可以工作。和往常一样，AOT 会快一些，这通常是推荐的方法。</p><p>到目前为止，我们所看到的一切都发生在路由器的导航循环中。但是，可以在导航循环之外以编程方式加载模块。这个主题以及一些应用 (如动态路由) 将在以后的文章讨论。</p><h3 id="预加载模块"><a href="#预加载模块" class="headerlink" title="预加载模块"></a>预加载模块</h3><p>我们已经看到懒加载模块时如何使初始包变小的。这意味着我们的应用将为用户更快地加载。但我们的工作还没完成。</p><p>假设我们有个大多数用户都可以访问的功能模块。一旦我们下载初始包并加载了应用，就没有理由在开始加载之前等待用户导航到那个流行的功能模块，最好是在后台加载它，这就是预加载发挥作用的地方。</p><p>预加载和懒加载一起工作。这时一种告诉 Angular 什么时候开始加载功能模块的方法。Angular 有两种默认的预加载策略：要么预加载所有内容，要么不预加载任何内容。</p><p>可以使用上面提到的两种默认预加载策略之一，也可以编写自己的自定义预加载策略。</p><p>你可以通过将一个选项传递到 <code>RouteModule.forRoot</code> ，来指定要使用哪一种预加载策略</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// preloading.ts</span></span><br><span class="line">RouterModule.forRoot(ROUTES, &#123;</span><br><span class="line">  <span class="attr">preloadingStrategy</span>: CustomPreloadingStrategy | PreloadAllModules | NoPreloading</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以指定自定义策略或者默认策略之一</p><p>自定义预加载策略被编写为实现 <code>PreloadingStrategy</code> 接口的服务。</p><h3 id="路由器如何调度预加载"><a href="#路由器如何调度预加载" class="headerlink" title="路由器如何调度预加载"></a>路由器如何调度预加载</h3><p>路由器需要某种提示来知道什么时候尝试预加载。在内部，路由器使用 <code>RouterPreloader</code> 的实例，该实例订阅路由器的 <code>events</code> observable 并侦听导航事件。每次发生<code>NavigationEnd</code> 事件时，预加载器都会检查是否有可以预加载的模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// router_preloader.ts</span><br><span class="line">setUpPreloading(): void &#123;</span><br><span class="line">  this.subscription =</span><br><span class="line">      this.router.events</span><br><span class="line">          .pipe(filter((e: Event) =&gt; e instanceof NavigationEnd), concatMap(() =&gt; this.preload()))</span><br><span class="line">          .subscribe(() =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从路由器中侦听 <code>NavigationEnd</code> 事件，然后调用 <code>this.preload</code> 来递归路由配置。</p><p>有趣的事实: 你也可以在应用的任意位置订阅 <code>this.router.events</code>以查看所有的路由器事件。</p><p>如果你正在使用自定义策略，那么何时以及如何预加载模块的确切机制取决于自定义策略如何实现 <code>PreloadingStrategy</code> 的抽象方法 <code>preload</code>。然而，路由器总是在看到 <code>NavigationEnd</code> 时运行检查，看看是否可以预加载任何东西。</p><h3 id="理解-CanLoad-守卫"><a href="#理解-CanLoad-守卫" class="headerlink" title="理解 CanLoad 守卫"></a>理解 CanLoad 守卫</h3><p>最后但并非最不重要的，值得注意的是，懒加载有自己的路由器守卫程序，称为 <strong>CanLoad</strong>。它决定模块是否可以懒加载。如果返回<code>false</code>，模块甚至不会加载到浏览器中。</p><p><strong>注意，这个守卫程序会阻止所有预加载。两者不能同时使用</strong>。</p><p>如果不是这样，我们可能会遇到用户在页面上的问题，并且在后台尝试预加载模块。这将激活 canLoad 守卫检查，该检查可能会失败，并将用户重定向到另一个页面(例如登录页面)，这绝对不是我们希望用户看到的场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular：Angular 路由器之概览</title>
      <link href="/2021/11/22/Angular%EF%BC%9AAngular%20%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E6%A6%82%E8%A7%88/"/>
      <url>/2021/11/22/Angular%EF%BC%9AAngular%20%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：Angular-路由器之概览"><a href="#Angular：Angular-路由器之概览" class="headerlink" title="Angular：Angular 路由器之概览"></a>Angular：Angular 路由器之概览</h1><h2 id="A-Tree-of-States"><a href="#A-Tree-of-States" class="headerlink" title="A Tree of States"></a>A Tree of States</h2><p>Angular 程序是一棵组件树，有一些组件，如根组件，在程序中的位置不变。然而，我们需要动态渲染组件，其中一种方式就是使用路由器。通过使用路由模块的 <code>router-outlet</code> 指令，可以根据当前 url 在程序中某个位置渲染一些组件。例如，一个简单的笔记程序，对于 Case 1 url 你需要渲染 <code>HomeComponent</code> ，对于另一个 Case 2 url，可能需要渲染 <code>NoteComponent</code> 展示笔记列表：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/1XoVjy.jpg" alt="alt"></p><p>路由内部会把这些可被路由的组件称为路由状态，路由器会把程序中可被路由的组件作为一棵路由状态树，上面的示例中，<code>home</code> 页是一个 <code>route state</code>，笔记列表也是一个 <code>route state</code>。</p><p>路由的核心功能是可以在程序内进行组件导航，并且需要路由器在页面的某个出口处渲染组件，url 得随渲染状态进行对应的修改。为此路由器需要把相关的 url 和加载的组件绑定到一起，它通过让开发者定义路由状态，根据对应 url 来渲染对应组件。</p><p>通过在程序内导入 <code>RouterModule</code> 并在 <code>forRoot</code> 方法内定义 <code>Route</code> 对象数组，来定义路由状态，例如，一个简单程序的路由数组定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RouterModule, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ROUTES: Route[] = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">component</span>: HomeComponent &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;notes&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: NotesComponent &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;:id&#x27;</span>, <span class="attr">component</span>: NoteComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    RouterModule.forRoot(ROUTES)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传入的路由对象数组会被构造成如下的一棵路由状态树</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/8ILgJg.jpg" alt="alt"></p><p>重要的是，任何时候，一些路由状态 (即组件的组合) 会根据当前的 url 展示在用户屏幕上，该组合就是所谓的 <code>ActiveRouter</code>。一个 <code>ActiveRouter</code> 仅仅是所有路由状态树的子树而已，比如 <code>/nodes</code> 会被表示成如下的 <code>ActiveRouter</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/H5LIEi.jpg" alt="alt"></p><p>有关攞配置有两个有趣的点：1、<code>RouterModule</code> 有一个 <code>forChild</code> 方法，也可以传入 <code>Router</code> 对象数组，然而尽管 <code>forChild</code> 和 <code>forRoot</code> 方法都包含路由指令和配置，但是 <code>forRoot</code> 可以返回 <code>Router</code> 对象，由于 <code>Router</code> 服务会改变浏览器 <code>location</code> 对象，而 <code>location</code> 对象又是一个全局单例对象，所以 <code>Router</code> 服务对象也必须全局单例。这就是你必须在根模块中只使用一次 <code>forRoot</code> 方法的原因，特性模块中应当应用 <code>forChild</code> 方法。2、当匹配到路由路径时，路由状态 <code>component</code> 属性定义的最贱就会被渲染在 <code>router-outlet</code> 指令挂载的地方，即渲染组件的动态元素。被渲染的组件会作为 <code>router-outler</code> 元素的兄弟节点而不是子节点，<code>router-outlet</code> 也可以层层嵌套，形成父子路由关系。</p><p>程序内部导航时，路由器对象会捕捉导航的 url，并与路由状态树中某个路由状态进行匹配。比如上文提到的路由状态树配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ROUTES: Route[] = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">component</span>: HomeComponent &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;notes&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: NotesComponent &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;:id&#x27;</span>, <span class="attr">component</span>: NoteComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><code>localhost:4200/notes:15</code> 会被匹配并加载 <code>NoteComponent</code> 组件，通过使用其提供的对象如 <code>ActivedRouter</code>，<code>NoteComponent</code> 组件能够访问到参数 15 并显示正确的笔记。带有冒号前缀的路径值，如 <code>:id</code>，也是一个必选参数，会匹配几乎所有值 (本例中是 15)，但是 <code>localhost:4200/iamerror</code> 会匹配失败而报错。</p><p>任意时刻，当前 url 表示当前程序激活路由状态的序列化形式。路由状态的改变会触发 url 的改变，同时，url 的改变也会触发当前激活路由状态的改变，它们表示的是同一个东西。在本系列的下一篇文章，会看到路由器对象根据路径匹配路由的内部算法。现在我们只需要它使用的是最先匹配策略，内部实现采用第一层级搜索，匹配 url 的第一个路径。</p><p>Angular 的路由器如何把程序中所有路由构建为一棵路由状态树是第一步。第二步是导航，描述如何从一个路由状态导航到另一个路由状态。</p><h2 id="路由器生命周期"><a href="#路由器生命周期" class="headerlink" title="路由器生命周期"></a>路由器生命周期</h2><p>与组件生命周期相同，路由器在每一次路由状态切换时也存在生命周期</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/RgljKT.jpg" alt="alt"></p><p>每一次导航周期内，路由器会触发一系列事件。路由器对象也提供了监听路由事件的 <code>observable</code> 对象，用来定义一些自定义的逻辑，如加载动画，或辅助调试路由。值得关注的事件有：</p><ul><li><p><code>NavigationStart</code> 表示单行周期开始。</p></li><li><p><code>NavigationCancel</code> 表示取消本次导航。比如，路由守卫拒绝导航到特定的路由。</p></li><li><p><code>RoutesRecognized</code> 当 url 匹配到对应的路由。</p></li><li><p><code>NavigationEnd</code> 导航成功结束。</p></li></ul><p>每一个路由事件都是 <code>RouterEvent</code> 的子类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ROUTES: Route[] = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">component</span>: HomeComponent &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;notes&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: NotesComponent &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;:id&#x27;</span>, <span class="attr">component</span>: NoteComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>根据上面定义的路由状态，当 url 导航到 <code>http://localhost:4200/notes/42</code>，看看发生什么有趣的事情。总体上来说主要包括以下几步：</p><ul><li>很合重定向会被优先处理，因为只有将最终稳定的 url 匹配到路由状态才有意义，而本示例中没有重定向，所以 <code>http://localhost:4200/notes/42</code> 就是最终稳定的。</li><li>路由器使用最先匹配策略来匹配 url 和路由状态。本示例中，会优先匹配 <code>path: &#39;notes&#39;</code>，然后就是 <code>path: &#39;id&#39;</code>，匹配的路由组件是 <code>NoteComponent</code>。</li><li>由于匹配到了路由状态，所以路由器会检查该路由状态是否存在阻止导航的路由守卫。比如，只有登录用户才能看到笔记列表，而本示例中，没有路由守卫。同时，也没有定义 <code>resolve</code> 预先获取数据，所以路由器会继续执行导。</li><li>路由器会激活该路由状态的路由组件。</li><li>路由器完成导航，然后它会等待下一次路由状态的改变，重复以上过程</li></ul><p>可以通过在 <code>forRoot</code> 方法内开启 <code>enableTrace: true</code> 选项，这样可以在浏览器控制台里看到打印的事件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterModule.forRoot([</span><br><span class="line">  ROUTES,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">enableTracing</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">]),</span><br></pre></td></tr></table></figure><p>同理，组件可以通过注入路由器对象来访问到路由事件流，并订阅该事件流</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.router.events.subscribe( <span class="function">(<span class="params">event: RouterEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(event))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒加载特性模块"><a href="#懒加载特性模块" class="headerlink" title="懒加载特性模块"></a>懒加载特性模块</h2><p>随着程序越来越大，很多功能会被封装在单独的特性模块中，比如，一个卖书的网站可能包括书籍，用户等模块。问题是程序首次加载时不需要展示所有数据，所以没有必要在主模块中包含所有模块。否则这会导致主模块文件膨胀，并导致程序加载时间过长。最好的解决方法就是当用户导航到某些模块再按需加载这些模块，而 Angular 路由器的懒加载功能可以做到这点。</p><p>懒加载模块的实例如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from the Angular docs https://angular.io/guide/lazy-loading-ngmodules#routes-at-the-app-level</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;customers&#x27;</span>,</span><br><span class="line">  <span class="attr">loadChildren</span>: <span class="string">&#x27;app/customers/customers.module#CustomersModule&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传给 <code>loadChildren</code> 属性的值类型是字符串，而不是组件对象引用。在导入模块时，注意避免引用任何懒加载模块，否则编译时依赖该模块，导致 Angular 不得不在主代码包把它编译进来，破坏了懒加载的目的。</p><p>路由器在导航周期的重定向和 url 匹配阶段内，会开始加载懒加载模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the `UrlTree` with the redirection applied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lazy modules are loaded along the way.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">applyRedirects</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    moduleInjector: Injector, configLoader: RouterConfigLoader, urlSerializer: UrlSerializer,</span></span></span><br><span class="line"><span class="params"><span class="function">    urlTree: UrlTree, config: Routes</span>): <span class="title">Observable</span>&lt;<span class="title">UrlTree</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如源码文件 <code>config.ts</code> 所描述的</p><blockquote><p>The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with ‘team’.Then it will extract the set of routes defined in that NgModule, and will transparently add those routes to the main configuration.</p><p>译（路由器会使用注册的 <strong>NgModuleFactoryLoader</strong> 来加载与 ‘team’ 相关的模块，并把该懒加载模块中定义的路由集合，添加到主配置里。）</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular：使用 ViewContainerRef 技术操作 DOM</title>
      <link href="/2021/11/22/Angular%EF%BC%9A%E4%BD%BF%E7%94%A8%20ViewContainerRef%20%E6%8A%80%E6%9C%AF%E6%93%8D%E4%BD%9C%20DOM/"/>
      <url>/2021/11/22/Angular%EF%BC%9A%E4%BD%BF%E7%94%A8%20ViewContainerRef%20%E6%8A%80%E6%9C%AF%E6%93%8D%E4%BD%9C%20DOM/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：使用-ViewContainerRef-技术操作-DOM"><a href="#Angular：使用-ViewContainerRef-技术操作-DOM" class="headerlink" title="Angular：使用 ViewContainerRef 技术操作 DOM"></a>Angular：使用 ViewContainerRef 技术操作 DOM</h1><p>Angular 操作 DOM，总会发现会涉及到 <code>ElementRef</code>，<code>TemplateRef</code>，<code>ViewContainerRef</code> 和其他类。本文将详细讲解他们的使用思路。</p><p>Angular 可以运行在多种平台上，例如浏览器、移动端、<code>Web Worker</code> 等。所以，就需要在特定的平台的 API 和框架接口之间增加一个抽象层，用于屏蔽平台之间的差异性。Angular 中的这个抽象层包括如下引用类型：<code>ElementRef</code>，<code>TemplateRef</code>，<code>ViewRef</code>，<code>ComponentRef</code> 和 <code>ViewContainerRef</code>。本文将详细讲解这些引用类型以及他们如何用来操作 DOM。</p><h2 id="ViewChild"><a href="#ViewChild" class="headerlink" title="@ViewChild"></a>@ViewChild</h2><p>在探索 DOM 抽象层之前，先了解下如何在组件 / 指令中访问它们。Angular 提供了一种叫 <code>DOM querys</code> 的技术，它们以 <code>@ViewChild</code> 和 <code>@ViewChildren</code> 装饰器的形式出现。两者功能类似，唯一区别是 <code>@ViewChild</code> 返回单个引用，<code>@ViewChildren</code> 返回由 <code>QueryList</code> 对象包装的好多个引用。本文将以 <code>ViewChild</code> 装饰器为例，后面描述时省略 <code>@</code> 符号。</p><p>通常这些装饰器与模板引用变量配合使用，模板引用变量可以理解为 DOM 元素的引用标识，类似 <code>html</code> 元素的 <code>id</code> 属性。你可以使用模板引用来标记一个 DOM 元素 (下文示例中的 <code>#tref</code>)，并在组件/指令仲使用 <code>ViewChild</code> 装饰器查询到它，比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span #tref&gt;I am span&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> <span class="title">implements</span> <span class="title">AfterViewInit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;tref&quot;</span>, &#123;<span class="attr">read</span>: ElementRef&#125;) tref: ElementRef;</span><br><span class="line"></span><br><span class="line">    ngAfterViewInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// outputs `I am span`</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.tref.nativeElement.textContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewChild</code> 装饰器的基本语法是</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>([reference <span class="keyword">from</span> template], &#123;<span class="attr">read</span>: [reference <span class="keyword">type</span>]&#125;);</span><br></pre></td></tr></table></figure><p>上例中你可以看到，我们把 <code>tref</code> 作为模板引用名称，并将 <code>ElementRef</code> 与该元素联系起来，第二个参数 <code>read</code> 是可选的，因为 Angular 会根据 DOM 元素的类型推断出该引用类型。例如，如果 <code>tref</code> 挂载的是类似于 <code>span</code> 的简单 html 元素，Angular 推断为 <code>ElementRef</code> 类型；如果它挂载的是 <code>template</code> 元素，Angular 推断为 <code>TemplateRef</code> 类型。一些引用类型如 <code>ViewContainerRef</code> 就不可以被 Angular 推断出来，所以必须在 <code>read</code> 参数中显式声明。其他如 <code>ViewRef</code> 不可以挂载在 DOM 元素中，所以必须手动在构造函数中编码构造出来。</p><h2 id="ElementRef"><a href="#ElementRef" class="headerlink" title="ElementRef"></a>ElementRef</h2><p>这时最基本的抽象类，如果查看它的类结构，会发现它仅仅包含与原生元素交互的方法，这对访问原生 DOM 元素很有用，比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// outputs `I am span`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.tref.nativeElement.textContent);</span><br></pre></td></tr></table></figure><p>然而，Angular 团队不鼓励这种写法，不仅因为这种方式会存在安全风险，而且还会让程序与渲染层紧耦合，这样就很难实现在多平台运行相同的应用程序。我认为这个问题并不是使用 <code>nativeElement</code> 导致的，而是使用特定的 DOM API 造成的，例如使用了 <code>textContent</code>。但是后文会看到，Angular 实现了操作 DOM 的整体思路模型，这样就不用必须调用平台指定的低层次抽象的 API，如 <code>textContent</code>。</p><p>使用 <code>ViewChild</code> 装饰器可以返回任何 DOM 元素对应的 <code>ElementRef</code>，但是由于所有组件挂载在自定义 DOM 元素中，所有指令也都应用在 DOM 元素上，所以组件和指令都可以通过 DI (Dependency Injection) 获取宿主元素的 <code>ElementRef</code> 对象，例如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> hostElement: ElementRef</span>)</span> &#123;</span><br><span class="line">          <span class="comment">//outputs &lt;sample&gt;...&lt;/sample&gt;</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.hostElement.nativeElement.outerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所有组件可以通过 DI 访问到它的宿主元素，但 <code>ViewChild</code> 装饰器经常被用来获取模板视图中的 DOM 元素。然而指令却相反，因为指令没有模板，所以主要用来获取挂载指令的宿主元素。</p><h2 id="TemplateRef"><a href="#TemplateRef" class="headerlink" title="TemplateRef"></a>TemplateRef</h2><p>模板就是一组 DOM 元素的组合体，并且可以在整个应用中被重复使用。Angular 使用 <code>TemplateRef</code> 类来操作 <code>template</code> 元素 (<code>&lt;ng-template&gt;</code> 是 Angular 提供的类似于 <code>&lt;template&gt;</code> 原生 html 标签)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;ng-template #tpl&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;I am span in template&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> <span class="title">implements</span> <span class="title">AfterViewInit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;tpl&quot;</span>) tpl: TemplateRef&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngAfterViewInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> elementRef = <span class="built_in">this</span>.tpl.elementRef;</span><br><span class="line">        <span class="comment">// outputs `template bindings=&#123;&#125;`</span></span><br><span class="line">        <span class="built_in">console</span>.log(elementRef.nativeElement.textContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular 框架从 DOM 中移除了 <code>template</code> 元素，并在其位置插入了注释，这时渲染后的样子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sample</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--template bindings=&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sample</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>TemplateRef</code> 是一个结构简单的抽象类，它的 <code>elementRef</code> 属性是对其宿主元素的引用，它还有一个 <code>createEmbeddedView</code> 方法。<code>createEmbeddedView</code> 方法非常有用，因为它可以创建一个视图并返回该视图的引用对象 <code>ViewRef</code>。</p><h2 id="ViewRef"><a href="#ViewRef" class="headerlink" title="ViewRef"></a>ViewRef</h2><p>该抽象类型表示一个 Angular 视图，在 Angular 世界里，视图是构建应用中 UI 的基础单位。它是可以同时创建和销毁的最小元素组合。Angular 鼓励开发者把 UI 作为一堆视图的组合，而不仅仅是 html 标签组成的树。</p><p>Angular 支持两种视图</p><ul><li>内嵌视图 (EmbeddedView)，与 <code>TemplateRef</code> 关联</li><li>宿主视图 (HostView)，与 <code>Component</code> 关联</li></ul><h3 id="创建内嵌视图"><a href="#创建内嵌视图" class="headerlink" title="创建内嵌视图"></a>创建内嵌视图</h3><p>模板仅仅是视图的蓝图，可以通过之前提到的 <code>createEmbeddedView</code> 方法来创建视图，比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ngAfterViewInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="built_in">this</span>.tpl.createEmbeddedView(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建宿主视图"><a href="#创建宿主视图" class="headerlink" title="创建宿主视图"></a>创建宿主视图</h3><p>宿主视图是在组件动态实例化时创建的，一个动态组件可以通过 <code>ComponentFactoryResolver</code> 创建</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> injector: Injector,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">private</span> r: ComponentFactoryResolver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> factory = <span class="built_in">this</span>.r.resolveComponentFactory(ColorComponent);</span><br><span class="line">    <span class="keyword">let</span> componentRef = factory.create(injector);</span><br><span class="line">    <span class="keyword">let</span> view = componentRef.hostView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Angular 中，每个组件都绑定着一个指定的注入器 (Injector) 实例，所以创建 <code>ColorComponent</code> 组件时传入当前组件 (即 <code>SampleComponent</code>) 的注入器。另外，别忘了，动态创建的组件，需要再 <code>ngModule</code> 中或者宿主组件中增加 EntryComponents 配置。</p><p>一旦视图创建，就可以使用 <code>ViewContainer</code> 插入 DOM 树中，下文主要探究这个功能。</p><h2 id="ViewContainerRef"><a href="#ViewContainerRef" class="headerlink" title="ViewContainerRef"></a>ViewContainerRef</h2><p>视图容器可以挂载一个或多个视图</p><p>首先需要说的是，任何 DOM 元素都可以作为视图容器，然而有趣的是，对于绑定 <code>ViewContainer</code> 的 DOM 元素，Angular 不会把视图插入该元素的内部，而是追加到该元素的后边，这类似于 <code>router-outlet</code> 中插入组件的方式。</p><p>通常，比较好的方式是把 <code>ViewContainer</code> 绑定在 <code>ng-container</code> 元素上，因为 <code>ng-container</code> 元素会被渲染成注释，从而不会再 DOM 中引入多余的 html 元素。下面示例描述在组件模板中如何创建 <code>ViewContainer</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am first span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-container #vc&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am last span&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> <span class="title">implements</span> <span class="title">AfterViewInit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;vc&quot;</span>, &#123;<span class="attr">read</span>: ViewContainerRef&#125;) vc: ViewContainerRef;</span><br><span class="line"></span><br><span class="line">    ngAfterViewInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// outputs `template bindings=&#123;&#125;`</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.vc.element.nativeElement.textContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同其他 DOM 抽象类一样，<code>ViewContainer</code> 绑定到特殊的 DOM 元素，并可以通过 <code>element</code> 访问到。例如上例中，它绑定到 <code>ng-container</code> 元素上，并且渲染为 html 注释，所以输出会是 <code>template bindings=&#123;&#125;</code>。</p><h3 id="操作视图"><a href="#操作视图" class="headerlink" title="操作视图"></a>操作视图</h3><p><code>ViewContainer</code> 提供了一些操作视图 API</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewContainerRef</span> </span>&#123;</span><br><span class="line">    ...m</span><br><span class="line">    clear() : <span class="built_in">void</span></span><br><span class="line">    insert(viewRef: ViewRef, index?: <span class="built_in">number</span>) : ViewRef</span><br><span class="line">    get(index: <span class="built_in">number</span>) : ViewRef</span><br><span class="line">    indexOf(viewRef: ViewRef) : <span class="built_in">number</span></span><br><span class="line">    detach(index?: <span class="built_in">number</span>) : ViewRef</span><br><span class="line">    move(viewRef: ViewRef, <span class="attr">currentIndex</span>: <span class="built_in">number</span>) : ViewRef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上文我们已经知道内嵌视图和宿主视图的创建方式，当创建视图之后，就可以通过 <code>insert</code> 方法插入 DOM 中。下面示例描述如何通过 <code>ng-template</code> 创建内嵌视图，并在 <code>ng-container</code> 中插入该视图</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am first span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-container #vc&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am last span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-template #tpl&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;I am span in template&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> <span class="title">implements</span> <span class="title">AfterViewInit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;vc&quot;</span>, &#123;<span class="attr">read</span>: ViewContainerRef&#125;) vc: ViewContainerRef;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;tpl&quot;</span>) tpl: TemplateRef&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngAfterViewInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="built_in">this</span>.tpl.createEmbeddedView(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.vc.insert(view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的实现，最后的 <code>html</code> 看起来是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sample</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I am first span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--template bindings=&#123;&#125;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I am span in template<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I am last span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--template bindings=&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sample</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(从上文中知道是追加到 <code>ng-container</code> 后边，而不是插入到该 DOM 元素内部，因为在 Angular 中 <code>ng-container</code> 元素不会生成真实的 DOM 元素，所以在结构中不会发现这个追加的痕迹，如果把 <code>ng-container</code> 换成其他元素，则可以明显看到视图是追加在 <code>ViewContainer</code> 之后的：<code>&lt;div _ngcontent-c4=&quot;&quot;&gt;&lt;/div&gt;&lt;span _ngcontent-c4&gt;I am span in template&lt;/span&gt;</code>)</p><p>此外，可以通过 <code>detach</code> 方法从 DOM 移除视图，其他的方法可以很容易通过方法名知道其含义，如通过 <code>index</code> 方法获得对应索引的视图引用，<code>move</code> 方法移动视图位置次序，或者使用 <code>remove</code> 方法从移除所有的视图。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p><code>ViewContainer</code> 也提供了手动创建视图 API</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewContainerRef</span> </span>&#123;</span><br><span class="line">    <span class="attr">element</span>: ElementRef</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">    createComponent(componentFactory...): ComponentRef&lt;C&gt;</span><br><span class="line">    createEmbeddedView(templateRef...): EmbeddedViewRef&lt;C&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个方法是对上文我们手动操作的封装，可以传入模板引用对象或者组件工厂对象来创建视图，并将该视图出入到视图容器特定位置。</p><h2 id="ngTemplateOutlet-和-ngComponentOutlet"><a href="#ngTemplateOutlet-和-ngComponentOutlet" class="headerlink" title="ngTemplateOutlet 和 ngComponentOutlet"></a>ngTemplateOutlet 和 ngComponentOutlet</h2><p>尽管知道 Angular 操作 DOM 的内部机制是好事，但是如果存在某种边界的方式就更好了。Angular 提供了两种跨界指令：<code>ngTemplateOutlet</code> 和 <code>ngComponentOutlet</code>。写作本文时，这两个指令都是实验性的，<code>ngComponentOutlet</code> 也将在 <code>4.0</code> 版本中可用。</p><h3 id="ngTemplateOutlet"><a href="#ngTemplateOutlet" class="headerlink" title="ngTemplateOutlet"></a>ngTemplateOutlet</h3><p>该指令会把 DOM 元素标记为 <code>ViewContainer</code>，并插入由模板创建的内嵌视图，从而不需要在组件类中显式创建该内嵌视图。这意味着，上面实例中创建内嵌视图并插入 <code>#vc</code> DOM 元素的代码就可以重写为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am first span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-container [ngTemplateOutlet]=&quot;tpl&quot;&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am last span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-template #tpl&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;I am span in template&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>从上面示例，我们不需要在组件类中写任何实例化视图的代码，非常方便。</p><h3 id="ngComponentOutlet"><a href="#ngComponentOutlet" class="headerlink" title="ngComponentOutlet"></a>ngComponentOutlet</h3><p>这个指令和 <code>ngTemplateOutlet</code> 很相似，区别是一个是用于宿主视图，另外一个是用于内嵌视图，使用如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngComponentOutlet</span>=<span class="string">&quot;ColorComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似有很多新知识需要消化啊，但实际上 Angular 通过视图操作 DOM 的思路模型是很清晰和连贯的。你可以使用 <code>ViewChild</code> 查询模板引用变量来获得 Angular DOM 元素的引用对象；DOM 元素的最简单封装是 <code>ElementRef</code>；而对于模板，你可以使用 <code>TemplateRef</code> 来创建内嵌视图；而对于组件，可以使用 <code>ComponentRef</code> 来创建宿主视图，同时又可以使用 <code>ComponentFactoryResolver</code> 创建 <code>ComponentRef</code>。这两个创建的视图（即内嵌视图和宿主视图）又会被 <code>ViewContainerRef</code> 管理。最后，Angular 又提供了两个快捷指令自动化这个过程：<code>ngTemplateOutlet</code> 指令使用模板创建内嵌视图；<code>ngComponentOutlet</code> 使用动态组件创建宿主视图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular：Angular 路由器之理解路由器导航循环</title>
      <link href="/2021/11/22/Angular%EF%BC%9AAngular%20%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E7%90%86%E8%A7%A3%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AF%BC%E8%88%AA%E5%BE%AA%E7%8E%AF/"/>
      <url>/2021/11/22/Angular%EF%BC%9AAngular%20%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E7%90%86%E8%A7%A3%E8%B7%AF%E7%94%B1%E5%99%A8%E5%AF%BC%E8%88%AA%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：Angular-路由器之理解路由器导航循环"><a href="#Angular：Angular-路由器之理解路由器导航循环" class="headerlink" title="Angular：Angular 路由器之理解路由器导航循环"></a>Angular：Angular 路由器之理解路由器导航循环</h1><p>本文结束时，你将会明白在导航过程中，路由器将会询问自身三个问题</p><ul><li>对于给定的 url，路由应该导航到哪一组组件？</li><li>路由可以导航到响应的组件？</li><li>路由是否应该为响应的组件预取数据</li></ul><p>在此过程中，我们将详细了解以下内容</p><ul><li>从开始到结束的整个路由过程</li><li>在导航期间和之后，路由器如何构建和使用 <code>ActiveRouterSnapshot</code> 对象树</li><li>使用 <code>&lt;router-outlet&gt;</code> 指令渲染内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/27J53w.jpg" alt="alt"></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>在 Angular 中，我们构建单页应用，这意味着每当 url 改变时，我们实际上并不会从服务器加载新的页面。相反，路由器在浏览器中提供基于位置的导航，这对于单页应用来说必不可少。它允许我们在不刷新页面的情况下改变用户看到的内容以及 url。</p><p>每当 url 改变时就会发生导航 (路由)。我们需要一种在应用视图之间导航的方法，而带有 <code>href</code> 的标准锚标记将不起作用，因为这将触发整个页面的重载。这就是 Angular 为我们 <code>[routerLink]</code> 指令的原因。当点击时，它告诉路由器更新 url 并使用 <code>&lt;router-outlet&gt;</code> 指令渲染内容，而无需重载页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- without a routerLink --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;localhost:4200/users&#x27;</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="comment">&lt;!-- not what we want! --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- with a routerLink --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">&quot;[&#x27;/users&#x27;]&quot;</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="comment">&lt;!-- router will handle this --&gt;</span></span><br></pre></td></tr></table></figure><p>对于每次导航，当路由器在屏幕上渲染新组件之前，会执行一系列步骤。这就是路由器导航生命周期。</p><p>成功导航的输出是：由 <code>&lt;router-outlet&gt;</code> 渲染的新组建以及一个被用作可查询的导航记录的树形 <code>ActivedRouter</code> 数据结构。出于我们的目的，只需要理解开发者和路由器都用 <code>ActivedRoute</code> 获取导航的相关信息，例如查询参数和组件内容</p><h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h3><p>我们将使用一个非常简单的应用作为运行示例。这是路由器配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ROUTES = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: UsersComponent,</span><br><span class="line">    <span class="attr">canActivate</span>: [CanActivateGuard],</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">      <span class="attr">users</span>: UserResolver</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>该应用由一路由 <code>/users</code> 组成，它检查查询参数以查看用户是否登录 (<code>login = 1</code>)，然后显示它从模拟 API 服务检索到的用户名列表。</p><p>应用的细节不重要，我们只需要一个示例来查看导航循环</p><h3 id="导航循环和路由事件"><a href="#导航循环和路由事件" class="headerlink" title="导航循环和路由事件"></a>导航循环和路由事件</h3><p>查看导航循环的一个好办法就是订阅路由器服务的 <code>events</code> observable</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.router.events.subscribe( <span class="function">(<span class="params">event: RouterEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(event))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发期间，也可以在路由器配置中传入选项 <code>enableTracing: true</code> 以观察导航循环</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RouterModule.forRoot(ROUTES, &#123;</span><br><span class="line">  <span class="attr">enableTracing</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在开发者控制台里，我们可以看到在导航到 <code>/users</code> 路由期间发出的事件</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/PlUxTv.jpg" alt="alt"></p><p>这些事件对于研究或调试路由器非常有用，也很容易利用它们，在导航期间显示加载消息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.router.events.subscribe(<span class="function"><span class="params">evt</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> NavigationStart) &#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;Loading...&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.displayMessage = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> NavigationEnd) <span class="built_in">this</span>.displayMessage = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行个指向 <code>/users</code> 的导航</p><h3 id="导航开始-Navigation-Start"><a href="#导航开始-Navigation-Start" class="headerlink" title="导航开始 (Navigation Start)"></a>导航开始 (Navigation Start)</h3><p><code>events: NatigationStart</code></p><p>在我们的示例应用中，用户首先点击了以下链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">&quot;[&#x27;/users&#x27;]&quot;</span> [<span class="attr">queryParams</span>]=<span class="string">&quot;&#123;&#x27;login&#x27;: &#x27;1&#x27;&#125;&quot;</span>&gt;</span>Authorized Navigation<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导航到 <code>/users</code>，传入查询参数 <code>login=1</code></p><p>每当路由器检测到对路由链接指令的点击时，就会启动导航循环。启动导航也有其他的方式，例如路由服务的 <code>navigate</code> 和 <code>navigateByUrl</code> 方法。</p><p>以前，Angular 应用中可能同时运行多个导航 (因此需要导航 id)，但是由于此更改，一次只能拥有一个导航。</p><h3 id="URL-匹配以及重定向"><a href="#URL-匹配以及重定向" class="headerlink" title="URL 匹配以及重定向"></a>URL 匹配以及重定向</h3><p><code>events: RoutesRecognized</code></p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/Djui1L.jpg" alt="alt"></p><p>首先，路由器会对路由器配置数组 (我们的示例中的 <code>ROUTES</code>) 进行深度优先搜索，并尝试将 URL <code>/uses</code> 和众多路由配置项的 <code>path</code> 属性相匹配，同时在此过程中应用重定向。</p><p>在我们的例子中，无需担心重定向，<code>/users</code> 将匹配到 <code>ROUTES</code> 中的以下配置</p><p><code>&#123; path: &#39;users&#39;, component: UsersComponent, ... &#125;</code></p><p>如果匹配到的路径需要一个懒加载的模块，那么它将在此时加载。</p><p>路由器发出 <code>RoutesRecognized</code> 事件，以表明它找到了与 URL 匹配的项，以及一个将要导航到的组件 (UsersComponent)。这回答了路由器的第一个问题，“路由应该导航到哪个组件”。但是没有那么快，路由器必须确保它被允许导航到这个新组件。</p><p>进入路由守卫。</p><h3 id="路由守卫-Route-Guards"><a href="#路由守卫-Route-Guards" class="headerlink" title="路由守卫 (Route Guards)"></a>路由守卫 (Route Guards)</h3><p><code>events: GuardsCheckStart, GuardsCheckEnd</code></p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/2P9TrH.jpg" alt="alt"></p><p>路由守卫是布尔函数，路由器使用它来确定是否可以执行导航操作。作为开发人员，我们使用守卫 (guards) 来控制导航是否可以发生。在我们示例应用中，通过在路由配置中指定 <code>canActive</code> 守卫来检查用户的登录状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;users&#x27;</span>, ..., <span class="attr">canActivate</span>: [CanActivateGuard] &#125;</span><br></pre></td></tr></table></figure><p>守卫函数如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canActivate(route: ActivatedRouteSnapshot, <span class="attr">state</span>: RouterStateSnapshot): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.auth.isAuthorized(route.queryParams.login);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当查询参数 <code>login = 1</code> 时，<code>isAuthorized</code> 会返回 <code>true</code></p><p>此守卫传递 <code>login</code> 查询参数到 <code>auth</code> 服务中 (本例中为 <code>auth.service.ts</code>)</p><p>如果对 <code>isAuthorzed(route.queryParams.login)</code> 的调用返回了 <code>true</code> ，那么守卫传参成功。否则，守卫传参失败，路由器会发出 <code>NavigationCancel</code> 事件，然后中止整个导航。</p><p>其他的守卫 (guards) 包括 <code>canLoad</code> (模块是否被懒加载)、<code>canActivateChild</code> 、<code>canDeactivate</code> (存在表单填写的场景下，为了防止已填写的表单信息丢失，阻止用户直接从当前页面导航离开)。</p><p>守卫类似于服务，它们被注册为提供者 (<code>providers</code>)，并且是 <code>Injectable</code> 的。每当 URL 发生变化时，路由器都会运行守卫程序。</p><p><code>canActive</code> 守卫在为路由获取数据之前运行，因为没有理由为不应该被激活的路由获取数据。一旦通过了守卫，路由器就回答了第二个问题：“我应该执行这个导航吗？”。路由器现在可以使用解析器 (resolvers) 预获取数据了。</p><h3 id="路由解析器-Route-Resolvers"><a href="#路由解析器-Route-Resolvers" class="headerlink" title="路由解析器 (Route Resolvers)"></a>路由解析器 (Route Resolvers)</h3><p><code>events: ResolverStart, ResolverEnd</code></p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/JUFpaS.jpg" alt="alt"></p><p>路由解析器是我们可以在导航的过程中，在路由器渲染内容之前用来预取数据的函数。类似于守卫，我们在路由配置中使用 <code>resolve</code> 属性指定解析器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;users&#x27;</span>, ..., <span class="attr">resolve</span>: &#123; <span class="attr">users</span>: UserResolver &#125; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.resolver.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserResolver</span> <span class="title">implements</span> <span class="title">Resolve</span>&lt;<span class="title">Observable</span>&lt;<span class="title">any</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> userService: MockUserDataService</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  resolve(): Observable&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.userService.getUsers();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦路由器将 URL 匹配到某个路径，并且所有的守卫都通过了，它将调用 <code>UserResolver</code> 类中定义的 <code>resolve</code> 方法来获取数据。路由器将结果存储在 <code>ActivatedRoute</code> 服务的 <code>data</code> 对象的键 ( key ) <code>users</code> 下。可以通过订阅 <code>ActivatedRoute</code> 服务的 <code>data</code> observable 来读取此信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activatedRouteService.data.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> data.users);</span><br></pre></td></tr></table></figure><p>在 <code>UsersComponent</code> 里使用 <code>ActivatedRoute</code> 服务，从解析器里检索数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> users = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> route: ActivatedRoute</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.route.data.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">this</span>.users = data.users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析器允许我们在路由期间预获取组件数据。这种技术可以通过预获取数据来避免想用户显示部分加载的模板。在内部，路由器有个 <code>runResolve</code> 方法，它将执行解析器，并将结果存储在 <code>ActivatedRoute</code> 快照 (<code>snapshot</code>) 上。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pre_activation.ts</span></span><br><span class="line">future.data = &#123;...future.data,</span><br><span class="line">               ...inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve&#125;;</span><br></pre></td></tr></table></figure><p>一旦路由器处理了所有解析器，下一步就是使用适当的路由器出口 (<code>outlets</code>) 开始渲染组件。</p><h3 id="激活路由-Activated-Route"><a href="#激活路由-Activated-Route" class="headerlink" title="激活路由 (Activated Route)"></a>激活路由 (Activated Route)</h3><p><code>events: ActivationStart, ActivationEnd, ChildActivationStart, ChildActivationEnd</code></p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/fflxpt.jpg" alt="alt"></p><p>现在是时候激活这些组件，并使用 <code>&lt;router-outlet&gt;</code> 显示它们了。路由器可以从 <code>ActivatedRouteSnapshots</code> 树中提取它需要的关于组件的信息，<code>ActivatedRouteSnapshot</code> 树是它在导航循环的前几个步骤构建的。</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/kH6Vsx.jpg" alt="alt"></p><p>所有的魔法发生在路由器的 <code>activateWith</code> 函数里</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">activateWith</span>(<span class="params">activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver|<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isActivated) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Cannot activate an already activated outlet&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._activatedRoute = activatedRoute;</span><br><span class="line">  <span class="keyword">const</span> snapshot = activatedRoute._futureSnapshot;</span><br><span class="line">  <span class="keyword">const</span> component = &lt;<span class="built_in">any</span>&gt;snapshot.routeConfig !.component;</span><br><span class="line">  resolver = resolver || <span class="built_in">this</span>.resolver;</span><br><span class="line">  <span class="keyword">const</span> factory = resolver.resolveComponentFactory(component);</span><br><span class="line">  <span class="keyword">const</span> childContexts = <span class="built_in">this</span>.parentContexts.getOrCreateContext(<span class="built_in">this</span>.name).children;</span><br><span class="line">  <span class="keyword">const</span> injector = <span class="keyword">new</span> OutletInjector(activatedRoute, childContexts, <span class="built_in">this</span>.location.injector);</span><br><span class="line">  <span class="built_in">this</span>.activated = <span class="built_in">this</span>.location.createComponent(factory, <span class="built_in">this</span>.location.length, injector);</span><br><span class="line">  <span class="comment">// Calling `markForCheck` to make sure we will run the change detection when the</span></span><br><span class="line">  <span class="comment">// `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.</span></span><br><span class="line">  <span class="built_in">this</span>.changeDetector.markForCheck();</span><br><span class="line">  <span class="built_in">this</span>.activateEvents.emit(<span class="built_in">this</span>.activated.instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码要点：</p><ul><li>在第 9 行，<code>ComponentFactoryResolver</code> 用于创建 <code>UsersComponent</code> 的实例。路由器从第 7 行 <code>ActivatedRouteSnapshot</code> 中提取此信息。</li><li>在 12 行，组件被真正创建。<code>location</code> 是指向 <code>&lt;router-outlet&gt;</code> 的 <code>ViewContainerRef</code>。</li><li>在创建并激活组件之后，将调用上文未列出的 <code>activateChildRoutes</code>，为用户处理嵌套的 <code>&lt;router-outlet&gt;</code>，即存在子路由的场景。</li></ul><p>路由器将在屏幕上渲染组件。如果所渲染的组件中有任何嵌套的 <code>&lt;router-outlet&gt;</code> 元素，路由器也将遍历并渲染这些元素。</p><h3 id="更新-URL"><a href="#更新-URL" class="headerlink" title="更新 URL"></a>更新 URL</h3><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/kfhueZ.jpg" alt="alt"></p><p>导航循环的最后一步是更新 URL 到 <code>/users</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router_link.ts</span></span><br><span class="line"><span class="keyword">private</span> updateTargetUrlAndHref(): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.href = <span class="built_in">this</span>.locationStrategy.prepareExternalUrl(<span class="built_in">this</span>.router.serializeUrl(<span class="built_in">this</span>.urlTree));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由器现在已尊卑好侦听另一个 URL 变更，并重新开始导航循环。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular：对于 DOM 的新认知及优化技术</title>
      <link href="/2021/11/22/Angular%EF%BC%9A%E5%AF%B9%E4%BA%8E%20DOM%20%E7%9A%84%E6%96%B0%E8%AE%A4%E7%9F%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/11/22/Angular%EF%BC%9A%E5%AF%B9%E4%BA%8E%20DOM%20%E7%9A%84%E6%96%B0%E8%AE%A4%E7%9F%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：对于-DOM-的新认知及优化技术"><a href="#Angular：对于-DOM-的新认知及优化技术" class="headerlink" title="Angular：对于 DOM 的新认知及优化技术"></a>Angular：对于 DOM 的新认知及优化技术</h1><h2 id="视图引擎-View-Engine"><a href="#视图引擎-View-Engine" class="headerlink" title="视图引擎 (View Engine)"></a>视图引擎 (View Engine)</h2><p>假设需要从 <code>DOM</code> 中删除一个子元素，目前已经存在了父组件，父组件的模板中包含一个子组件 <code>A</code>，现在要做的是把 <code>A</code> 从父组件中移除</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button (click)=&quot;remove()&quot;&gt;Remove child component&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;a-comp&gt;&lt;/a-comp&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>解决上述需求，一个错误的方法是：使用 <code>Renderer</code> 或者 <code>native DOM API</code> 来直接删除 <code>&lt;a-comp&gt;</code> DOM 元素</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;...&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.renderer.removeChild(</span><br><span class="line">       <span class="built_in">this</span>.hostElement.nativeElement,      <span class="comment">// parent App comp node</span></span><br><span class="line">       <span class="built_in">this</span>.childComps.first.nativeElement  <span class="comment">// child A comp node</span></span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用浏览器的审查元素功能，查看页面 <code>DOM</code> 节点情况，你会发现 <code>&lt;a-comp&gt;</code> 组件已经从 <code>DOM</code> 元素中移除了</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/1aE9sZ.jpg" alt="alt"></p><p>然而，如果查看控制台的输出，会发现打印结果中，仍然显示子节点的数量为 <code>1</code> 而不是 <code>0</code>。变更检测好像没有检测出子组件已经被移除了，下面是控制台输出的日志</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/03aiwb.jpg" alt="alt"></p><p>之所以出现这种状况，是因为 <code>Angular</code> 内部使用了一种数据结构来描述组件，通常称它为 <code>View</code> (视图) 或者 <code>ComponentView</code>。下图展示了视图和 <code>DOM</code> 之间的关联关系</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/0KiBJD.jpg" alt="alt"></p><p>每个视图由多个 (<code>View Node</code>) 构成，这些节点都包含有 <code>DOM</code> 元素的引用，当我们直接更改 <code>DOM</code> 元素时，视图节点并没有改变。下图演示了从 <code>DOM</code> 树中删除了组件 <code>&lt;a-comp&gt;</code></p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/dPt9Me.jpg" alt="alt"></p><p>所有的变更检测操作，包括 <code>ViewChildren</code> 都是运行在视图上，并非在 <code>DOM</code> 上。Angular 仍然会检测到 <code>&lt;a-comp&gt;</code>组件存在 (因为只是删除了 <code>DOM</code> 中的元素，视图中的引用仍然存在)，打印出子组件数量仍为 <code>1</code>。此外，变更检测也仍然会把 <code>&lt;a-comp&gt;</code> 作为检测对象。</p><blockquote><p>上面的示例说明：不仅仅从 <code>DOM</code> 中删除子组件，应该避免删除任何由矿建创建的 HTML 元素，否则框架无法感知你删除了哪些元素。不过，你可以删除 Angular 框架无法感知到的元素，例如第三方库创建的元素。</p></blockquote><h2 id="ViewContainer"><a href="#ViewContainer" class="headerlink" title="ViewContainer"></a>ViewContainer</h2><p><code>ViewContainer</code> 能够保证发生在其内部的 <code>DOM</code> 操作更安全 (保证 <code>View</code> 与 <code>DOM</code> 同步)，Angular 中所有内置的指令中都有用到它。它是一种特殊类型的 <code>View Node</code>，它既存在视图之中，也可以作为视图的容器，挂载其他视图</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/6nNFua.jpg" alt="alt"></p><p>如上图所示，它能接受两种类型的视图：内嵌视图 (EmbeddedView) 和宿主视图 (HostView)。</p><p>它们是 Angular 仅有的视图类型，它们之间的最大不同是用于创建它们的载体 (API 的输入不同) 不同。内嵌视图仅仅可以添加到 <code>ViewContainer</code> 中，而宿主视图除此之外，还可以添加到任意 <code>DOM</code> 元素中 (这个元素通常称为宿主元素)。</p><p>内嵌视图从模板创建，使用 <code>TemplateRef</code> 方法，宿主视图从视图创建，使用 <code>ComponentFactoryResolver</code> 方法。例如，用来启动 Angular 应用 (<code>AppComponent</code>) 的入口组件，在内部表示为附加到组件的宿主元素 (<code>&lt;app-comp&gt;</code>) 的宿主视图。</p><p><code>ViewContainer</code> 提供了动态创建、操作、移除视图的 API，我们称它为动态视图，是相对框架中使用静态组件模板创建的视图。Angular 静态视图没有使用到 <code>ViewContainer</code>，它是在子组件中指定节点放一个子视图的引用。下图是静态视图的示例</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/XmrxIB.jpg" alt="alt"></p><p>从图中得知，视图中没有 <code>ViewContainer</code> 节点，子视图的引用直接关联到 <code>A</code> 组件。</p><h2 id="动态操作视图"><a href="#动态操作视图" class="headerlink" title="动态操作视图"></a>动态操作视图</h2><p>在开始创建和添加视图到 <code>ViewContainer</code> 之前，首先要把 <code>ViewContainer</code> 添加到组件的模板中，初始化它。任何元素都可以作为 <code>ViewContainer</code>，不过大部分情况，都使用 <code>&lt;ng-container&gt;</code> 元素，因为它在渲染时会被渲染成一个注释节点，因此 <code>DOM</code> 树中不会出现 <code>&lt;ng-container&gt;</code> 元素。</p><p>转换元素为 <code>ViewContainer</code>，可以在 <code>view query</code> 时使用 <code>&#123;read: ViewContainer&#125;</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line"> …</span><br><span class="line"> <span class="attr">template</span>: <span class="string">`&lt;ng-container #vc&gt;&lt;/ng-container&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> <span class="title">implements</span> <span class="title">AfterViewChecked</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">&#x27;vc&#x27;</span>, &#123;<span class="attr">read</span>: ViewContainerRef&#125;) viewContainer: ViewContainerRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得 <code>ViewContainer</code> 的引用之后，那么就可以用它来创建动态视图了。</p><h2 id="创建内嵌视图-Embedded-View"><a href="#创建内嵌视图-Embedded-View" class="headerlink" title="创建内嵌视图 (Embedded View)"></a>创建内嵌视图 (Embedded View)</h2><p>创建内嵌视图，需要一个 <code>template</code>，在 Angular 中，我们使用 <code>&lt;ng-template&gt;</code> 元素来包装 <code>DOM</code> 元素，并且定义它为模板。并且可以通过 <code>view query</code> 的 <code>&#123;read: TemplateRef&#125;</code> 属性得到这个模板的引用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ng-template #tpl&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- any HTML elements can go here --&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> <span class="title">implements</span> <span class="title">AfterViewChecked</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&#x27;tpl&#x27;</span>, &#123;<span class="attr">read</span>: TemplateRef&#125;) tpl: TemplateRef&lt;<span class="literal">null</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 <code>template</code> 引用之后，可以使用 <code>createEmbeddedView</code> 方法来创建和添加一个内嵌视图到 <code>ViewContainer</code> 之中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123; ... &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> <span class="title">implements</span> <span class="title">AfterViewInit</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="title">ngAfterViewInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.viewContainer.createEmbeddedView(<span class="built_in">this</span>.tpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在 <code>ngAfterViewInit</code> 生命周期钩子实现你的逻辑，因为 <code>view query</code> 在 <code>ngAfterViewInit</code> 周期时才初始化。此外，对于内嵌视图，你可以定义一个上下文对象 (<code>context object</code>)，来绑定 <code>&lt;ng-template&gt;</code> 中的值。可以参考 <code>createEmbeddedView()</code> 和 <code>NgTemplateOutlet</code> 来理解这个上下文对象。(<code>NgTemplateOutlet</code> 与 <code>createEmbeddedView</code> 功能上是相同的)。</p><h2 id="创建宿主视图-Host-View"><a href="#创建宿主视图-Host-View" class="headerlink" title="创建宿主视图 (Host View)"></a>创建宿主视图 (Host View)</h2><p>创建宿主视图，需要使用 <code>component factory</code> 方法，更多关于动态创建组件的知识，可以查看这篇文章：<a href="https://indepth.dev/posts/1054/here-is-what-you-need-to-know-about-dynamic-components-in-angular">Here is what you need to know about dynamic components in Angular</a>。</p><p>在 Angular 中，我们使用 <code>ComponentFactoryResolve service</code> 来获取 <code>component factory</code> 的引用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123; ... &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> <span class="title">implements</span> <span class="title">AfterViewChecked</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> r: ComponentFactoryResolver</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">ngAfterViewInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = <span class="built_in">this</span>.r.resolveComponentFactory(ComponentClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除一个视图"><a href="#移除一个视图" class="headerlink" title="移除一个视图"></a>移除一个视图</h2><p>任何添加到 <code>view container</code> 的视图，都可以使用 <code>remove</code> 或者 <code>detach</code> 方法来移除它。这些方法在从 <code>view container</code> 中移除视图的同时，也会从 <code>DOM</code> 删除对应的元素。它们之间的区别是：<code>remove</code> 方法会销毁，此后这个视图无法再次被添加到 <code>view container</code> 中；<code>detach</code> 方法移除的视图，在后续还可以被重新添加到 <code>view container</code> 之中。这些特性，我们可以利用来优化 <code>DOM</code> 的操作。</p><p>所以正确的移除一个子组件或者 <code>DOM</code> 元素的方式，是需要首先创建嵌入视图或宿主视图，并把它们添加到 <code>view container</code> 中，并且使用 <code>view container</code> 中提供的 <code>remove</code> 或者 <code>detach</code> 等方法来移除它。</p><h3 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h3><p>在开发中，会遇到这样的场景：我们需要重复的隐藏和显示某个组件或模板元素，类似下图展示的那样</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/8.gif" alt="alt"></p><p>如果我们简单利用上文中学到的知识来解决这个问题，代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;...&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">show</span>(<span class="params"><span class="keyword">type</span></span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// a view is destroyed</span></span><br><span class="line">    <span class="built_in">this</span>.viewContainer.clear();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// a view is created and attached to a view container      </span></span><br><span class="line">    <span class="built_in">this</span>.viewContainer.createComponent(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现，会导致在切换隐藏和显示组件时，频繁地销毁和重建视图。</p><p>在这个特定的示例中，因为它是宿主视图，所以销毁和重新创建视图使用了 <code>component factory</code> 和 <code>createComponent</code> 方法。如果我们使用 <code>createEmbeddedView</code> 和 <code>TemplateRef</code>，那么就是内嵌视图被销毁和重建</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">show</span>(<span class="params"><span class="keyword">type</span></span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// a view is destroyed</span></span><br><span class="line">    <span class="built_in">this</span>.viewContainer.clear();</span><br><span class="line">    <span class="comment">// a view is created and attached to a view container</span></span><br><span class="line">    <span class="built_in">this</span>.viewContainer.createEmbeddedView(<span class="built_in">this</span>.tpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在理想状况下，我们仅需要创建一次视图，在后续的显示 / 隐藏过程中，可以复用这个视图。<code>ViewContainerRef</code> API 中提供了这样的方法，它支持添加视图到 <code>ViewContainer</code> 且在移除视图时不会测地销毁这个视图。</p><h2 id="ViewRef"><a href="#ViewRef" class="headerlink" title="ViewRef"></a>ViewRef</h2><p><code>ComponentFactory</code> 和 <code>TemplateRef</code> 实现了 <code>view</code> 接口创建视图的方法，都可以用来创建一个视图。事实上，<code>ViewContainer</code> 在调用 <code>createComponent</code> 和 <code>createEmbeddedView</code> 方法时以及传递输入数据时，隐藏了一些细节。我们也可以自己利用这些方法来创建宿主视图或者内嵌视图，并且获得视图的引用，在 Angular 中这个视图的引用即是：<code>ViewRef</code> 以及它的子类。</p><h2 id="创建一个宿主视图"><a href="#创建一个宿主视图" class="headerlink" title="创建一个宿主视图"></a>创建一个宿主视图</h2><p>下面是使用 <code>component factory</code> 来创建一个宿主视图，并且获得返回的引用的示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aComponentFactory = resolver.resolveComponentFactory(AComponent);</span><br><span class="line">aComponentRef = aComponentFactory.create(<span class="built_in">this</span>.injector);</span><br><span class="line">view: ViewRef = aComponentRef.hostView;</span><br></pre></td></tr></table></figure><p>在宿主视图下，<code>create</code> 方法返回的 <code>ComponentRef</code> 中包含组件关联的视图，可由 <code>hostView</code> 属性获得。</p><p>获得视图引用后，我们就可以使用 <code>insert</code> 方法来添加到 <code>ViewContainer</code> 中。结合上文提到的 <code>detach</code> 方法的特性，可以得出优化的方法为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">showView2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Existing view 1 is removed from a view container and the DOM</span></span><br><span class="line">    <span class="built_in">this</span>.viewContainer.detach();</span><br><span class="line">    <span class="comment">// Existing view 2 is attached to a view container and the DOM</span></span><br><span class="line">    <span class="built_in">this</span>.viewContainer.insert(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再提醒一下，这里使用的是 <code>detach</code> 方法，而不是 <code>clear</code> 或者 <code>remove</code> 方法，为的就是保证视图的引用没有被销毁，可以重复使用，不用再次创建。</p><h2 id="创建一个内嵌视图"><a href="#创建一个内嵌视图" class="headerlink" title="创建一个内嵌视图"></a>创建一个内嵌视图</h2><p>内嵌视图是利用 <code>ng-template</code> 进行创建的，创建的视图，由 <code>createEmbeddedView</code> 方法返回</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view1: ViewRef;</span><br><span class="line">view2: ViewRef;</span><br><span class="line"><span class="function"><span class="title">ngAfterViewInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.view1 = <span class="built_in">this</span>.t1.createEmbeddedView(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>.view2 = <span class="built_in">this</span>.t2.createEmbeddedView(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里概念容易弄混，上文和下文提到的两种创建方式 内嵌 / 宿主视图的方式的区别就是：<code>create</code> 的行为是否由 <code>ViewContainer</code> 发起，实际使用效果没有差别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular：深入理解 Angular Modules</title>
      <link href="/2021/11/22/Angular%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Angular%20Modules/"/>
      <url>/2021/11/22/Angular%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Angular%20Modules/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：深入理解-Angular-Modules"><a href="#Angular：深入理解-Angular-Modules" class="headerlink" title="Angular：深入理解 Angular Modules"></a>Angular：深入理解 Angular Modules</h1><p>Angular Modules 是一个相当复杂的话题，本文将深度解析 <code>Modules</code> 内部工作原理，争取做到消除一些常见的误会</p><h2 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h2><p>Angular 引入了模块封装的概念，这个和 ES 模块概念很相似，基本意思是所有声明类型，包括组件、指令和管道，只可以在当前模块内部，被其他声明的组件使用。比如，如果我在 App 组件中使用了 A 模块的 <code>acomp</code> 组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;a-comp&gt;&lt;/a-comp&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>Angular 编译器就会抛出错误</p><blockquote><p> Template parse errors: ‘a-comp’ is not a known element</p></blockquote><p>这是因为 App 模块没有声明 <code>a-comp</code> 组件，如果我想要使用这个组件，就不得不引入 A 模块，就像这样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [..., AModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>上面描述的就是 <strong>模块封装</strong>。不仅如此，如果想要 <code>a-comp</code> 组件正常工作，得设置它为可以公开访问，即在 A 模块的 <code>export</code> 属性中导出这个组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">declarations</span>: [AComponent],</span><br><span class="line">  <span class="attr">exports</span>: [AComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>同理，对于指令和管道，也必须遵循 <strong>模块封装</strong> 的规则</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    PublicPipe, </span><br><span class="line">    PrivatePipe, </span><br><span class="line">    PublicDirective, </span><br><span class="line">    PrivateDirective</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">exports</span>: [PublicPipe, PublicDirective]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>模块封装</strong> 原则不适用于在 <code>entryComponents</code> 属性中注册的组件，如果你在使用动态视图时，即实例化动态组件的方式引入 <code>a-comp</code> ，就不需要在 A 模块的 <code>export</code> 属性中导出 <code>a-comp</code> 组件，当然，还是得导入 A 模块。</p><p>大多数初学者都认为 <code>providers</code> 也有封装规则，但实际上没有。在 <strong>非懒加载模块</strong> 中声明的任何 <code>providers</code> 都可以在程序内的任何地方被访问。下文会详细解释原因。</p><h2 id="模块层级"><a href="#模块层级" class="headerlink" title="模块层级"></a>模块层级</h2><p>初学者最大的一个误解就是，一个模块导入其他模块之后会形成一个模块层级，认为该模块会成为这个被导入模块的父模块，从而形成一个类似模块树的层级，当然这么想也很合理。但实际上，不存在这样的模块层级。因为 <strong>所有模块在编译阶段都会被合并</strong>，所以导入和被导入模块之间不存在任何层级关系。</p><p>就像组件一样，Angular 编译器也会为根模块生成一个模块工厂，根模块就是你在 <code>main.ts</code> 中，以参数传入 <code>bootstrapModule()</code> 方法的模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platformBrowserDynamic().bootstrapModule(AppModule);</span><br></pre></td></tr></table></figure><p>Angular 编译器使用 <code>createNgModuleFactory</code> 方法来创建该模块工厂，该方法需要几个参数</p><ul><li>Module Class Reference</li><li>Bootstrap Components</li><li>Component Factory Resolver With EntryComponents</li><li>Definition Factory With Merged Module Providers</li></ul><p>最后两点解释了为何 <code>providers</code> 和 <code>entryComponents</code> 没有模块封装规则，因为编译结束后没有多个模块，而仅仅只有一个合并后的模块。并且在编译阶段，编译器不知道你将如何使用 <code>providers</code> 和动态组件。但是在编译阶段的组件模板解析过程中，编译器知道你是如何使用组件、指令和管道的，所以编译器能够控制它们的私有声明。(<code>providers</code> 和 <code>entryComponents</code> 整个程序中的动态部分，Angular 编译器不知道它会被如何使用，但是模板中写的组件、指令和管道，是静态部分，Angular 编译器在编译的时候知道它是如何被使用的。这点对理解 Angular 内部工作原理还是比较重要的。)</p><p>看一个生成模块工厂的示例，假设有 <code>A</code> 和 <code>B</code> 两个模块，并且每一个模块都定义了一个 <code>provider</code> 和一个 <code>entryComponents</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [&#123;<span class="attr">provide</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">useValue</span>: <span class="string">&#x27;a&#x27;</span>&#125;],</span><br><span class="line">  <span class="attr">declarations</span>: [AComponent],</span><br><span class="line">  <span class="attr">entryComponents</span>: [AComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AModule</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [&#123;<span class="attr">provide</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">useValue</span>: <span class="string">&#x27;b&#x27;</span>&#125;],</span><br><span class="line">  <span class="attr">declarations</span>: [BComponent],</span><br><span class="line">  <span class="attr">entryComponents</span>: [BComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>根模块 <code>App</code> 也定义了一个 <code>provider</code> 和根组件 <code>app</code>，并导入 <code>A</code> 和 <code>B</code> 模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [AModule, BModule],</span><br><span class="line">  <span class="attr">declarations</span>: [AppComponent],</span><br><span class="line">  <span class="attr">providers</span>: [&#123;<span class="attr">provide</span>: <span class="string">&#x27;root&#x27;</span>, <span class="attr">useValue</span>: <span class="string">&#x27;root&#x27;</span>&#125;],</span><br><span class="line">  <span class="attr">bootstrap</span>: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/09/26/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/26/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="面试题：判断一个链表是否有环"><a href="#面试题：判断一个链表是否有环" class="headerlink" title="面试题：判断一个链表是否有环"></a>面试题：判断一个链表是否有环</h2><ul><li>硬做法。遍历一个链表，然后观察这个列表的尽头的 <code>next</code> 指针是否指向 <code>null</code> ，如果指向 <code>null</code> 则说明该链表没有环，如果一直死循环就说明该链表有环。</li><li>使用 <code>Set</code> 数据结构来判重。<code>Set</code> 这个数据结构用于判重的话，他的时间复杂度是 <code>O(1)</code> 。具体做法：遍历链表，然后将链表节点的每一个 <code>next</code> 指针都记录在 <code>Set</code> 这个数据结构当中，然后每次放进 <code>Set</code> 之前，都使用 <code>Set</code> 中的元素和将要放进 <code>Set</code> 的元素进行一个判重，如果返回 <code>true</code> ，说明有环，如果链表循环完还没有返回 <code>true</code> ，则说明没有环。时间复杂度为 <code>O(n · 1)</code> 即为 <code>O(n)</code>。</li><li>使用快慢指针。具体做法是：定义两个指针，他们的步速不一样，一个的步速为 <code>1</code> ，另一个的步速为 <code>2</code> 。然后按照各自的步速来遍历链表，如果链表没有环，那这两个指针不会相遇，并且不会陷入死循环。但是如果链表有环，那么这两个指针就会相遇。遍历链表的结束条件为：指针到了链表的尽头，也就是 <code>next</code> 指针为 <code>null</code> 或者是两个指针相遇了。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Angular：深入理解依赖注入 (DI)</title>
      <link href="/2021/07/15/Angular%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%20(DI)/"/>
      <url>/2021/07/15/Angular%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%20(DI)/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular：深入理解依赖注入-DI"><a href="#Angular：深入理解依赖注入-DI" class="headerlink" title="Angular：深入理解依赖注入 (DI)"></a>Angular：深入理解依赖注入 (DI)</h1><p>如果之前没有深入理解 Angular 依赖注入系统，那么或许你会认为 Angular 程序内的根注入器包含所有合并的服务提供商，每一个组件都有它自己的注入器，延迟加载模块有它自己的注入器。</p><p>但是，仅仅知道这些或许不够。</p><p>在 Angular 中，有两个注入器层次结构：</p><ul><li>Module Injector (模块注入器)：使用 @NgModule( ) 或 @Injectable( ) 注解在此层次结构中配置 Module Injector</li><li>Element Injector (元素注入器)：在每一个 DOM 上隐式创建</li></ul><h2 id="注入器树-Injector-Tree"><a href="#注入器树-Injector-Tree" class="headerlink" title="注入器树 (Injector Tree)"></a>注入器树 (Injector Tree)</h2><p>大多数开发者都知道，Angular 会创建根注入器，根注入器内的服务都是单例的。但是，貌似还有其他注入器是它的父级。</p><p>作为一名开发者，我想知道 Angular 是怎么构建注入器树的，下图是注入器树的顶层部分：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/g7kRmn.jpg" alt="alt"></p><p>这不是整棵树，目前还没有任何组件，后面会继续画树的其他部分，先看一下根注入器 AppModule Injector，因为他最常用。</p><h2 id="根注入器-root-AppModule-Injector"><a href="#根注入器-root-AppModule-Injector" class="headerlink" title="根注入器 (root AppModule Injector)"></a>根注入器 (root AppModule Injector)</h2><p>我们知道 Angular 程序注入器就是上图中的 AppModule Injector，上文说了，这个根注入器包含所有中间模块的服务提供商，也就是说 (不翻译) ：</p><blockquote><p>If we have a module with some providers and import this module directly in AppModule or in any other module, which has already been imported in AppModule, then those providers become application-wide providers.</p></blockquote><p>ComponentFactoryResolver 也会添加到这个根注入器当中，因为它是用于动态创建定义在 entryComponents 属性中的组件。</p><p>为了实例化根注入器，Angular 使用 <code>AppModule</code> 工厂函数，这个函数的位置在 <code>module.ngfactory.js</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/lIz3Si.jpg" alt="alt"></p><p>我们可以看到这个工厂函数返回的是一个融合了所有 Provider 的一个 Module 定义。相信大多数开发者都知道。</p><h2 id="平台注入器-Platform-Injector"><a href="#平台注入器-Platform-Injector" class="headerlink" title="平台注入器 (Platform Injector)"></a>平台注入器 (Platform Injector)</h2><p>事实证明，<code>AppModule</code> 根注入器的上一级有一个父注入器叫做 <code>NgZoneInjector</code>，他也有一个父注入器，名字叫做 <code>PlatformInjector</code>。</p><p>平台注入器通常包括了一些内置的 Provider，但是我们也可以在创建平台的时候往平台注入器中添加我们自定义的 Provider：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> platform = platformBrowserDynamic([ &#123; </span><br><span class="line">  <span class="attr">provide</span>: SharedService, </span><br><span class="line">  <span class="attr">deps</span>:[] </span><br><span class="line">&#125;]);</span><br><span class="line">platform.bootstrapModule(AppModule);</span><br><span class="line">platform.bootstrapModule(AppModule2);</span><br></pre></td></tr></table></figure><p>我们传进 platform 中的这个额外的 Provider必须是 StaticProviders。如果不了解 StaticProvider 和 Provider 的区别，可以点击这里查看 <a href="https://stackoverflow.com/questions/48594944/can-deps-also-be-used-with-useclass/48595518#48595518">Answer</a></p><p>虽然现在比较清晰 Angular 是如何根注入器和其父注入器是如何解析依赖的。但是，对于组件级别的注入器还是有一点迷惑，所以我们开始探索。</p><h2 id="EntryComponent-and-RootData"><a href="#EntryComponent-and-RootData" class="headerlink" title="EntryComponent and RootData"></a>EntryComponent and RootData</h2><p>当我谈论 ComponentFactoryResolver 的时候，我提到了 <code>entryComponent</code>。这种 components 通常出现在 <code>NgModule</code> 中的 <code>bootstrap</code> 或者 <code>entryComponents</code> 数组中，Angular 路由也会使用他们来创建动态组件。</p><p>Angular 会帮所有的 <code>entryComponents</code> 创建宿主工厂函数，这些宿主工厂函数就是其他视图的根视图，这就意味着：</p><blockquote><p>Every time we create dynamic component angular creates root view with root data, that contains references to elInjector and ngModule injector.</p><p>参考译文：每次我们创建动态 Angular 组件时，都会使用根数据 ( <code>RootData</code> ) 创建根视图 ( <code>RootView</code> )。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentFactory_</span> <span class="keyword">extends</span> <span class="title">ComponentFactory</span>&lt;<span class="title">any</span>&gt;</span>&#123;</span><br><span class="line">  create(</span><br><span class="line">      injector: Injector, projectableNodes?: <span class="built_in">any</span>[][], rootSelectorOrNode?: <span class="built_in">string</span>|<span class="built_in">any</span>,</span><br><span class="line">      ngModule?: NgModuleRef&lt;<span class="built_in">any</span>&gt;): ComponentRef&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ngModule) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;ngModule should be provided&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> viewDef = resolveDefinition(<span class="built_in">this</span>.viewDefFactory);</span><br><span class="line">    <span class="keyword">const</span> componentNodeIndex = viewDef.nodes[<span class="number">0</span>].element!.componentProvider!.nodeIndex;</span><br><span class="line">    <span class="comment">// 使用根数据创建根视图</span></span><br><span class="line">    <span class="keyword">const</span> view = Services.createRootView(</span><br><span class="line">        injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);</span><br><span class="line">    <span class="comment">// view.nodes 的访问器</span></span><br><span class="line">    <span class="keyword">const</span> component = asProviderData(view, componentNodeIndex).instance;</span><br><span class="line">    <span class="keyword">if</span> (rootSelectorOrNode) &#123;</span><br><span class="line">      view.renderer.setAttribute(asElementData(view, <span class="number">0</span>).renderElement, <span class="string">&#x27;ng-version&#x27;</span>, VERSION.full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ComponentRef_(view, <span class="keyword">new</span> ViewRef_(view), component);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该根数据 ( <code>RootData</code> ) 包含对 <code>elInjector</code> 和 <code>ngModule</code> 注入器的引用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRootData</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    elInjector: Injector, ngModule: NgModuleRef&lt;<span class="built_in">any</span>&gt;, rendererFactory: RendererFactory2,</span></span></span><br><span class="line"><span class="params"><span class="function">    projectableNodes: <span class="built_in">any</span>[][], rootSelectorOrNode: <span class="built_in">any</span></span>): <span class="title">RootData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sanitizer = ngModule.injector.get(Sanitizer);</span><br><span class="line">  <span class="keyword">const</span> errorHandler = ngModule.injector.get(ErrorHandler);</span><br><span class="line">  <span class="keyword">const</span> renderer = rendererFactory.createRenderer(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ngModule,</span><br><span class="line">    <span class="attr">injector</span>: elInjector, projectableNodes,</span><br><span class="line">    <span class="attr">selectorOrNode</span>: rootSelectorOrNode, sanitizer, rendererFactory, renderer, errorHandler</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在猜测当我们启动一个 Angular 应用。</p><p>当我们执行下面的代码，会发生什么事情</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platformBrowserDynamic().bootstrapModule(AppModule);</span><br></pre></td></tr></table></figure><p>实际上，会发生许多事情，但是我们只对 Angular 如何创建 entry component 感兴趣。</p><p>当应用程序 <code>ApplicationRef</code> 启动 <code>bootstrap</code> 时，会创建 <code>entryComponent</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);</span><br></pre></td></tr></table></figure><p>该过程会使用根数据 <code>RootData</code> 创建根视图 <code>RootView</code>，同时创建根元素注入器，在这里 <code>elInjector</code> 为 <code>Injector.NULL</code>。</p><p>这里就是注入器树被分成元素注入器树和模块注入器树这两个平行树的地方。</p><p>Angular 会有规律的创建下级注入器，每当 Angular 创建一个在 <code>@Component()</code> 中指定了 <code> providers</code> 的组件实例时，它也会为该实例创建一个新的子注入器。类似的，当在运行期间加载一个新的 <code>NgModule</code> 时，Angular 也可以为它创建一个拥有自己的提供者的注入器。</p><p>子模块和组件注入器彼此独立，并且会为所提供的服务分别创建自己的实例。当 Angular 销毁 <code>NgModule</code> 或组件实例时，也会销毁这些注入器以及注入器中的那些服务实例。</p><h2 id="Element-Injector-vs-Module-Injector"><a href="#Element-Injector-vs-Module-Injector" class="headerlink" title="Element Injector vs Module Injector"></a>Element Injector vs Module Injector</h2><p>上一段时间，当懒加载开始广泛地被应用的时候，一个奇怪的现象在 Github 上被报告。依赖注入系统导致延迟加载模块的两倍实例。因此，一个新的设计被引入，从此开始，我们有了两颗平行的树，一个是用于元素，一个是用于模块的。</p><p>主要的规则如下：</p><p>当我们在组件或者在指令当中当中请求依赖，会使用 <code>Merge Injector</code> 去遍历元素注入器树，然后如果找不到依赖，就会切换到模块注入器树来解析依赖。</p><blockquote><p>Please note I don’t use phrase “component injector” but rather “element injector”.</p></blockquote><h3 id="什么是-Merge-Injector"><a href="#什么是-Merge-Injector" class="headerlink" title="什么是 Merge Injector"></a>什么是 Merge Injector</h3><p>你们曾经是否写过这种代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;[someDir]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeDirective</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> injector: Injector</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在这里的 <code>injector</code> 就是一个 <code>Merge Injector</code> (相应的，我们同样也可以将 Merge Injector 在组件的构造函数中注入)。</p><p><code>Merge Injector</code> 本身没有任何值，它只是视图和元素定义的组合，它有以下定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Injector_</span> <span class="title">implements</span> <span class="title">Injector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> view: ViewData, <span class="keyword">private</span> elDef: NodeDef|<span class="literal">null</span></span>)</span> &#123;&#125;</span><br><span class="line">  get(token: <span class="built_in">any</span>, <span class="attr">notFoundValue</span>: <span class="built_in">any</span> = Injector.THROW_IF_NOT_FOUND): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> allowPrivateServices =</span><br><span class="line">        <span class="built_in">this</span>.elDef ? (<span class="built_in">this</span>.elDef.flags &amp; NodeFlags.ComponentView) !== <span class="number">0</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Services.resolveDep(</span><br><span class="line">        <span class="built_in">this</span>.view, <span class="built_in">this</span>.elDef, allowPrivateServices,</span><br><span class="line">        &#123;<span class="attr">flags</span>: DepFlags.None, token, <span class="attr">tokenKey</span>: tokenKey(token)&#125;, notFoundValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们所看到的，<code>Merge Injector</code> 只是视图和元素定义的组合。当 Angular 解决依赖关系时，这个注入器就像是元素注入器树和模块注入器树之间的桥梁。</p><p><code>Merge Injector</code> 同样也可以解析一些内置的依赖，类似于 <code>ElementRef</code>，<code>ViewContainerRef</code>，<code>TemplateRef</code>，<code>ChangeDetectorRef</code> 这些，更有趣的是，他还可以返回 <code>Merge Injector</code></p><p><strong>基本上，每个元素都有一个 <code>merge injector</code> 即使你没有提供任何的 <code>Token</code></strong></p><h3 id="什么是-Element-Injector"><a href="#什么是-Element-Injector" class="headerlink" title="什么是 Element Injector"></a>什么是 Element Injector</h3><p>在 Angular 中，视图是模板的表示形式，它包含不同类型的节点，其中便有元素节点，元素注入器位于此节点上。</p><p>默认情况下 <code>ElementInjector</code> 为空，除非在 <code>@Directive( )</code> 或 <code>@Component( )</code> 的 <code>providers</code> 属性中进行配置。</p><p>当 Angular 为嵌套的 <a href="http://www.fly63.com/tag/html">html</a> 元素创建元素注入器时，要么从父元素注入器继承它，要么直接将父元素注入器分配给子节点定义。</p><p>如果子 <a href="http://www.fly63.com/tag/html">html</a> 元素上的元素注入器具有提供者，则应该继承该注入器。否则，无需为子组件创建单独的注入器，并且如果需要，可以直接从父级的注入器中解决依赖项。</p><p>我们都知道，Angular 通过传递视图定义创建工厂函数来解析模板。视图包含很多不同类型的节点，比如说：<code>deiective</code>，<code>text</code>，<code>provider</code>，<code>query</code> 等等，其中 <code>Element Node</code> 就是代表着 <code>DOM</code> 结构，实际上，<code>Element Injector</code> 就是驻留在这个 <code>Element Node</code> 上。Angular 保留了这个节点上关于 <code>Provider</code> 的信息在这两个属性上：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ElementDef &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * visible public providers for DI in the view,</span></span><br><span class="line"><span class="comment">   * as see from this element. This does not include private providers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">publicProviders</span>: &#123;[tokenKey: <span class="built_in">string</span>]: NodeDef&#125;|<span class="literal">null</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * same as visiblePublicProviders, but also includes private providers</span></span><br><span class="line"><span class="comment">   * that are located on this element.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  allProviders: &#123;[tokenKey: <span class="built_in">string</span>]: NodeDef&#125;|<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Element Injector</code> 解析依赖的过程：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> providerDef =</span><br><span class="line">  (allowPrivateServices ? elDef.element!.allProviders :</span><br><span class="line">    elDef.element!.publicProviders)![tokenKey];</span><br><span class="line"><span class="keyword">if</span> (providerDef) &#123;</span><br><span class="line">  <span class="keyword">let</span> providerData = asProviderData(searchView, providerDef.nodeIndex);</span><br><span class="line">  <span class="keyword">if</span> (!providerData) &#123;</span><br><span class="line">    providerData = &#123; <span class="attr">instance</span>: _createProviderInstance(searchView, providerDef) &#125;;</span><br><span class="line">    searchView.nodes[providerDef.nodeIndex] = providerData <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> providerData.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注入器包含组件 / 指令的实例，还有就是所有在组件 / 指令当中登记了的 <code>Provider</code>。</p><p>这些 <code>Providers</code> 的填充是在视图的实例化阶段，主要是由 Angular 的编译器中的 <a href="https://github.com/angular/angular/blob/master/packages/compiler/src/provider_analyzer.ts#L47">ProviderElementContext</a> 处理的，如果我们深入到这个类会发现许多有趣的事。</p><p>比如说，当使用 <code>@Host</code> 装饰器时会有一些 **<a href="https://github.com/angular/angular/blob/master/packages/compiler/src/provider_analyzer.ts#L290-L298">限制</a>**，可以使用宿主元素的 <strong><code>viewProviders</code></strong> 属性来解决这些限制，可以查看 <a href="https://medium.com/@a.yurich.zuev/angular-nested-template-driven-form-4a3de2042475">https://medium.com/@a.yurich.zuev/angular-nested-template-driven-form-4a3de2042475</a> 。</p><p>另外的一个例子是，如果我们在组件上挂载指令，然后我们在组件和在指令上都拥有一个一样的 <code>token</code>，这个时候指令上的依赖会胜出。</p><h3 id="依赖算法-Resolution-Algorithm"><a href="#依赖算法-Resolution-Algorithm" class="headerlink" title="依赖算法 (Resolution Algorithm)"></a>依赖算法 (Resolution Algorithm)</h3><p>要想明白依赖解析算法如何工作，我们需要对视图和视图父元素这个概念熟悉。</p><p>如果我们有一个根组件 <code>AppComponent</code>，他的模板为 <code>&lt;child&gt;&lt;/child&gt;</code>，然后我们有三个视图，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HostView_AppComponent</span><br><span class="line">    <span class="tag">&lt;<span class="name">my-app</span>&gt;</span><span class="tag">&lt;/<span class="name">my-app</span>&gt;</span></span><br><span class="line">View_AppComponent</span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">View_ChildComponent</span><br><span class="line">    some content</span><br></pre></td></tr></table></figure><p>依赖解析算法会根据视图层级进行展开：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/HIC19t.jpg" alt="alt"></p><blockquote><ul><li>首先查看子元素注入器，进行检查 <code>elRef.element.allProvider|publicProviders</code>。</li><li>然后遍历所有视图父元素 ①，并检查元素注入器中的提供者。</li><li>如果下一个视图父元素等于 <code>null</code> ②，则返回 <code>startView</code> ③，检查 <code>startView.rootData.elInjector</code> ④。</li><li>只有在找不到令牌的情况下，才检查 <code>startView.rootData.module.injector</code> ⑤。</li></ul></blockquote><p>如果我们在子组件中查找依赖，首先他会查看 <code>childComponent</code> 的 <code>Injector</code>，也就是查看 <code>elRef.element.allProviders|publicProviders</code>，然后会遍历所有的父视图查看 <code>Element Injector</code> 中的 <code>Provider</code>。直到视图父元素的值为 <code>null</code>。然后就会返回 <code>startView</code>，检查 <code>startView.rootData.eInjector</code> 如果最终 <code>token</code> 对应的依赖找不到，那么就会查看 <code>startView.rootData.module.injector</code>。</p><p>当向上遍历组件视图来解析依赖时，会搜索 <strong>视图的父元素，而不是元素的父元素</strong>。Angular 会使用 <code>viewParentEI( )</code> 函数获取视图父元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for component views, this is the host element.</span></span><br><span class="line"><span class="comment"> * for embedded views, this is the index of the parent node</span></span><br><span class="line"><span class="comment"> * that contains the view container.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">viewParentEl</span>(<span class="params">view: ViewData</span>): <span class="title">NodeDef</span>|<span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parentView = view.parent;</span><br><span class="line">  <span class="keyword">if</span> (parentView) &#123;</span><br><span class="line">    <span class="keyword">return</span> view.parentNodeDef !.parent;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找依赖详细代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveDep</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    view: ViewData, elDef: NodeDef, allowPrivateServices: <span class="built_in">boolean</span>, depDef: DepDef,</span></span></span><br><span class="line"><span class="params"><span class="function">    notFoundValue: <span class="built_in">any</span> = Injector.THROW_IF_NOT_FOUND</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖注入被 @Value 装饰器修饰</span></span><br><span class="line">  <span class="keyword">if</span> (depDef.flags &amp; DepFlags.Value) &#123;</span><br><span class="line">    <span class="keyword">return</span> depDef.token;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> startView = view;</span><br><span class="line">  <span class="comment">// 依赖注入被 @Optional 修饰</span></span><br><span class="line">  <span class="keyword">if</span> (depDef.flags &amp; DepFlags.Optional) &#123;</span><br><span class="line">    notFoundValue = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取依赖的 token</span></span><br><span class="line">  <span class="keyword">const</span> tokenKey = depDef.tokenKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依赖 token 为 ChangeDetectorRef</span></span><br><span class="line">  <span class="keyword">if</span> (tokenKey === ChangeDetectorRefTokenKey) &#123;</span><br><span class="line">    <span class="comment">// directives on the same element as a component should be able to control the change detector</span></span><br><span class="line">    <span class="comment">// of that component as well.</span></span><br><span class="line">    allowPrivateServices = !!(elDef &amp;&amp; elDef.element !.componentView);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依赖被 @SkipSelf 修饰</span></span><br><span class="line">  <span class="keyword">if</span> (elDef &amp;&amp; (depDef.flags &amp; DepFlags.SkipSelf)) &#123;</span><br><span class="line">    allowPrivateServices = <span class="literal">false</span>;</span><br><span class="line">    elDef = elDef.parent !;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前视图对象 view 赋值给 searchView</span></span><br><span class="line">  <span class="keyword">let</span> searchView: ViewData|<span class="literal">null</span> = view;</span><br><span class="line">  <span class="comment">// searchView 不为空就一直执行下去，除非提前返回</span></span><br><span class="line">  <span class="keyword">while</span> (searchView) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elDef) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (tokenKey) &#123;</span><br><span class="line">        <span class="comment">// token 为 Renderer</span></span><br><span class="line">        <span class="keyword">case</span> RendererV1TokenKey: &#123;</span><br><span class="line">          <span class="keyword">const</span> compView = findCompView(searchView, elDef, allowPrivateServices);</span><br><span class="line">          <span class="keyword">return</span> createRendererV1(compView);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// token 为 Renderer2</span></span><br><span class="line">        <span class="keyword">case</span> Renderer2TokenKey: &#123;</span><br><span class="line">          <span class="keyword">const</span> compView = findCompView(searchView, elDef, allowPrivateServices);</span><br><span class="line">          <span class="keyword">return</span> compView.renderer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// token 为 ElementRef  </span></span><br><span class="line">        <span class="keyword">case</span> ElementRefTokenKey:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);</span><br><span class="line">        <span class="comment">// token 为 ViewContainerRef</span></span><br><span class="line">        <span class="keyword">case</span> ViewContainerRefTokenKey:</span><br><span class="line">          <span class="keyword">return</span> asElementData(searchView, elDef.nodeIndex).viewContainer;</span><br><span class="line">        <span class="comment">// token 为 TemplateRef  </span></span><br><span class="line">        <span class="keyword">case</span> TemplateRefTokenKey: &#123;</span><br><span class="line">          <span class="keyword">if</span> (elDef.element !.template) &#123;</span><br><span class="line">            <span class="keyword">return</span> asElementData(searchView, elDef.nodeIndex).template;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// token 为 ChangeDetectorRef</span></span><br><span class="line">        <span class="keyword">case</span> ChangeDetectorRefTokenKey: &#123;</span><br><span class="line">          <span class="keyword">let</span> cdView = findCompView(searchView, elDef, allowPrivateServices);</span><br><span class="line">          <span class="keyword">return</span> createChangeDetectorRef(cdView);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// token 为 Injector</span></span><br><span class="line">        <span class="keyword">case</span> InjectorRefTokenKey:</span><br><span class="line">          <span class="keyword">return</span> createInjector(searchView, elDef);</span><br><span class="line">        <span class="comment">// token 为其他类型</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">const</span> providerDef =</span><br><span class="line">              (allowPrivateServices ? elDef.element !.allProviders :</span><br><span class="line">                                      elDef.element !.publicProviders) ![tokenKey];</span><br><span class="line">          <span class="keyword">if</span> (providerDef) &#123;</span><br><span class="line">            <span class="keyword">let</span> providerData = asProviderData(searchView, providerDef.nodeIndex);</span><br><span class="line">            <span class="keyword">if</span> (!providerData) &#123;</span><br><span class="line">              providerData = &#123;<span class="attr">instance</span>: _createProviderInstance(searchView, providerDef)&#125;;</span><br><span class="line">              searchView.nodes[providerDef.nodeIndex] = providerData <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> providerData.instance;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allowPrivateServices = isComponentView(searchView);</span><br><span class="line">    elDef = viewParentEl(searchView) !;</span><br><span class="line">    searchView = searchView.parent !;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depDef.flags &amp; DepFlags.Self) &#123;</span><br><span class="line">      searchView = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||</span><br><span class="line">      notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) &#123;</span><br><span class="line">    <span class="comment">// Return the value from the root element injector when</span></span><br><span class="line">    <span class="comment">// - it provides it</span></span><br><span class="line">    <span class="comment">//   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)</span></span><br><span class="line">    <span class="comment">// - the module injector should not be checked</span></span><br><span class="line">    <span class="comment">//   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> startView.root.ngModule.injector.get(depDef.token, notFoundValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>读取依赖注入前的装饰器，例如：<code>@Host</code>、<code>@Optional</code>、<code>@Self</code>、<code>@SkipSelf</code>。并且根据这些装饰器，对传进来的 <code>viewData</code> 和 <code>elDef</code> 进行配置</li><li>判断依赖注入 <code>token</code> 的类型，并且根据 <code>switch</code> 语句中的分类进行执行</li><li>若是走到了 <code>default</code> 分支，那么将这样进行查找依赖：<ul><li>先查看当前元素的元素注入器 (<code>elDef.allProviders|publicProviders</code>) 是否拥有给定 <code>token</code> 的依赖，若无执行下一步</li><li>将当前 <code>viewData.parent</code> 赋给新的 <code>viewData</code>，将当前 <code>viewData.parentDef.parent</code> 赋值给新的 <code>elDef</code>，然后进入下一个循环，也就是查看新的元素注入器 (<code>elDef.allProviders|publicProviders</code>) 中是否拥有给定依赖</li></ul></li><li>如果还是找不到对应的依赖，则直接去查找初始视图的根注入器 (<code>startView.root.injector.get(token)</code>)</li><li>若还是找不到对应依赖，则查找 (<code>startView.root.ngModule.injector.get(token)</code>)</li></ul></blockquote><p>比如说，假设有如下一段小程序：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;my-list&gt;&lt;/my-list&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-list&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;container&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;grid-list&gt;</span></span><br><span class="line"><span class="string">        &lt;grid-tile&gt;1&lt;/grid-tile&gt;</span></span><br><span class="line"><span class="string">        &lt;grid-tile&gt;2&lt;/grid-tile&gt;</span></span><br><span class="line"><span class="string">        &lt;grid-tile&gt;3&lt;/grid-tile&gt;</span></span><br><span class="line"><span class="string">      &lt;/grid-list&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListComponent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;grid-list&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;ng-content&gt;&lt;/ng-content&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">GridListComponent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;grid-tile&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`...`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">GridTileComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> gridList: GridListComponent</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 <code>grid-tile</code> 组件依赖 <code>GridListComponent</code>，我们可以成功拿到该组件对象。但是这是怎么做到的？</p><p><strong>这里的视图父元素到底是什么？</strong></p><p>下面的步骤回答了这个问题：</p><p>1、查找 <strong>起始元素</strong>。我们的 <code>GridTileComponent</code> 拥有 <code>grid-tile</code> 这个元素选择器，因此我们需要查找匹配 <code>grid-tile</code> 选择器的元素</p><p>2、查找 <strong>模板</strong>。查找 <code>grid-tile</code> 元素所属的模板 (<code>MyListComponent template</code>)。</p><p>3、确定该元素的视图，如果没有父嵌入视图，则为组件视图，否则为嵌入视图。<code>grid-tile</code> 元素之上没有任何的 <code>ng-template</code> 或者 <code>*structuralDirective</code>，所以这里是组件视图 <code>View_MyListComponent</code>。</p><p>4、查找视图的父元素。这里是视图的父元素，而不是元素的父元素。</p><p>这里有两种情况：</p><ul><li>对于嵌入视图，父元素则为包含该嵌入视图的视图容器，比如，假设 <code>grid-list</code> 上挂载有结构指令，则 <code>grid-tile</code> 视图的父元素则是 <code>div.container</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-list&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;container&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;grid-list *ngIf=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;grid-tile&gt;1&lt;/grid-tile&gt;</span></span><br><span class="line"><span class="string">        &lt;grid-tile&gt;2&lt;/grid-tile&gt;</span></span><br><span class="line"><span class="string">        &lt;grid-tile&gt;3&lt;/grid-tile&gt;</span></span><br><span class="line"><span class="string">      &lt;/grid-list&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>对于组件视图，父元素则为宿主元素</li></ul><p>我们上面的小程序也就是组件视图，所以视图父元素是 <code>my-list</code> 元素，而不是 <code>grid-list</code>。</p><p><strong>现在，你可能想知道如果 Angular 跳过 <code>grid-list</code>，则它是怎么解析 <code>GridListComponent</code> 依赖的？</strong></p><p>关键在于 Angular 使用 <strong><a href="https://github.com/angular/angular/blob/master/packages/core/src/view/view.ts#L87">原型链继承</a></strong> 来搜集 <code>Provider</code>：</p><blockquote><p>Each time we provide any token on an element, angular creates new <code>allProviders</code> and <code>publicProviders</code> array inherited from parent node, otherwise it just shares the same array with parent node.</p></blockquote><p>这就表示了 <code>grid-tile</code> 包含当前视图内所有父元素的所有 <code>Provider</code>。</p><p>下图说明了 Angular 是如何为模板内元素收集 <code>Provider</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/xnjleM.jpg" alt="alt"></p><p>正如我们所见，<code>grid-tile</code> 可以成功获取到 <code>GridListComponent</code> 从它自己的 Element Injector 中的 <code>allProviders</code> 属性，因为 <code>grid-tile</code> 的 Element Injector 包括了来自父元素的所有 Providers。</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/1_el4lEGLk_TSoZLUKlKK06Q.gif" alt="alt"></p><p>Element Injector 的 Provider 使用了原型链继承，导致了我们不能使用 multi 选项来提供同一个令牌多个服务，但是由于依赖注入系统很灵活，也有办法去解决这个可以，具体可以查看  <a href="https://stackoverflow.com/questions/49406615/is-there-a-way-how-to-use-angular-multi-providers-from-all-multiple-levels">答案</a></p><p>现在继续画注入树。</p><h3 id="Simple-my-app-gt-child-gt-grand-child-application"><a href="#Simple-my-app-gt-child-gt-grand-child-application" class="headerlink" title="Simple my-app -&gt; child -&gt; grand-child application"></a>Simple my-app -&gt; child -&gt; grand-child application</h3><p>假设有如下简单程序：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;child&gt;&lt;/child&gt;`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;grand-child&gt;&lt;/grand-child&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;grand-child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`grand-child`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChildComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> service: Service</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [BrowserModule],</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    AppComponent, </span><br><span class="line">    ChildComponent, </span><br><span class="line">    GrandChildComponent</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">bootstrap</span>: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>我们有三层结构，并且 GrandChildComponent 依赖于 Service：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">   child</span><br><span class="line">      grand-child(ask <span class="keyword">for</span> Service dependency)</span><br></pre></td></tr></table></figure><p>下图解释了 Angular 内部是如何解析 Service 依赖的：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/3nKSe9.jpg" alt="alt"></p><p>上面从 View_Child ① 的 <code>&lt;grand-child&gt;</code> 开始，并向上遍历查找所有视图的父元素，当视图没有父元素时，本实例中 <code>&lt;my-app&gt;</code> 没有父元素，则使用根视图的注入器进行查找 ②</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);</span><br></pre></td></tr></table></figure><p>本实例中 <code>startView.root.injector</code> 就是 <code>NullInjector</code>，由于 <code>NullInjector</code> 没有任何 Provider，则 Angular 就会切换到模块注入器 ③：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startView.root.ngModule.injector.get(depDef.token, notFoundValue);</span><br></pre></td></tr></table></figure><p>所以 Angular 会按照以下顺序解析依赖：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AppModule Injector </span><br><span class="line"><span class="code">        ||</span></span><br><span class="line"><span class="code">        \/</span></span><br><span class="line"><span class="code">    ZoneInjector </span></span><br><span class="line"><span class="code">        ||</span></span><br><span class="line"><span class="code">        \/</span></span><br><span class="line"><span class="code">  Platform Injector </span></span><br><span class="line"><span class="code">        ||</span></span><br><span class="line"><span class="code">        \/</span></span><br><span class="line"><span class="code">    NullInjector </span></span><br><span class="line"><span class="code">        ||</span></span><br><span class="line"><span class="code">        \/</span></span><br><span class="line"><span class="code">       Error</span></span><br></pre></td></tr></table></figure><h2 id="路由程序"><a href="#路由程序" class="headerlink" title="路由程序"></a>路由程序</h2><p>让我们修改程序，添加路由器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;router-outlet&gt;&lt;/router-outlet&gt;`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot([</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;child&#x27;</span>, <span class="attr">component</span>: ChildComponent &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">redirectTo</span>: <span class="string">&#x27;/child&#x27;</span>, <span class="attr">pathMatch</span>: <span class="string">&#x27;full&#x27;</span> &#125;</span><br><span class="line">    ])</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    ChildComponent,</span><br><span class="line">    GrandChildComponent</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">bootstrap</span>: [ AppComponent ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>这样视图树就类似为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">   router-outlet</span><br><span class="line">   child</span><br><span class="line"><span class="code">      grand-child(dynamic creation)</span></span><br></pre></td></tr></table></figure><p>现在让我们看看路由是如何创建动态组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> injector = <span class="keyword">new</span> OutletInjector(activatedRoute, childContexts, <span class="built_in">this</span>.location.injector);                           </span><br><span class="line"><span class="built_in">this</span>.activated = <span class="built_in">this</span>.location.createComponent(factory, <span class="built_in">this</span>.location.length, injector);</span><br></pre></td></tr></table></figure><p>这里 Angular 使用新的 rootData 对象创建一个新的根视图，同时传入 OutletInjector 作为根元素注入器 elInjector。OutletInjector 又依赖于父注入器 this.location.injector，该父注入器是 router-outlet 的元素注入器。</p><p>OutletInjector 是一种特别的注入器，行为有些向路由组件和父元素 router-outlet 之间的桥梁，该对象的代码可以看 **<a href="https://github.com/angular/angular/blob/master/packages/router/src/directives/router_outlet.ts#L144">这里</a>**：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/Du0CuC.jpg" alt="alt"></p><h2 id="延迟加载程序"><a href="#延迟加载程序" class="headerlink" title="延迟加载程序"></a>延迟加载程序</h2><p>最后，让我们把 GrandChildComponent 移到延迟加载模块，为此需要再子组件中添加 router-outlet，并修改路由配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    Child</span></span><br><span class="line"><span class="string">    &lt;router-outlet&gt;&lt;/router-outlet&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> </span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;child&#x27;</span>, <span class="attr">component</span>: ChildComponent,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; </span><br><span class="line">             <span class="attr">path</span>: <span class="string">&#x27;grand-child&#x27;</span>, </span><br><span class="line">             <span class="attr">loadChildren</span>: <span class="string">&#x27;./grand-child/grand-child.module#GrandChildModule&#x27;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">redirectTo</span>: <span class="string">&#x27;/child&#x27;</span>, <span class="attr">pathMatch</span>: <span class="string">&#x27;full&#x27;</span> &#125;</span><br><span class="line">    ])</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    ChildComponent</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">bootstrap</span>: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">   router-outlet</span><br><span class="line">   child (dynamic creation)</span><br><span class="line">       router-outlet</span><br><span class="line">         +grand-child(lazy loading)</span><br></pre></td></tr></table></figure><p>让我们为延迟加载程序画两棵独立的树：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/FE4nMJ.jpg" alt="alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解 Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS：Flex 布局</title>
      <link href="/2021/07/09/CSS%EF%BC%9AFlex%20%E5%B8%83%E5%B1%80/"/>
      <url>/2021/07/09/CSS%EF%BC%9AFlex%20%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS：Flex-布局"><a href="#CSS：Flex-布局" class="headerlink" title="CSS：Flex 布局"></a>CSS：Flex 布局</h1><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>盒模型由 <code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code> 组成</p><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><ul><li><p>margin 可以让块状元素居中显示，注意是块状元素。实现方式是：<code>margin: 10px, auto</code></p></li><li><p>设置 margin 可能会导致上下的两个元素出现外间距合并的情况，类似的上边的 div (块级元素) 设置了 margin 为 100px，然后下边的 div 设置了 50px，那么就会导致这两个元素间的间距并不是 150px，而是变成了 100px，这个就是外间距合并，这种的解决方式就是在这两个 div 的外边的父元素触发成一个 BFC。这样就可以解决了。</p></li><li><p>行内元素实际上不占上下外边距。行内元素的左右外边距不合并</p></li><li><p>浮动元素的外边距也不会合并</p></li><li><p>允许指定负的外边距，不过使用的时候要小心</p></li></ul><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>padding 的宽高要是记录在盒子模型的宽高之内，与此同时的是 border 也要记录在盒子模型的宽高之内，但是 margin 并不算在宽高之内。所以各位在书写宽高时注意减掉内边距和边框。box-sizing 属性有两个值，一个是 content-box (标准)，此时 padding 和 border 不被包含在 width 和 height 内，元素的实际大小为宽高 + border + padding，此为标准模式下的盒模型。border-boxing (怪异) padding 和 border 被包含在定义的 width 和 height 中。元素实际的大小为你定义了多宽就是多宽。此属性为怪异模式下的盒模型。</p><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Flex是“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用Flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: inline-flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为Flex布局后，子元素的float、clear和vertical-align属性将失效。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用了 Flex 布局的元素，称为 Flex 容器，简称“容器”。它的所有子元素自动称为容器成员，称为 Flex 项目，简称“项目”</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/4COzFw.jpg" alt="alt"></p><p>容器默认存在两根轴：水平方向的主轴 (main axis) 和垂直方向的交叉轴 (cross axis)。主轴的开始位置 (与边框的交叉点) 叫 main start，结束位置叫做 main end；交叉轴的开始位置叫做 (cross end)。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 (main size)，占据的交叉轴空间叫做 (cross size)。</p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><p>以下 6 个属性设置在容器上</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>flex-direction 属性决定主轴的方向 (即项目的排列方向)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/7t8Gu5.jpg" alt="alt"></p><p>它的取值有 4 种可能：</p><ul><li>row (默认值)：主轴为水平方向，起点在左端</li><li>row-reverse：主轴为水平方向，起点在右边</li><li>column：主轴为垂直方向，起点在上方</li><li>column-reverse：主轴为垂直方向，起点在下方</li></ul><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>默认情况下，项目都排在一条线 (又称“轴线”) 上。flex-wrap属性定义，如果一条轴线排不下，如何换行</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/2FW5XI.jpg" alt="alt"></p><p>它的取值有三种可能：</p><ul><li>norwrap (默认值)：不换行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/6d2FWW.jpg" alt="alt"></p><ul><li>wrap：换行，第一行在上方</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/JA3nNx.jpg" alt="alt"></p><ul><li>wrap-reverse：换行，第一行在下方</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/hOo7m9.jpg" alt="alt"></p><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row norwrap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content 属性定义了项目在主轴的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/NFWbgj.jpg" alt="alt"></p><p>它的取值有 5 种可能，具体对齐方式跟轴的方向有关，下面假设主轴为从左到右</p><ul><li>flex-start (默认值)：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目之间的间隔相等</li><li>space-around：每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items 属性定义项目在交叉轴上如何对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/rttbFb.jpg" alt="alt"></p><p>它的取值有 5 种可能：</p><ul><li>flex-start：交叉轴起点对齐</li><li>flex-end：交叉轴终点对齐</li><li>center：交叉轴中点对齐</li><li>baseline：项目的第一项文字的基线</li><li>stretch (默认值)：如果项目未设置高度或设为 auto，将占满整个容器的高度</li></ul><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>align-content 属性定义了多根轴线的对齐方式。如果项目只有一个轴线，该属性不起作用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">align-content</span>: flex-start | flex-end | center | space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/W8DGmG.jpg" alt="alt"></p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分配</li><li>space-around：每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框间隔大一倍</li><li>stretch（默认值）：轴线占满整个交叉轴</li></ul><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><p>以下 6 个属性设置在项目上</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex</li><li>align-self</li></ul><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/iTaKZ4.jpg" alt="alt"></p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的 flex-grow 属性都为 1，则他们将等分剩余空间 (如果有的话)，如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不够，该项目会缩小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/sn1tSc.jpg" alt="alt"></p><p>如果所有项目 flex-shrink 属性为 1，那么当空间不够的时候，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间 (main size)。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟 width 或 height 属性一样的值，比如 350px，则项目将占据固定空间。</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex 属性是 flex-grow、flex-shrink、flex-basis 的简写，默认值为 0、1、auto。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷键：auto(1 1 auto) 和 auto(0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写是哪个分离的属性，因为浏览器会推算相关值。</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items，如果没有父元素，则等同 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline |</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/KeVUWJ.jpg" alt="alt"></p><p>该属性可能取值为 6 个，除了 auto，其他都与 align-items 属性完全一致。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS：定位</title>
      <link href="/2021/07/09/CSS%EF%BC%9A%E5%AE%9A%E4%BD%8D/"/>
      <url>/2021/07/09/CSS%EF%BC%9A%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS：定位"><a href="#CSS：定位" class="headerlink" title="CSS：定位"></a>CSS：定位</h1><h2 id="浮动定位"><a href="#浮动定位" class="headerlink" title="浮动定位"></a>浮动定位</h2><h3 id="浮动属性"><a href="#浮动属性" class="headerlink" title="浮动属性"></a>浮动属性</h3><ul><li>将元素排除在普通流之外</li><li>元素将不在页面中占据位置</li><li>将浮动元素放在包含框的左边或右边</li><li>浮动元素依旧位于包含框内</li><li>浮动的框可以向左或者向右移动，直到他的边缘碰到父元素边框或者另一个浮动框的边框为止</li><li>浮动元素的外边缘不会超过其父元素的内边缘</li><li>浮动元素不会互相重叠</li><li>浮动元素不会上下浮动</li><li>任何元素一旦浮动，display 属性将完全失效均可以设置宽高，并且不会独占一行</li><li>语法：float: none / left / right</li><li>div 作为父元素没有设置宽高属性的话，那么 div 的高度是由其子元素的高度撑开的。如果其子元素全部设置为浮动了，那么会导致父元素的高度坍塌。</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>结尾处加空 div 标签 clear: both (或在下一个元素上加 clear: both)</li><li>浮动元素的父级 div 定义 overflow: hidden，设置了 overflow: hidden 之后相当于触发了 BFC 容器</li><li>浮动元素的父元素定宽高</li></ul><h2 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h2><h3 id="Position-定位"><a href="#Position-定位" class="headerlink" title="Position 定位"></a>Position 定位</h3><ul><li><p>absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位，元素的位置通过 left、top、right、bottom 进行规定，***<u>绝对定位的元素不会占据原有的物理位置</u>***，以其他元素作为参照物移动指定距离的定位方式。</p><ul><li>如果元素的外层元素是***<u>非 static</u>*** (有了除默认值之外的定位设置) 那么这个外层元素就成为该元素的定位参考点。</li><li>如果元素的外层元素没有设置任何的 position 值，那么该元素将寻找距离自己最近的其他设置过 position 的外层元素作为参照物 (必须为嵌套层)。</li><li>如果该元素的外层元素没有一个元素采用 position 定位，那么此时定位参考元素就变为 body 或者页面</li></ul></li><li><p>fixed：生成固定定位的元素，相对于浏览器窗口进行定位。元素也是通过 left、top、right、bottom 进行定位。</p></li><li><p>relative：生成相对定位的元素，相对于其正常位置进行定位，因此，left: 20 会向元素的 left 位置添加 20 像素，以当前参照物移动指定的距离，被定位的元素会占据原有的物理位置。</p></li><li><p>static：默认值，没有定位，元素出现在正常的流中 (忽略 top、bottom、left、right 或者 z-Index 声明)。</p></li><li><p>z-Index 属性只支持定位元素</p></li></ul><h2 id="Display-属性"><a href="#Display-属性" class="headerlink" title="Display 属性"></a>Display 属性</h2><p>每一个网页元素都有一个 display 属性，用于确认该元素的类型，每一个元素都有默认的 display 属性值，比如 div 元素，它的默认 display 属性值为 block，称为块元素，而 span 元素的默认 display 属性值为 inline，称为行内元素。块元素和行内元素可以转换。</p><h3 id="常见属性值"><a href="#常见属性值" class="headerlink" title="常见属性值"></a>常见属性值</h3><ul><li>none：隐藏对象，这里隐藏了对象之后，会导致对象不占据原有的位置</li><li>inline：指定对象为内联对象 (即行内对象)，特点是没有宽高属性，不会独占一行</li><li>block：指定对象为块元素，特点是具有宽高属性，并且独占一行</li><li>inline-block：指定对象为内联块对象，特点是具有宽高，并且不会独占一行</li><li>table-cell：指定对象为表格单元格</li><li>flex：弹性盒</li></ul><p>注意：visibility: hidden 和 opacity: 0 会将元素隐藏，但是物理空间实际还存在；display: none 隐藏元素，不保留物理空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS：选择器</title>
      <link href="/2021/07/09/CSS%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2021/07/09/CSS%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS：选择器"><a href="#CSS：选择器" class="headerlink" title="CSS：选择器"></a>CSS：选择器</h1><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><p>1、标签选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、类选择器 class</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.active</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Id 选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><em><strong>总结：Id 选择器 &gt; class 选择 &gt; 标签选择器</strong></em></u></p><h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><p>1、后代选择器：body 中的所有子孙 p 标签都被设置为红色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、子选择器：body 中的子 p 标签才被设置为红色，孙 p 标签不被设置为红色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、相邻兄弟选择器：只使用类别为 active 并且是他下边一个相邻的 p 标签才被设置为红色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.active</span> + <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、通用选择器：通用兄弟选择器，当前选中元素的向下的所有兄弟元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.active</span> ~ <span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>li1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>li2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>li3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择ul中的子孙li元素，选中最后一个li*/</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择ul中的子孙li元素，选中第一个li*/</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择当前p标签的父标签，选中父级元素的第一个，并且是当前元素才生效*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定位到当前元素的父元素，并且将父元素中为p标签类型第二个设置为黄色*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>HTML 内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item first&quot;</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item active&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;test&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/a.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/abc.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abcd.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item last&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*存在id属性的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[id]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中id为first的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[id=first]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中class中含有links的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class*=<span class="string">&quot;links&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中href属性中以http开头的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=http]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中href属性中以pdf结尾的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=pdf]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=：绝对等于</p><p>*=：包含这个元素</p><p>^=：以这个开头</p><p>$=：以这个结尾</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Cold vs Hot Observables</title>
      <link href="/2021/07/09/RxJS%EF%BC%9ACold%20vs%20Hot%20Observables/"/>
      <url>/2021/07/09/RxJS%EF%BC%9ACold%20vs%20Hot%20Observables/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Cold-vs-Hot-Observables"><a href="#RxJS：Cold-vs-Hot-Observables" class="headerlink" title="RxJS：Cold vs Hot Observables"></a>RxJS：Cold vs Hot Observables</h1><p>RxJS 中 Observables 分为两种：Cold Observables 和 Hot Observables，这两个的区别：</p><ul><li>Cold Observables：只有被 observers 订阅的时候，才会开始产生值。是单播的，有多少个订阅就会生成多少个订阅实例，每个订阅都是从第一个产生的值开始接受值，所以每个订阅收到的值都是一样的。</li><li>Hot Observables：不管有没有被订阅都会产生值。是多播的，多个订阅共享同一个，是从订阅开始接受到值，每个订阅接收到的值是不同的，取决于它们是从什么时候开始订阅的。</li></ul><h2 id="Cold-Observables"><a href="#Cold-Observables" class="headerlink" title="Cold Observables"></a>Cold Observables</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = <span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2nd subscriber:&quot;</span> + data) &#125;);</span><br></pre></td></tr></table></figure><p>把一个数组转换成 Observables，然后分别用不同的 Subcription 订阅它，在 console.log 结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2nd subscriber:<span class="number">1</span></span><br><span class="line">2nd subscriber:<span class="number">2</span></span><br><span class="line">2nd subscriber:<span class="number">3</span></span><br><span class="line">2nd subscriber:<span class="number">4</span></span><br><span class="line">2nd subscriber:<span class="number">5</span></span><br></pre></td></tr></table></figure><p>我们把代码改一下，让第二个 Subscription 延迟一秒订阅：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = <span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2nd subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">&#125;, <span class="number">1100</span>);</span><br></pre></td></tr></table></figure><p>结果还是跟上面一样，没有任何区别。这个是 Cold Observables，代码如下，先忽略 publish，ConnectableObservable，connect，稍后再详细解释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = <span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).pipe(</span><br><span class="line">    publish()</span><br><span class="line">) <span class="keyword">as</span> ConnectableObservable&lt;any&gt;;</span><br><span class="line">obs$.connect();</span><br><span class="line"></span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">&#125;, <span class="number">2100</span>);</span><br></pre></td></tr></table></figure><p>根据 Hot Observables 的定义，期待的效果是第一个订阅收到 1，2，3，4，5；第二个订阅收到 3，4，5。实际上两个订阅都没有接收任何值。因为 Hot Observables 是不管有没有被订阅，都会发送值，数组中有 5 个值，等到开始订阅的时候，这 5 个值已经发送完成了，所以在订阅中接收不到任何值了。</p><p>为了看到效果，把数组替换成了 interval，每隔一秒钟就发送一个值，第一个订阅等了一秒开始接受值，第二订阅等了两秒开始接收值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    publish()</span><br><span class="line">) <span class="keyword">as</span> ConnectableObservable&lt;any&gt;;</span><br><span class="line">obs$.connect();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    &#125;, <span class="number">1100</span>);</span><br><span class="line">&#125;, <span class="number">2100</span>);</span><br></pre></td></tr></table></figure><p>效果是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">2st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">2st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line">1st subscriber:<span class="number">6</span></span><br><span class="line">2st subscriber:<span class="number">6</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="Cold-Observables-vs-Hot-Observables"><a href="#Cold-Observables-vs-Hot-Observables" class="headerlink" title="Cold Observables vs Hot Observables"></a>Cold Observables vs Hot Observables</h2><ul><li>我们可以把 Cold Observables 理解为在手机网易云音乐 APP 上听歌：APP 里的歌曲资源是 Cold Observables，听歌的人是 observers。如果没有人打开 APP 去播放这首歌，这首歌不会自己播放。每个人从自己 APP 打开播放这首歌的时候，先把歌曲从网上下载到本地，每份都是单独的歌曲实例，都是从头开始听，互相不会影响。</li><li>而 Hot Observables 可以理解为演唱会：比如我们去看一场演唱会，没有迟到的小伙伴（A）可以从第一首歌开始听，迟到的小伙伴就（B）只能从第二首或者更晚的歌开始听；演唱会就是 Hot Observables，小伙伴 A 和 B 就是 observers。小伙伴 A 和 B 共享同一个演唱会实例，是从订阅开始接受到值，每个订阅接收到的值是不同的，取决于它们是从什么时候开始订阅。</li></ul><h2 id="如何创建-Hot-Observables"><a href="#如何创建-Hot-Observables" class="headerlink" title="如何创建 Hot Observables"></a>如何创建 Hot Observables</h2><p>在上方的 Hot Observables 代码里，用到了 publish 操作符，ConnectableObservable，以及 connect( ) 方法创建 Hot Observables；看一下对应的方法是什么意思。</p><ul><li>publish：这个操作符把正常的 Observable (Cold Observables) 转换成 ConnectableObservable。</li><li>ConnectableObservable：ConnectableObservable 是多播的共享 Observable，可以同时被多个 observers 共享订阅，是 Hot Observables。ConnectableObservable 是订阅者和真正源头 Observables (上面例子中的 interval，每隔一秒发送一个值，就是源头 Observable) 的中间人。ConnectableObservable 从源头 Observables 接收到值然后再把值转发给订阅者。</li><li>connect( )：ConnectableObservable 并不会主动发送值，它有个 connect 方法，通过调用 connect 方法，可以启动共享 ConnectableObservable 发送值。当我们调用 ConnectableObservable.prototype.connect 方法，不管有没有被订阅，都会发送值。订阅者共享同一个实例，订阅者接收到的值取决于它们何时开始订阅。在我们的例子中，第一个订阅等了一秒从 2 开始接收值，第二个订阅等了两秒从 3 开始接收值。</li></ul><h2 id="connect-vs-refCount"><a href="#connect-vs-refCount" class="headerlink" title="connect vs refCount"></a>connect vs refCount</h2><p>除了 connect，还有一个 refCount 方法，在比较这两个区别之前，我们先看一下 refCount 的用法和效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    publish(),</span><br><span class="line">    refCount()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">1100</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>按之前对 publish 会生成一个 ConnectableObservable，它是一个 Hot Observables，那么预期结果是：第一个订阅者是从 2 开始接收值，第二个订阅者是从 3 开始接收值。</p><p>实际的输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1st subscriber:<span class="number">0</span></span><br><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">2st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">2st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">2st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">2st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line"></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>跟预想的不一样，第一个订阅者从 0 开始接收值，第二个订阅者比第一个订阅者晚了一秒，从 1 开始接收值。</p><p>当使用 refCount，是引用计数的 Observable。它表示当第一个订阅者开始订阅的时候，开始发送和产生值；第二个订阅者 (之后的订阅者) 共享第一个订阅者的 Observables 实例，没有订阅者的时候，会自动取消订阅；之后再重新订阅，又从头开始发送值。</p><p>它不是 Hot Observables 也不是 Cold Observables，因为它是从有第一个订阅者的时候才开始发送值，没有订阅者的时候会自动取消订阅，而且之后的订阅者共享第一个订阅者的 Observables 实例。它是基于 Hot Observables 与 Cold Observables 之间的 Observables，可以理解为 Warm Observables。</p><h2 id="share"><a href="#share" class="headerlink" title="share"></a>share</h2><p>publish 和 refCount 可以生成一个 Warm Observables，实际单独使用 share 操作符也可以达到同样的效果，share 实际上是 publish( ).refCount( ) 的简写，这次把第二个订阅比第一个订阅晚 5 秒再开始订阅，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    share()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">5100</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1st subscriber:<span class="number">0</span></span><br><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line">1st subscriber:<span class="number">6</span></span><br><span class="line">2st subscriber:<span class="number">6</span></span><br><span class="line">1st subscriber:<span class="number">7</span></span><br><span class="line">2st subscriber:<span class="number">7</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>和使用 publish( ).refCount( ) 效果完全一样。</p><h2 id="shareReplay"><a href="#shareReplay" class="headerlink" title="shareReplay"></a>shareReplay</h2><p>在用 share( ) 的时候，第二个或者更后面的订阅者开始订阅者，都是共享第一个订阅者的 Observables，比如上面的例子中，第二个订阅比第一个订阅晚 5 秒再开始订阅，那么第二个订阅者从 5 开始接收值。但是实际情况中，如果我想让第二个订阅者也能够拿得到前面的值，那怎么办？用 shareReplay( ) 可以实现。具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    shareReplay(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">5100</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1st subscriber:<span class="number">0</span></span><br><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">2st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line">1st subscriber:<span class="number">6</span></span><br><span class="line">2st subscriber:<span class="number">6</span></span><br><span class="line">1st subscriber:<span class="number">7</span></span><br><span class="line">2st subscriber:<span class="number">7</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>shareReplay(1) 中的 1 表示拿到错过的前一个值，在我们的例子就是第二个订阅从 4 开始接收值。如果改成 shareReplay (2) 就表示从错过的前两个值开始接收值，也就是第二个订阅会从 3 开始接收值。</p><p>shareReplay(1) 其实也是 publishReplay(1).refCount( ) 的缩写，用 publishReplay(1).refCount( ) 有同样的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：通过 RxJS 实现简单的消息通知机制</title>
      <link href="/2021/07/09/RxJS%EF%BC%9A%E9%80%9A%E8%BF%87%20RxJS%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/07/09/RxJS%EF%BC%9A%E9%80%9A%E8%BF%87%20RxJS%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：通过-RxJS-实现简单的消息通知机制"><a href="#RxJS：通过-RxJS-实现简单的消息通知机制" class="headerlink" title="RxJS：通过 RxJS 实现简单的消息通知机制"></a>RxJS：通过 RxJS 实现简单的消息通知机制</h1><p>在实际开发中，还有一种 API 返回的值随着时间会有变化，这个时候去更新 RxJS 缓存里的值，从用户体验的角度出发，先在页面显示一个消息通知用户数据有更新，让用户选择是否需要更新页面内容，而不是直接在每次缓存更新之后直接刷新页面数据。下面介绍如何基于 RxJS 实现简单的消息通知机制。</p><ul><li>本文用到的 RxJS 缓存指 Angular 2+ 中结合 <code>HttpClient</code> 和 <code>ReplaySubject</code> 缓存 API Response 数据，后续新的订阅者都可以直接从 <code>ReplaySubject</code> 拿 API Response 数据。</li></ul><h2 id="更新-RxJS-缓存"><a href="#更新-RxJS-缓存" class="headerlink" title="更新 RxJS 缓存"></a>更新 RxJS 缓存</h2><p>这里直接每隔 10 秒调用一次 API，把新拿到的值赋值给 RxJS 缓存。</p><p>还是用 Github 的 get all users API：Github API，每 10 秒调用一次 API 拿到 30 个不同的 Github 用户信息。用 interval 可以实现每隔 10s 调用一次 API，但是会有一个问题，用户在第一次进到页面的时候需要等 10s 才能看到 30 位用户信息。我们希望用户第一次进到页面立马能看到 30 位用户信息，之后是每隔 10s 调用一次 API 更新 30 位 Git 用户信息，timer 操作符可以满足这个要求，timer(0, 10000) 表示首次不用等直接调用 API 拿到 30 位 Git 用户信息，之后每隔 10s 调用一次 API。Service 代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CACHE_SIZE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REFRESH_INTERVAL = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> API_ENDPOINT = <span class="string">&quot;https://api.github.com/users?since=&quot;</span>;</span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsNotificationService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> cacheUsers$: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line">    <span class="keyword">private</span> userStartId: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">users</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.cacheUsers$) &#123;</span><br><span class="line">            <span class="keyword">const</span> timer$ = timer(<span class="number">0</span>, REFRESH_INTERVAL);</span><br><span class="line">            <span class="built_in">this</span>.cacheUsers$ = timer$</span><br><span class="line">                .pipe(</span><br><span class="line">                    switchMap(<span class="function">() =&gt;</span> <span class="built_in">this</span>.requestUsers()),</span><br><span class="line">                    shareReplay(CACHE_SIZE)</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cacheUsers$;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">requestUsers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userStartId = <span class="built_in">this</span>.userStartId + <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;(API_ENDPOINT + <span class="built_in">this</span>.userStartId)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">respone</span> =&gt;</span> respone),</span><br><span class="line">                catchError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong &quot;</span> + error)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 RxjsNotificationComponent，具体代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">templateUrl</span>: <span class="string">&quot;./rxjs-notification.component.html&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsNotificationComponent</span> </span>&#123;</span><br><span class="line">    <span class="attr">users$</span>: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> rxjsNotificationService: RxjsNotificationService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users$ = <span class="built_in">this</span>.rxjsNotificationService.users.pipe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rxjs-notification.component.html 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:30px;width: 40%;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-md-center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin: 10px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;card w-100&quot;</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行代码发现，刚进页面会调用一次 API，之后每隔 10s 会去调用一次 API 更新 RxJS 缓存，页面的用户信息也是每隔 10s  就会更新。这个用户体验并不好，我们并不希望用户在浏览页面的时候，每隔 10s 页面里的信息就被自动更新，而是希望弹出一个消息通知用户有新的用户信息，让用户选择是否需要更新页面内容。</p><h2 id="基于-RxJS-的简单消息通知机制"><a href="#基于-RxJS-的简单消息通知机制" class="headerlink" title="基于 RxJS 的简单消息通知机制"></a>基于 RxJS 的简单消息通知机制</h2><p>我们先梳理一下消息通知的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/o9mGUr.jpg" alt="alt"></p><p>在我们的例子中，页面需要显示 30 位 Github 用户信息是数据消费者。</p><p>当用户进入到页面 (0s) 立马去调用 API 拿到 30 位 Github 用户信息放在 RxJS 缓存里并显示在页面上，之后每隔 10s 都会去调用一次 API 拿到全新的 30 位 Github 用户信息更新 RxJS 缓存里的数据，但不更新页面显示的数据，此时会在页面显示一个消息提醒用户有新数据更新，如果用户点击更新按钮，提醒消息会小时同时新拿到的用户信息会更新在页面上，如果不点击更新按钮，页面列出的 Github 用户信息不更新。</p><p>首先需要拿到第一次进入页面，也就是 0s 调用 API 拿到的 30 位 Github 用户信息，可以通过 take(1) 操作符拿到页面首次加载的 30 位 Github 用户信息。再定义 <code>updateClick$ = new Subject&lt;void&gt;();</code>用户每次点击更新按钮，会再去拿到最后一次 API 返回的用户信息，然后在通过 merge 操作符把两个 Observable 合并，具体代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">users$: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line">   updateClick$ = <span class="keyword">new</span> Subject&lt;<span class="built_in">void</span>&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> rxjsNotificationService: RxjsNotificationService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> initialUsers$ = <span class="built_in">this</span>.getUserOnce();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">const</span> updateUsers$ = <span class="built_in">this</span>.updateClick$.pipe(</span><br><span class="line">           mergeMap(<span class="function">() =&gt;</span> <span class="built_in">this</span>.getUserOnce())</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.users$ = merge(initialUsers$, updateUsers$);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">getUserOnce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.rxjsNotificationService.users.pipe(take(<span class="number">1</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>页面代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:30px;width: 40%;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-md-center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;alert alert-warning w-100&quot;</span> <span class="attr">role</span>=<span class="string">&quot;alert&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Warning!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> new user infor available, please click to update!</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 20px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-warning&quot;</span></span></span><br><span class="line"><span class="tag">                (<span class="attr">click</span>)=<span class="string">&quot;updateClick$.next()&quot;</span>&gt;</span>Update<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-md-center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin: 10px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;card w-100&quot;</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于显示和隐藏更新按钮，可以通过<code>mapTo</code>实现：</p><p>component 的完整代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable, Subject, merge &#125; <span class="keyword">from</span> <span class="string">&quot;rxjs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;./interface/rxjs-notification.interface&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; RxjsNotificationService &#125; <span class="keyword">from</span> <span class="string">&quot;./service/rxjs-notification.service&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; take, mergeMap, skip, mapTo &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">templateUrl</span>: <span class="string">&quot;./rxjs-notification.component.html&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsNotificationComponent</span> </span>&#123;</span><br><span class="line">    <span class="attr">users$</span>: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line">    updateClick$ = <span class="keyword">new</span> Subject&lt;<span class="built_in">void</span>&gt;();</span><br><span class="line">    showNotificatoin$: Observable&lt;<span class="built_in">boolean</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> rxjsNotificationService: RxjsNotificationService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> initialUsers$ = <span class="built_in">this</span>.getUserOnce();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> updateUsers$ = <span class="built_in">this</span>.updateClick$.pipe(</span><br><span class="line">            mergeMap(<span class="function">() =&gt;</span> <span class="built_in">this</span>.getUserOnce())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.users$ = merge(initialUsers$, updateUsers$);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> initNotification$ = <span class="built_in">this</span>.getNotifications();</span><br><span class="line">        <span class="keyword">const</span> show$ = initNotification$.pipe(mapTo(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">const</span> hide$ = <span class="built_in">this</span>.updateClick$.pipe(mapTo(<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">this</span>.showNotificatoin$ = merge(show$, hide$);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getUserOnce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rxjsNotificationService.users.pipe(take(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getNotifications</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rxjsNotificationService.users.pipe(skip(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Html 完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:30px;width: 40%;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-md-center&quot;</span> *<span class="attr">ngIf</span>=<span class="string">&quot;showNotificatoin$ | async&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;alert alert-warning w-100&quot;</span> <span class="attr">role</span>=<span class="string">&quot;alert&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Warning!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> new user infor available, please click to update!</span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 20px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-warning&quot;</span></span></span><br><span class="line"><span class="tag">                (<span class="attr">click</span>)=<span class="string">&quot;updateClick$.next()&quot;</span>&gt;</span>Update<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-md-center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin: 10px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;card w-100&quot;</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>service 完整代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/common/http&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;../interface/rxjs-notification.interface&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map, catchError, shareReplay, switchMap &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">of</span>, Observable, timer &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CACHE_SIZE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REFRESH_INTERVAL = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> API_ENDPOINT = <span class="string">&quot;https://api.github.com/users?since=&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsNotificationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> cacheUsers$: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line">    <span class="keyword">private</span> userStartId: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">users</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.cacheUsers$) &#123;</span><br><span class="line">            <span class="keyword">const</span> timer$ = timer(<span class="number">0</span>, REFRESH_INTERVAL);</span><br><span class="line">            <span class="built_in">this</span>.cacheUsers$ = timer$</span><br><span class="line">                .pipe(</span><br><span class="line">                    switchMap(<span class="function">() =&gt;</span> <span class="built_in">this</span>.requestUsers()),</span><br><span class="line">                    shareReplay(CACHE_SIZE)</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cacheUsers$;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">requestUsers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userStartId = <span class="built_in">this</span>.userStartId + <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;(API_ENDPOINT + <span class="built_in">this</span>.userStartId)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">respone</span> =&gt;</span> respone),</span><br><span class="line">                catchError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong &quot;</span> + error)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：四种 Subjuct 的用法和区别</title>
      <link href="/2021/07/07/RxJS%EF%BC%9A%E5%9B%9B%E7%A7%8D-Subjuct-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/07/07/RxJS%EF%BC%9A%E5%9B%9B%E7%A7%8D-Subjuct-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：四种-Subject-的用法和区别"><a href="#RxJS：四种-Subject-的用法和区别" class="headerlink" title="RxJS：四种 Subject 的用法和区别"></a>RxJS：四种 Subject 的用法和区别</h1><p>在 RxJS 中有四种 Subject 分别是：Subject、BehaviorSubject、AsyncSubject、ReplaySubject；这四种 Subject 都是特殊的 Observable。</p><p>四种 Subject 与普通 Observable 的区别：</p><table><thead><tr><th align="center">Observable</th><th align="center">Subject</th><th align="center">BehaviorSubject</th><th align="center">AsyncSubject</th><th align="center">ReplaySubject</th></tr></thead><tbody><tr><td align="center">Cold</td><td align="center">Hot</td><td align="center">Hot</td><td align="center">Hot</td><td align="center">Hot</td></tr><tr><td align="center">数据生成者</td><td align="center">数据生成者和消费者</td><td align="center">数据生成者和消费者</td><td align="center">数据生成者和消费者</td><td align="center">数据生成者和消费者</td></tr><tr><td align="center">单播</td><td align="center">多播</td><td align="center">多播</td><td align="center">多播</td><td align="center">多播</td></tr><tr><td align="center">每次从头开始把值发给观察者</td><td align="center">将值多播给已注册监听该 Subject 的观察者</td><td align="center">把最后一个值 (当前值) 发送给观察者 (需要初始值)</td><td align="center">执行的最后一个值发送给观察者，相当于 last( )</td><td align="center">可以把之前的值发送给观察者 (错过的值)</td></tr></tbody></table><h2 id="Cold-vs-Hot"><a href="#Cold-vs-Hot" class="headerlink" title="Cold vs Hot"></a>Cold vs Hot</h2><p>前面介绍了 Cold Observables 与 Hot Observables 的区别，除了 Observable 之外，这四种 Subject 都是 Hot Observables。</p><h2 id="数据生产者-vs-数据消费者"><a href="#数据生产者-vs-数据消费者" class="headerlink" title="数据生产者 vs 数据消费者"></a>数据生产者 vs 数据消费者</h2><ul><li><em><strong>数据生产者</strong></em> 是指 Observable (可观察对象)，产生数据的一方</li><li><em><strong>数据消费者</strong></em> 是指 Observer (观察者)，接收数据的一方</li></ul><p>普通的 Observable 只是数据生产者，发送数据。而 Subject、BehaviorSubject、AsyncSubject 和 ReplaySubject 即是生产者有时消费者。比如在 Angular 项目中，我们经常是哟 Subject 在多个 component 中共享数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// messageService.ts</span></span><br><span class="line">private shareData: Subject&lt;string&gt; = <span class="keyword">new</span> Subject&lt;string&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sendData</span>(<span class="params">value: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.shareData.next(value);</span><br><span class="line">&#125;</span><br><span class="line">getData(): Observable&lt;string&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.shareData.asObservable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RxjsSubjectBComponent</span></span><br><span class="line"><span class="comment">// send data from RxjsSubjectBComponent</span></span><br><span class="line">  <span class="built_in">this</span>.messageService.sendData(<span class="string">&quot;this message from subject b&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RxjsSubjectCComponent</span></span><br><span class="line"><span class="comment">// get data in RxjsSubjectCComponent</span></span><br><span class="line"><span class="built_in">this</span>.subscription = <span class="built_in">this</span>.messageService.getData()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = val;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>在这两个 component 中通过定义在 messageService 的 Subject 共享数据，通过 next( ) 方法使得 Subject 是数据生产者 (可观察对象) ，通过 asObservable( ) 使得 Subject 是数据消费者 (Observers)。</p><h2 id="单播-vs-多播"><a href="#单播-vs-多播" class="headerlink" title="单播 vs 多播"></a>单播 vs 多播</h2><p>在上面的代码例子中，不仅是 component c 可以订阅拿到数据，其他 component 中也可以订阅拿到数据。比如在 RxjsSubjectAComponent 中定义如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RxjsSubjectAComponent</span></span><br><span class="line"><span class="comment">// get data in RxjsSubjectAComponent</span></span><br><span class="line"><span class="built_in">this</span>.subscription = <span class="built_in">this</span>.messageService.getData()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in componet A and &quot;</span> + val);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>从 RxjsSubjectComponent 发出值，在 RxJSSubjectCComponent 和 RxjsSubjectAComponent 能拿到同样的值，这个就是多播。</p><p>普通的 Observables 是 Cold Observables 并且是单播的，其他四种 Subject 是 Hot Observables 并且是多播的。</p><p>单播的意思是，每个普通的 Observables 实例都只能被一个观察者订阅，当它被其他观察者订阅的时候，会产生一个新的实例。也就是普通的 Observables 被不同的观察者订阅的时候，会有多个实例，不管观察者是从何时开始订阅，每个实例都是从头开始把值发给对应的观察者。</p><h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>Subject 其中的一个变体就是 BehaviorSubject，它有一个“当前值”的概念。它保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”，在定义一个 BehaviorSubject 时需要有初始值。</p><p>在 messageService 定义一个 BehaviorSubject，初始值是 1，updateBehaviorSubject 方法把值更新为 2，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//messageService.ts</span></span><br><span class="line">private behaviorSubject: BehaviorSubject&lt;number&gt; = <span class="keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="number">1</span>);</span><br><span class="line">currentBehaviorSubject = <span class="built_in">this</span>.behaviorSubject.asObservable();</span><br><span class="line"><span class="function"><span class="title">updateBehaviorSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.behaviorSubject.next(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在 RxjsSubjectBComponent 中调用执行了 updateBehaviorSubject 方法，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RxjsSubjectBComponent</span></span><br><span class="line"><span class="built_in">this</span>.messageService.updateBehaviorSubject();</span><br></pre></td></tr></table></figure><p>在 RxjsSubjectAComponent 中订阅 BehaviorSubject 的值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription1 = <span class="built_in">this</span>.messageService.currentBehaviorSubject</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectAComponent and Current behavior subject value is  &quot;</span> + val)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.subscription.add(subscription1);</span><br></pre></td></tr></table></figure><p>在 RxjsSubjectCComponent 中，等 5 秒以后再订阅 BehaviorSubject 的值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription1 = <span class="built_in">this</span>.messageService.currentBehaviorSubject</span><br><span class="line">        .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectCComponent and Current behavior subject value is  &quot;</span> + val)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>运行效果：在 RxJSSubjectAComponent 中会拿到 1 和 2 两个值，在RxJSSubjectCComponent中会拿到 2 这个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectAComponent and Current behavior subject value is  <span class="number">1</span></span><br><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectAComponent and Current behavior subject value is  <span class="number">2</span></span><br><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectCComponent and Current behavior subject value is  <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果是正常的 Hot Observable 在 5 秒之后，拿不到任何值，因为在 5 秒内已经将所有值发送出去了，5 秒之后观察者再订阅，没有任何值可以发送了。但是用 BehaviorSubject 保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”，所以 RxJSSubjectCComponent 的订阅者会拿到 2 这个值。</p><h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>类似于 BehaviorSubject，可以发送旧值给新的订阅者，但是不仅是“当前值”，还可以是之前的旧值。</p><p>在 messageService 定义一个 ReplaySubject，<u>为新的订阅者缓冲 3 个值</u>，sendReplaySubject 方法把 1、2、3、4、5 五个值发送给订阅者，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//messageService.ts</span></span><br><span class="line">private replaySubject: ReplaySubject&lt;number&gt; = <span class="keyword">new</span> ReplaySubject&lt;number&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="function"><span class="title">sendReplaySubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getReplaySubject(): Observable&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replaySubject.asObservable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 RxjsSubjectBComponent 中，调用 sendReplaySubject 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.messageService.sendReplaySubject();</span><br></pre></td></tr></table></figure><p>在 RxjsSubjectAComponent 中，订阅 ReplaySubject 的值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription2 = <span class="built_in">this</span>.messageService.getReplaySubject()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectAComponent and Current Replay subject value is  &quot;</span> + val)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.subscription.add(subscription2);</span><br></pre></td></tr></table></figure><p>在 RxjsSubjectCComponent 中，等5秒以后在订阅 replaySubject 的值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription2 = <span class="built_in">this</span>.messageService.getReplaySubject()</span><br><span class="line">        .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectCComponent and Current repaly subject value is  &quot;</span> + val)</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">this</span>.subscription.add(subscription2);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>只有当 Observable 执行完成之后 (执行 complete ( ))，它才会将执行的最后一个值发送给观察者。</p><p>在 messageService 定义一个 AsyncSubject，sendAsyncSubject 方法把 10001 10002 10003 三个值发给订阅者，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private asyncSubject: AsyncSubject&lt;number&gt; = <span class="keyword">new</span> AsyncSubject&lt;number&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sendAsyncSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.next(<span class="number">10001</span>);</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.next(<span class="number">10002</span>);</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.next(<span class="number">10003</span>);</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.complete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getAsyncSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.asyncSubject.asObservable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 RxjsSubjectBComponent 中，调用 sendAsyncSubject 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.messageService.sendAsyncSubject();</span><br></pre></td></tr></table></figure><p>在 RxjsSubjectAComponent 中，订阅 asyncSubject 的值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription3 = <span class="built_in">this</span>.messageService.getAsyncSubject()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectAComponent and Current Async subject value is  &quot;</span> + val)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.subscription.add(subscription3);</span><br></pre></td></tr></table></figure><p>在 RxjsSubjectCComponent 中，等5秒以后在订阅 asyncSubject 的值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription3 = <span class="built_in">this</span>.messageService.getAsyncSubject()</span><br><span class="line">        .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectCComponent and Current async subject value is  &quot;</span> + val)</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">this</span>.subscription.add(subscription3);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectAComponent and Current Async subject value is  <span class="number">10003</span></span><br><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectCComponent and Current <span class="keyword">async</span> subject value is  <span class="number">10003</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：入门和概览</title>
      <link href="/2021/07/07/RXJS%EF%BC%9A%E5%85%A5%E9%97%A8%E5%92%8C%E6%A6%82%E8%A7%88/"/>
      <url>/2021/07/07/RXJS%EF%BC%9A%E5%85%A5%E9%97%A8%E5%92%8C%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="RXJS：入门和概览"><a href="#RXJS：入门和概览" class="headerlink" title="RXJS：入门和概览"></a>RXJS：入门和概览</h1><p>RxJS 是 Reactive Extensions For JavaScript 的简写，它是一个强大的 JavaScript Reactive 编程库。Reactive 是指响应式编程。</p><h2 id="什么是响应式编程"><a href="#什么是响应式编程" class="headerlink" title="什么是响应式编程"></a><strong>什么是响应式编程</strong></h2><p>任何异步事件（比如页面鼠标 click 事件），在响应式编程都是异步事件流。不仅仅是 click、hover 这种事件，任何变量、用户输入、属性、缓存、数据结构等，响应式编程把所有事物都看成是数据流。数据流是类似数组一样的序列，可以像一样，用 merge、map、concat 等方法操作。简单来说就是：把所有事物都事件流化，然后把这些事件流像数组一样去操作，就是响应式编程。</p><p>RxJS 提供了各种 API 来创建数据流：</p><ul><li>单值：of、empty、never</li><li>多值：from</li><li>定时：interval、timer</li><li>从事件创建：fromEvent</li><li>从 Promise 创建：fromPromise</li><li>自定义创建：create</li></ul><p>创建出来的数据流，是一种类似数组一样的序列，可以被订阅，也可以用如下 API 操作控制：</p><ul><li>改变数据形态：map、mapTo、pluck</li><li>过滤一些值：filter、skip、first、last、take</li><li>时间轴上的操作：delay、timeout、throttle、debounce、audit、bufferTime</li><li>累加：reduce、scan</li><li>异常处理：throw、catch、retry、finally</li><li>条件执行：takeUntil、delayWhen、retryWhen、subscribeOn、ObserveOn</li><li>转接：switch</li><li>concat，保持原来的序列顺序连接两个数据流</li><li>merge，合并序列</li><li>race，预设条件为其中一个数据流完成</li><li>forkJoin，预设条件为所有数据流都完成</li><li>zip，取各来源数据流最后一个值合并为对象</li><li>combineLatest，取各来源数据流最后一个值合并为数组</li></ul><h2 id="异步事件流"><a href="#异步事件流" class="headerlink" title="异步事件流"></a>异步事件流</h2><p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/GIT04l.jpg" alt="alt"></p><p>在上图中有如下几种东西：</p><ul><li>click 事件流</li><li>事件流产生的值</li><li>错误‘</li><li>事件流结束</li><li>时间轴</li></ul><p>点击一个按钮事件，随着时间推移，这个点击事件会产生三个不同的结果：值，发生错误，事件完成。我们可以定义方法用来：捕获值，捕获错误，捕获点击事件结束。在这个过程中，涉及以下几个 RxJS 的基本概念：</p><ul><li>Observable (可观察对象)：就是点击事件流</li><li>Observers (观察者)：就是捕获值 / 错误 / 事件结束的方法 (其实就是回调函数的集合)</li><li>Subscription (订阅)：Observable 产生的值都需要经过经过一个 ‘监听’ 传给 Observers，这个就是 Subscription</li><li>生产者 (Producer)：就是点击事件，是事件的生产者</li></ul><p>我们也可以用 ASCII 来描述这个事件流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--a---b-c---d---X---|-&gt;</span><br><span class="line"></span><br><span class="line">a b c d 是产生的值</span><br><span class="line">X 是错误</span><br><span class="line">| 是事件结束标志</span><br><span class="line">---&gt; 是时间线</span><br></pre></td></tr></table></figure><h2 id="响应式编程的必要性"><a href="#响应式编程的必要性" class="headerlink" title="响应式编程的必要性"></a>响应式编程的必要性</h2><p>例子：页面上有一个按钮，现在需要统计按钮点击次数。</p><p>没有 RxJS，代码是这样子的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter = counter + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用 RxJS，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clickStream$ = fromEvent(button, <span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counterStream$ = clickStream$.pipe(</span><br><span class="line">    map(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;),</span><br><span class="line">    scan(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">counterStream$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is the click counter: &quot;</span> + data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>整个事件流可以用 ASCII 描述如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clickStream: ---c----c--c----c------c--&gt;</span><br><span class="line">                   map(c becomes <span class="number">1</span>) </span><br><span class="line">               ---<span class="number">1</span>----<span class="number">1</span>--<span class="number">1</span>----<span class="number">1</span>------<span class="number">1</span>--&gt;</span><br><span class="line">                   scan(+) </span><br><span class="line"><span class="attr">counterStream</span>: ---<span class="number">1</span>----<span class="number">2</span>--<span class="number">3</span>----<span class="number">4</span>------<span class="number">5</span>--&gt;</span><br></pre></td></tr></table></figure><p>点击事件可以看成数据流 (clickStream)，在 clickStream 事件流基础上用方法 map 把每次点击事件转化成 1，然后用 scan 把所有的点击次数加起来，当我们执行 map 或者 scan 的时候都会在原来的数据流基础上生产一个新的数据流，原来的数据流不变。</p><p>从上面的这个例子还不能看出 RxJS 的强大和优势，我们现在再来看下：统计出双击事件次数，或者多次点击 (两次或两次以上) 都统计为双击次数。如果要用传统代码实现这个需求，肯定要很多变量来声明各种状态而且还要用到 intervals，代码逻辑复杂且容易出错，但是在响应式编程里十分简单，实际只需要四行代码。</p><p>我们先用 ASCII 把流程画一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   clickStream: ----c----c-c---c-cc---ccc---c----|-&gt;</span><br><span class="line">                buff(clickStream.throttleTime(250ms))</span><br><span class="line">                ----c----cc-----ccc---ccc---c----|-&gt;</span><br><span class="line">                    map(<span class="string">&#x27;get length of lists&#x27;</span>)</span><br><span class="line">                ----<span class="number">1</span>-----<span class="number">2</span>------<span class="number">3</span>-----<span class="number">3</span>----<span class="number">1</span>----|-&gt;</span><br><span class="line">                    filter(x&gt;=<span class="number">2</span>)                  </span><br><span class="line"><span class="attr">mulClickStream</span>: ----------<span class="number">2</span>------<span class="number">3</span>-----<span class="number">3</span>---------|-&gt;</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clickStream$ = fromEvent(button, <span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doubleClickStream$ = clickStream$</span><br><span class="line">    .pipe(</span><br><span class="line">        buffer(clickStream$.pipe(throttleTime(<span class="number">250</span>))),</span><br><span class="line">        map(<span class="function"><span class="params">click</span> =&gt;</span> &#123; <span class="keyword">return</span> click.length &#125;),</span><br><span class="line">        filter(<span class="function"><span class="params">num</span> =&gt;</span> num &gt;= <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">doubleClickStream$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;the number of double click is: &quot;</span> + data);;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面这个简单的例子，我们可以看到 RxJS 提供大量的操作符，处理不同的业务需求，短短几行就可以涵盖很复杂的代码逻辑，在前端交互非常复杂的系统中，客户端都是基于事件编程的，对事件处理非常多，用 RxJS 比较有优势。当然响应式编程也是支持各种语言的，包括：RxJava、Rx.NET、RxPY、RxGO等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Observable Operator &amp; Marble Diagrams</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AObservable%20Operator%20&amp;%20Marble%20Diagrams/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AObservable%20Operator%20&amp;%20Marble%20Diagrams/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Observable-Operator-amp-Marble-Diagrams"><a href="#RxJS：Observable-Operator-amp-Marble-Diagrams" class="headerlink" title="RxJS：Observable Operator &amp; Marble Diagrams"></a>RxJS：Observable Operator &amp; Marble Diagrams</h1><h2 id="什么是-Operator"><a href="#什么是-Operator" class="headerlink" title="什么是 Operator"></a>什么是 Operator</h2><p>Operator 就是一个个被附加到 Observable 的函数，例如：map、filter、concatAll 等等，所有这些函数都会拿到原本的 Observable 并回传一个新的 Observable。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> people = Rx.Observable.of(<span class="string">&#x27;Jerry&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">source, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source.subscribe(</span><br><span class="line">            <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    observer.next(callback(value));</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    observer.error(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; observer.error(err); &#125;,</span><br><span class="line">            <span class="function">() =&gt;</span> &#123; observer.complete() &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helloPeople = map(people, <span class="function">(<span class="params">item</span>) =&gt;</span> item + <span class="string">&#x27; Hello~&#x27;</span>);</span><br><span class="line"></span><br><span class="line">helloPeople.subscribe(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// Jerry Hello~</span></span><br><span class="line"><span class="comment">// Anna Hello~</span></span><br></pre></td></tr></table></figure><p>这里可以看到写了一个 <code>map</code> 函数，它接收两个参数，第一个是原本的 <code>Observable</code>，第二个是 <code>map</code> 的 <code>callback function</code>。<code>map</code> 内部第一件事就是用 <code>create</code> 建立一个新的 <code>Observable</code> 并回传，并且在内部订阅原本的 <code>Observable</code>。</p><p>当然我们也可以直接把 <code>map</code> 塞到 <code>Observable.prototype</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.subscribe(</span><br><span class="line">            <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    observer.next(callback(value));</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    observer.error(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; observer.error(err); &#125;,</span><br><span class="line">            <span class="function">() =&gt;</span> &#123; observer.complete() &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Rx.Observable.prototype.map = map;</span><br><span class="line"><span class="keyword">var</span> people = Rx.Observable.of(<span class="string">&#x27;Jerry&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> helloPeople = people.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item + <span class="string">&#x27; Hello~&#x27;</span>);</span><br><span class="line"></span><br><span class="line">helloPeople.subscribe(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// Jerry Hello~</span></span><br><span class="line"><span class="comment">// Anna Hello~</span></span><br></pre></td></tr></table></figure><p>这里有两个重点必须知道，每个 <code>operator</code> 都会回传一个新的 <code>observable</code>，而我们可以通过 <code>create</code> 的方法建立各种 <code>operator</code>。</p><blockquote><p>在 RxJS 5 的实例中，其实每个 Operator 是透过原来的 Observable 的 <code>lift</code> 方法来建立新的 Observable，这个方法会在新回传的 Observable 事件内偷塞两个属性，分别是 <code>source</code> 和 <code>operator</code>，记录原本的资料和当前使用的 <code>operator</code>。</p></blockquote><blockquote><p>其实 <code>lift</code> 方法还是用 <code>new Observable</code> (跟 create 一样)。至于为什么要独立这个方法，除了更好的封装之外，主要的原因是为了让 RxJS 5 的使用者能更好的 debug。关于 RxJS 5 的除错方式，之后会讲。</p></blockquote><p>在学习 <code>operator</code> 之前，为了更好地理解，我们需要订定一个简单的方式来表达 Observable。</p><h2 id="Marble-Diagrams"><a href="#Marble-Diagrams" class="headerlink" title="Marble Diagrams"></a>Marble Diagrams</h2><p>我们把描绘 Observable 的图示称为 Marble Diagrams，采用类似 ASCAII 的绘画方式。</p><p>我们用 <code>-</code> 来表达一小段时间，这些 <code>-</code> 串起来就代表一个 Observable</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p><code>X</code> (大写 X) 表示有错误发生</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">------------------------X</span><br></pre></td></tr></table></figure><p><code>|</code> 表示 Observable 结束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">------------------------|</span><br></pre></td></tr></table></figure><p>用这个时间序当中，我们可能会发送值，如果值是数字则是直接用阿拉伯数字取代，其他的资料类型则用相近的英文符号代表，这里我们用 <code>interval</code> 来举例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-----<span class="number">0</span>-----<span class="number">1</span>-----<span class="number">2</span>-----<span class="number">3</span>--...</span><br></pre></td></tr></table></figure><p>当 Observable 是同步发送值的时候，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><code>source</code>  的图形就会长这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1234</span>)|</span><br></pre></td></tr></table></figure><p>小括号代表同步发生。</p><p>另外，Marble Diagrams 也能够表达 operator 的前后转换，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> newest = source.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>); </span><br></pre></td></tr></table></figure><p>这时 Marble Diagrams 就会长这样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source: -----<span class="number">0</span>-----<span class="number">1</span>-----<span class="number">2</span>-----<span class="number">3</span>--...</span><br><span class="line">map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>)</span><br><span class="line"><span class="attr">newest</span>: -----<span class="number">1</span>-----<span class="number">2</span>-----<span class="number">3</span>-----<span class="number">4</span>--...</span><br></pre></td></tr></table></figure><p>最上面是原本的 Observable，中间是 Operator，下面则是最新的 Observable。</p><p>以上就是 Marble Diagrams 如何表示 Operator 对 Observable 的操作，这能让我们更好的理解各个 Operator。</p><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><p>Observable 的 <code>map</code> 方法使用跟数组中的 <code>map</code> 是一样的，我们传入一个 <code>callback function</code>，这个 <code>callback function</code> 会带入每次的发送值，然后再回传一个经过处理的值，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> newest = source.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">newest.subscribe(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5..</span></span><br></pre></td></tr></table></figure><p>用 Marble Diagrams 表达就是：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source: -----<span class="number">0</span>-----<span class="number">1</span>-----<span class="number">2</span>-----<span class="number">3</span>--...</span><br><span class="line">            map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>)</span><br><span class="line"><span class="attr">newest</span>: -----<span class="number">1</span>-----<span class="number">2</span>-----<span class="number">3</span>-----<span class="number">4</span>--...</span><br></pre></td></tr></table></figure><p>还有一个方法，名为 <code>mapTo</code>，跟 <code>map</code> 方法很像</p><h3 id="mapTo"><a href="#mapTo" class="headerlink" title="mapTo"></a><code>mapTo</code></h3><p><code>mapTo</code> 可以把传进来的值改成一个固定的值，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> newest = source.mapTo(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">newest.subscribe(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2..</span></span><br></pre></td></tr></table></figure><p><code>mapTo</code> 用 Marble Diagrams 表示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source: -----<span class="number">0</span>-----<span class="number">1</span>-----<span class="number">2</span>-----<span class="number">3</span>--...</span><br><span class="line">                mapTo(<span class="number">2</span>)</span><br><span class="line"><span class="attr">newest</span>: -----<span class="number">2</span>-----<span class="number">2</span>-----<span class="number">2</span>-----<span class="number">2</span>--...</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h3><p><code>filter</code> 在使用上也跟数组的相同，我们需要传入一个 <code>callback function</code>，这个 <code>function</code> 会传入每个被发送的元素，并且回传一个 <code>boolean</code> 值，如果为 <code>true</code> 则会保留，如果为 <code>false</code> 就会被过滤掉，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> newest = source.filter(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">newest.subscribe(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6..</span></span><br></pre></td></tr></table></figure><p><code>filter</code> 用 Marble Diagrams 表达：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source: -----<span class="number">0</span>-----<span class="number">1</span>-----<span class="number">2</span>-----<span class="number">3</span>-----<span class="number">4</span>-...</span><br><span class="line">            filter(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="attr">newest</span>: -----<span class="number">0</span>-----------<span class="number">2</span>-----------<span class="number">4</span>-...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - catch, retry, retryWhen, repeat</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20catch,%20retry,%20retryWhen,%20repeat/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20catch,%20retry,%20retryWhen,%20repeat/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-catch-retry-retryWhen-repeat"><a href="#RxJS：Operator-catch-retry-retryWhen-repeat" class="headerlink" title="RxJS：Operator - catch, retry, retryWhen, repeat"></a>RxJS：Operator - catch, retry, retryWhen, repeat</h1><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p><code>catch</code> 是很常见的非同步错误处理方法，在 RxJS 中也能够直接用 <code>catch</code> 来处理错误，在 RxJS 中的 <code>catch</code> 可以回传一个 Observable 来送出新的值，让我们直接看示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .catch(<span class="function"><span class="params">error</span> =&gt;</span> Rx.Observable.of(<span class="string">&#x27;h&#x27;</span>));</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个示例我们每隔 500 毫秒会送出一个字符串 (String)，并用字符串的方法 <code>toUpperCase()</code> 来吧字符串的英文字母改成大写，过程中可能未知的原因送出了一个数值 <code>2</code> 导致发生例外，这时我们在后面接的 <code>catch</code> 就能抓到错误。</p><p><code>catch</code> 可以回传一个新的 Observable、Promise、Array 或任何 Iterable 的事件，来传送之后的元素。</p><p>以我们的例子来说就会在送出 <code>X</code>，Marble Diagrams 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source : ----a----b----c----d----<span class="number">2</span>|</span><br><span class="line">        map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">         ----a----b----c----d----X|</span><br><span class="line">        <span class="keyword">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> Rx.Observable.of(<span class="string">&#x27;h&#x27;</span>))</span><br><span class="line"><span class="attr">example</span>: ----a----b----c----d----h|</span><br></pre></td></tr></table></figure><p>这里可以看到，当错误发生后就会进入到 <code>catch</code> 并重新处理一个新的 Observable，我们可以利用这个新的 Observable 来送出我们想送的值。</p><p>也可以在遇到错误之后，让 Observable 结束，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .catch(<span class="function"><span class="params">error</span> =&gt;</span> Rx.Observable.empty());</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>回传一个 <code>empty</code> 的 Observable 来直接结束。</p><p>另外 <code>catch</code> 的 <code>callback</code> 能接收第二个参数，这个参数会接收当前的 Observable，我们可以回传当前的 Observable，我们可以回传当前的 Observable 来做到重新执行，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .catch(<span class="function">(<span class="params">error, obs</span>) =&gt;</span> obs);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里可以看到我们直接回传了当前的 Observable (其实就是 example) 来重新执行，Marble Diagrams 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source : ----a----b----c----d----<span class="number">2</span>|</span><br><span class="line">        map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">         ----a----b----c----d----X|</span><br><span class="line">        <span class="keyword">catch</span>(<span class="function">(<span class="params">error, obs</span>) =&gt;</span> obs)</span><br><span class="line"><span class="attr">example</span>: ----a----b----c----d--------a----b----c----d--..</span><br></pre></td></tr></table></figure><p>因为是我们只是简单的示范，所以这里会一直无限循环，实际上通常会用在断线重连的情景。</p><p>上面的处理方式还有一种进化的写法，叫做 <code>retry()</code>。</p><h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h3><p>如果我们想要一个 Observable 发生错误时，重新尝试就可以用 <code>retry</code> 这个方法，跟我们前一个讲的示例的行为是一致的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .retry();</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>通常这种无限的 <code>retry</code> 会放在几时同步的重新连接，让我们在连线断掉后，不断尝试重连。另外我们也可以设定只尝试几次，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .retry(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// Error: TypeError: x.toUpperCase is not a function</span></span><br></pre></td></tr></table></figure><p>这里我们对 <code>retry</code> 传入一个数值 <code>1</code>，能够让我们只重复尝试 1 次后送出错误，对应 Marble Diagrams 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source : ----a----b----c----d----<span class="number">2</span>|</span><br><span class="line">        map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">         ----a----b----c----d----X|</span><br><span class="line">                retry(<span class="number">1</span>)</span><br><span class="line"><span class="attr">example</span>: ----a----b----c----d--------a----b----c----d----X|</span><br></pre></td></tr></table></figure><p>这种处理方式很适合在 HTTP request 失败的场景中，我们可以设定重新发送几次后，再抛出错误信息。</p><h3 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen"></a>retryWhen</h3><p>RxJS 还提供了另一种方法 <code>retryWhen</code>，他可以把另外发生的元素放到一个 Observable 中，让我们可以直接操作这个 Observable，并等到整个 Observable 操作完后再重新订阅一次原本的 Observable。</p><p>直接看代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .retryWhen(<span class="function"><span class="params">errorObs</span> =&gt;</span> errorObs.delay(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>这里 <code>retryWhen</code> 我们传入一个 <code>callback</code>，这个 <code>callback</code> 有一个参数会传入一个 Observable，这个 Observable 不是原本的 Observable (example) 而是另外事件送出的错误所组成的一个 Observable，我们可以对这个由错误所组成的 Observable 做操作，等到这次的处理完成后就会重新订阅我们原本的 Observable。</p><p>这个示例我们是把错误的 Observable 送出错误延迟 1 秒，这会使后面重新订阅的动作延迟 1 秒才执行，对应 Marble Diagrams 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source : ----a----b----c----d----<span class="number">2</span>|</span><br><span class="line">        map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">         ----a----b----c----d----X|</span><br><span class="line">        retryWhen(<span class="function"><span class="params">errorObs</span> =&gt;</span> errorObs.delay(<span class="number">1000</span>))</span><br><span class="line"><span class="attr">example</span>: ----a----b----c----d-------------------a----b----c----d----...</span><br></pre></td></tr></table></figure><p>从上图可以看到后续重新订阅的行为就被延后了，但实际上我们不太会用 <code>retryWhend</code> 来做重新订阅的延迟，通常是直接用 <code>catch</code> 做到这件事。这里只是为了示范 <code>retryWhen</code> 的行为，实际上我们</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>我们有时候可能想要 <code>retry</code> 一直重复订阅的效果，但没有错误发生，这时就可以用 <code>repeat</code> 来做到这件事，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.repeat(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>这里 <code>repeat</code> 的行为跟 <code>retry</code> 基本一致，只是 <code>retry</code> 只有在例外发生时才出发，对应 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : ----a----b----c|</span><br><span class="line">            repeat(<span class="number">1</span>)</span><br><span class="line"><span class="attr">example</span>: ----a----b----c----a----b----c|</span><br></pre></td></tr></table></figure><p>同样，我们也可以加参数不让他无限循环，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.repeat();</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就可以做不断重复的行为，这个可以在建立轮询时使用，让我们不断地发 request 来更新画面。</p><p>最后看一下错误处理在实际应用的小示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x,y</span>) =&gt;</span> x)</span><br><span class="line">            .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase()); </span><br><span class="line">            <span class="comment">// 通常 source 会是建立即时同步的连线，像是 web socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.catch(</span><br><span class="line">                <span class="function">(<span class="params">error, obs</span>) =&gt;</span> Rx.Observable.empty()</span><br><span class="line">                               .startWith(<span class="string">&#x27;连线发生错误： 5秒后重连&#x27;</span>)</span><br><span class="line">                               .concat(obs.delay(<span class="number">5000</span>))</span><br><span class="line">                 );</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; title.innerText = value &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>这个示例其实就是模仿在即使同步断线时，利用 <code>catch</code> 返回一个新的 Observable，这个 Observable 会先送出错误信息并且把原本的 Observable 延迟 5 秒再作合并，虽然这只不过是一个模仿，但它清除展示了 RxJS 在做错误处理时的灵活性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - distinct, distinctUntilChanged</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20distinct,%20distinctUntilChanged/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20distinct,%20distinctUntilChanged/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-distinct-distinctUntilChanged"><a href="#RxJS：Operator-distinct-distinctUntilChanged" class="headerlink" title="RxJS：Operator - distinct, distinctUntilChanged"></a>RxJS：Operator - distinct, distinctUntilChanged</h1><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p><code>distinct</code> 可以帮我们把相同值的值滤掉只留一个</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">300</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br><span class="line"><span class="keyword">var</span> example = source.distinct()</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : --a--b--c--a--b|</span><br><span class="line">            distinct()</span><br><span class="line"><span class="attr">example</span>: --a--b--c------|</span><br></pre></td></tr></table></figure><p>从上面可以看出，当使用了 <code>distinct</code> 之后，只要有重复出现的值就会被滤掉。</p><p>另外还可以传入一个 <code>selector callback function</code>，这个 <code>callback</code> 会传入一个接收到的元素，并回传我们真正希望比对的值，举例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([&#123; <span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span>&#125;, &#123; <span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="attr">value</span>: <span class="string">&#x27;c&#x27;</span> &#125;, &#123; <span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span> &#125;, &#123; <span class="attr">value</span>: <span class="string">&#x27;c&#x27;</span> &#125;])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">300</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br><span class="line"><span class="keyword">var</span> example = source.distinct(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.value</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;b&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>这里可以看到，因为 <code>source</code> 送出的都是实例，而 JS 事件的比对是比对内存位置，所以在这个例子中这些实例永远不会相等，但实际上我们想比对的是实例中的 <code>value</code>，这时我们可以传入 <code>selector callback</code>，来选择我们要比对的值。</p><blockquote><p><code>distinct</code> 传入的 <code>callback</code> 在 RxJS 5 几个 beta 版本中有过很多改变，现在网络上很多文章跟教学都是过时的，务必小心</p></blockquote><p>实际上 <code>distinct</code> 会在背地里建立一个 <code>Set</code>，当接收元素时先去判断 <code>Set</code> 内是否有相同的值，如果有就不送出，如果没有则存到 <code>Set</code> 并送出。所以尽量不要直接把 <code>distinct</code> 用在一个无限的 Observable 里，这样很可能会让 <code>Set</code> 越来越大，建议大家可以放第二个参数 <code>flushes</code>，或用 <code>distinctUntilChanged</code>。</p><blockquote><p>这里指的 <code>Set</code> 其实是 RxJS 自己实现的，跟 ES6 原生的 Set 行为也都一致，只是因为 ES6 的 <code>Set</code> 支持程度还并不理想，所以这里是直接用 JS 实现。</p></blockquote><p><code>distinct</code> 可以传入第二个参数 <code>flushes</code>，用来清除暂存的资料，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">300</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br><span class="line"><span class="keyword">var</span> flushes = Rx.Observable.interval(<span class="number">1300</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.distinct(<span class="literal">null</span>, flushes);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>对应的 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source : --a--b--c--a--c|</span><br><span class="line">flushes: ------------<span class="number">0</span>---...</span><br><span class="line">        distinct(<span class="literal">null</span>, flushes);</span><br><span class="line">example: --a--b--c-----c|</span><br></pre></td></tr></table></figure><p>其实 <code>flushes</code> 就是 Flushes Observable 在送出元素时，会把 <code>distinct</code> 的暂存清空，所以之后的暂存就会从头来过，这样就不用担心暂存的 <code>Set</code> 越来越大的问题，但其实我们平常不太会用这种方式来处理，通常用另一个方法 <code>distinctUntilChanged</code>。</p><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h3><p><code>distinctUntilChanged</code> 跟 <code>distinct</code> 一样会把相同的元素过滤掉，但 <code>distinctUntilChanged</code> 只会跟最后一次送出的元素比较，不会每个都比，举例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">300</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br><span class="line"><span class="keyword">var</span> example = source.distinctUntilChanged()</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - combineLatest, withLatestFrom, zip</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20combineLatest,%20withLatestFrom,%20zip/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20combineLatest,%20withLatestFrom,%20zip/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-combineLatest-withLatestFrom-zip"><a href="#RxJS：Operator-combineLatest-withLatestFrom-zip" class="headerlink" title="RxJS：Operator - combineLatest, withLatestFrom, zip"></a>RxJS：Operator - combineLatest, withLatestFrom, zip</h1><blockquote><p>非同步最难的地方在于，当有多个非同步行为同时触发且相互依赖，这时候我们要处理的逻辑跟状态就会变得极其复杂，甚至程序很可能会在完成的一两天就成了 Legacy Code (遗留代码)。</p></blockquote><p>我们讲过 <code>merge</code> 的用法，它的逻辑就像是 OR (||) 一样，可以把多个 Observable 合并且同时处理，当其中任何一个 Observable 送出元素时，我们都做相同的处理。</p><p>本文讲的三个 Operator 则像是 AND (&amp;&amp;) 逻辑，它们都是多个元素送进来时，只输出一个新元素，但各自的行为上仍有差异，需要花点时间思考。</p><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>首先介绍的是 <code>combineLatest</code>，它会取得各个 Observable 最后送出的值，再输出成一个值，直接看示例比较容易解释：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> newest = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.combineLatest(newest, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>相信读者第一次看到这个 <code>output</code> 应该都会很困惑，直接看 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>|</span><br><span class="line">newest : --<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>--<span class="number">5</span>|</span><br><span class="line"></span><br><span class="line">    combineLatest(newest, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"></span><br><span class="line">example: ----<span class="number">01</span>--<span class="number">23</span>-<span class="number">4</span>--(<span class="number">56</span>)--<span class="number">7</span>|</span><br></pre></td></tr></table></figure><p>首先 <code>combineLatest</code> 可以接收多个 Observable，最后一个参数是 <code>callback function</code>，这个 <code>callback function</code> 接收的参数数量跟合并的 Observable 数量相同，依照示例来说，因为我们这里合并了两个 Observable 所以后面的 <code>callback function</code> 就接收 <code>x</code>，<code>y</code> 两个参数，<code>x</code> 会接收从 source 发送来的的值，<code>y</code> 会接收从 newest 发送过来的值。</p><p>最后一个重点就是一定会等两个 Observable 都曾有送值出来才会呼叫我们传入的 <code>callback function</code>，所以这段代码是这样运行的</p><ul><li><code>newest</code> 送出了 <code>0</code>，但此时 <code>source</code> 并没有送出过任何值，所以不会执行 <code>callback</code></li><li><code>source</code> 送出了 <code>0</code>，此时 <code>newest</code> 最后一次送出的值为 <code>0</code>，把这两个数传入 <code>callback</code> 得到 <code>0</code></li><li><code>newest</code> 送出了 <code>1</code>，此时 <code>source</code> 最后一次送出的值为 <code>0</code>，把这两个数传入 <code>callback</code> 得到 <code>1</code></li><li><code>newest</code> 送出了 <code>2</code>，此时 <code>source</code> 最后一次送出的值为  <code>0</code>，把这两个数传入 <code>callback</code> 得到<code>2</code></li><li><code>source</code> 送出了 <code>1</code>，此时 <code>newest</code> 最后一次送出的值为 <code>2</code>，把这两个数传入 <code>callback</code> 得到 <code>3</code></li><li><code>newest</code> 送出了 <code>3</code>，此时 <code>source</code> 最后一次送出的值为 <code>1</code>，把这两个数传入 <code>callback</code> 得到 <code>4</code></li><li><code>source</code> 送出了 <code>2</code>，此时 <code>newest</code> 最后一次送出的值为 <code>3</code>，把这两个数传入 <code>callback</code> 得到 <code>5</code></li><li><code>source</code> 结束，但 <code>newest</code> 还没结束，所以 example 还不会结束</li><li><code>newest</code> 送出了 <code>4</code>，此时 <code>source</code> 最后一次发送的值为 <code>2</code>，把这两个数传入 <code>callback</code> 得到 <code>6</code></li><li><code>newest</code> 送出了 <code>5</code>，此时 <code>source</code> 最后一次发送的值为 <code>2</code>，把这两个数传入 <code>callback</code> 得到 <code>7</code></li><li><code>newest</code> 结束，因为 <code>source</code> 也结束了，所以 example 结束</li></ul><p>不管是 <code>source</code> 还是 <code>newest</code> 送出值来，只要另一方曾有送出过值来 (有最后的值)，就会执行 <code>callback</code> 并送出新的值，这就是 <code>combineLatest</code></p><p><code>combineLatest</code> 很常用在运算多个因子的结果，例如最常见的 BMI 计算，我们身高变动时就拿上一次的体重计算新的 BMI，当体重变动时则拿上一次身高计算 BMI，这就很适合 <code>combineLatest</code> 来处理。</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p><code>zip</code> 会取每个 Observable 相同顺位的元素并传入 <code>callback</code>，也就是说每个 Observable 的第 n 个元素会一起被传入 <code>callback</code>，这里我们同样直接用示例讲解会比较清楚</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> newest = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.zip(newest, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>|</span><br><span class="line">newest : --<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>--<span class="number">5</span>|</span><br><span class="line">    zip(newest, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"><span class="attr">example</span>: ----<span class="number">0</span>----<span class="number">2</span>----<span class="number">4</span>|</span><br></pre></td></tr></table></figure><p><code>zip</code> 会等到 <code>source</code> 和 <code>newest</code> 都送出了第一个元素，再传入 <code>callback</code>，下次则等到 <code>source</code> 和 <code>newest</code> 都送出了第二个元素再一起传入 <code>callback</code>，运行步骤如下：</p><ul><li><code>newest</code> 送出了第一个值 <code>0</code>，此时 <code>source</code> 没有送出第一个值，所以不执行 <code>callback</code></li><li><code>source</code> 送出了第一个值 <code>0</code>，<code>newest</code> 之前送出的第一个值为 <code>0</code>，把这两个数传入 <code>callback</code> 得到 <code>0</code></li><li><code>newest</code> 送出了第二个值 <code>1</code>，此时 <code>source</code> 没有送出第二个值，不执行 <code>callback</code></li><li><code>newest</code> 送出了第三个值 <code>2</code>，此时 <code>source</code> 没有送出第三个值，不执行 <code>callback</code></li><li><code>source</code> 送出了第二个值 <code>1</code>，<code>newest</code> 之前送出的第二个值为 <code>1</code>，把这两个数传入 <code>callback</code> 得到 <code>2</code></li><li><code>newest</code> 送出了第四个值 <code>3</code>，此时 <code>source</code> 并没有送出第四个值，不执行 <code>callback</code></li><li><code>source</code> 送出了第三个值 <code>2</code>，<code>newest</code> 之前送出的第二个值为 <code>2</code>，把这两个数传入 <code>callback</code> 得到 <code>4</code></li><li><code>source</code> 结束 example 就直接结束，因为 <code>source</code> 和 <code>newest</code> 不会再有对应顺位的值</li></ul><p><code>zip</code> 会把各个 Observable 相同顺位送出的值传入 <code>callback</code>，这很常拿来做 demo 使用，比如我们想间隔 100ms 送出 ‘h’ ‘e’ ‘l’ ‘l’ ‘o’，就可以这么做</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.interval(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.zip(source2, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br></pre></td></tr></table></figure><p>对应 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source : (hello)|</span><br><span class="line">source2: -<span class="number">0</span>-<span class="number">1</span>-<span class="number">2</span>-<span class="number">3</span>-<span class="number">4</span>-...</span><br><span class="line">        zip(source2, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x)</span><br><span class="line"><span class="attr">example</span>: -h-e-l-l-o|</span><br></pre></td></tr></table></figure><p>这里利用 <code>zip</code> 来达到原本只能同步发送的资料变成了非同步，适合建立示范用的资料</p><blockquote><p>平常没事不要乱用 <code>zip</code>，除非真的需要，因为 <code>zip</code> 必须 cache 住还没处理的元素，当两个 Observable 一个很快一个很慢的时候，就会 cache 住非常多的元素，等待比较慢的那个 Observable。可能会造成内存相关的问题。</p></blockquote><h3 id="withLatestFrom"><a href="#withLatestFrom" class="headerlink" title="withLatestFrom"></a>withLatestFrom</h3><p><code>withLatestFrom</code> 运行方式跟 <code>combineLatest</code> 有点像，只是他又有主从的关系，只有在主要的 Observable 送出新的值时，才会执行 <code>callback</code>，附随的 Observable 只是在背景下运行。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> main = Rx.Observable.from(<span class="string">&#x27;hello&#x27;</span>).zip(Rx.Observable.interval(<span class="number">500</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br><span class="line"><span class="keyword">var</span> some = Rx.Observable.from([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]).zip(Rx.Observable.interval(<span class="number">300</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = main.withLatestFrom(some, <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y === <span class="number">1</span> ? x.toUpperCase() : x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应的 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main   : ----h----e----l----l----o|</span><br><span class="line">some   : --<span class="number">0</span>--<span class="number">1</span>--<span class="number">0</span>--<span class="number">0</span>--<span class="number">0</span>--<span class="number">1</span>|</span><br><span class="line"></span><br><span class="line">withLatestFrom(some, <span class="function">(<span class="params">x, y</span>) =&gt;</span>  y === <span class="number">1</span> ? x.toUpperCase() : x);</span><br><span class="line"></span><br><span class="line">example: ----h----e----l----L----O|</span><br></pre></td></tr></table></figure><p><code>withLatestFrom</code> 会在 <code>main</code> 送出值的时候执行 <code>callback</code>，注意如果 <code>main</code> 送出值时 <code>some</code> 之前没有送出任何值 <code>callback</code> 仍然不会执行。</p><p>在 <code>main</code> 送出值时，判断 <code>some</code> 最后一次送的是不是 <code>1</code> 来决定是否切换大小写，执行步骤如下：</p><ul><li><code>main</code> 送出了 <code>h</code>，此时 <code>some</code> 上一次送出的值为 <code>0</code>，把这两个参数传入 <code>callback</code> 得到 <code>h</code></li><li><code>main</code> 送出了 <code>e</code>，此时 <code>some</code> 上一次送出的值为 <code>0</code>，把这两个参数传入 <code>callback</code> 得到 <code>e</code></li><li><code>main</code> 送出了 <code>l</code>，此时 <code>some</code> 上一次送出的值为 <code>0</code>，把这两个参数传入 <code>callback</code> 得到 <code>l</code></li><li><code>main</code> 送出了 <code>l</code>，此时 <code>some</code> 上一次送出的值为 <code>1</code>，把这两个参数传入 <code>callback</code> 得到 <code>L</code></li><li><code>main</code> 送出了 <code>o</code>，此时 <code>some</code> 上一次送出的值为 <code>1</code>，把这两个参数传入 <code>callback</code> 得到 <code>O</code></li></ul><p><code>withLatestFrom</code> 很常用在一些 <code>checkbox</code> 型的功能，例如说一个编辑器，开启粗体之后，打出来的字就都要变粗体，粗体就像 <code>some</code> Observable，打字就像 <code>main</code> Observable。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - scan, buffer</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20scan,%20buffer/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20scan,%20buffer/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-scan-buffer"><a href="#RxJS：Operator-scan-buffer" class="headerlink" title="RxJS：Operator - scan, buffer"></a>RxJS：Operator - scan, buffer</h1><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p><code>scan</code> 其实就是 Observable 版本的 <code>reduce</code> 只是命名不同。如果熟悉数组操作的话，应该知道原生的 JS Array 就有 <code>reduce</code> 方法，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.reduce(<span class="function">(<span class="params">origin, next</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(origin)</span><br><span class="line">    <span class="keyword">return</span> origin + next</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>reduce</code> 方法需要传两个参数，第一个是 <code>callback</code> 第二个则是起始状态，这个 <code>callback</code> 执行时，会传入两个参数，一个是原本的状态，另一个是修改原本状态的参数，最后回传一个新的状态，再继续执行。</p><p>所以这段代码是这样执行的：</p><ul><li>第一次执行 <code>callback</code> 起始状态是 <code>0</code>，所以 <code>origin</code> 传入 <code>0</code>，<code>next</code> 为 <code>arr</code> 的第一个元素 <code>1</code>，相加之后变成 <code>1</code> 回传并当做下一次的状态。</li><li>第二次执行 <code>callback</code>，这时原本的状态 (<code>origin</code>) 就变成了 <code>1</code>，<code>next</code> 为 <code>arr</code> 的第二个元素 <code>2</code>，相加之后变成 <code>3</code> 回传并当做下一次的状态。</li><li>第三次执行 <code>callback</code>，这时原本的状态 (<code>origin</code>) 就变成了 <code>3</code>，<code>next</code> 为 <code>arr</code> 的第三个元素 <code>3</code>，相加之后变成 <code>6</code> 回传并当做下一次的状态。</li><li>第四次执行 <code>callback</code>，这时原本的状态 (<code>origin</code>) 就变成了 <code>6</code>，<code>next</code> 为 <code>arr</code> 的第四个元素 <code>4</code>，相加之后变成 <code>10</code> 回传并当做下一次的状态。</li><li>这时 <code>arr</code> 的元素都已经遍历过了，所以不会直接把 <code>10</code> 回传。</li></ul><p><code>scan</code> 整体的运行方式都跟 <code>reduce</code> 一样，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">             .zip(Rx.Observable.interval(<span class="number">600</span>), <span class="function">(<span class="params">x, y</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.scan(<span class="function">(<span class="params">origin, next</span>) =&gt;</span> origin + next, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// he</span></span><br><span class="line"><span class="comment">// hel</span></span><br><span class="line"><span class="comment">// hell</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>画成 Marble Diagram</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : ----h----e----l----l----o|</span><br><span class="line">    scan(<span class="function">(<span class="params">origin, next</span>) =&gt;</span> origin + next, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="attr">example</span>: ----h----(he)----(hel)----(hell)----(hello)|</span><br></pre></td></tr></table></figure><p>这里可以看到第一次传入 <code>&#39;h&#39;</code> 跟 <code>&#39; &#39;</code> 相加，返回 <code>&#39;h&#39;</code> 当做下一次的初始状态，一直重复下去。</p><blockquote><p><code>scan</code> 跟 <code>reduce</code> 最大的差别就在 <code>scan</code> 一定会回传一个 Observable 实例，而 <code>reduce</code> 最后回传的值有可能是任何类型，必须看使用者传入的 <code>callback</code> 才能决定 <code>reduce</code> 最后的返回值。</p></blockquote><blockquote><p>Jafar Husain 曾说过：JavaScript 的 <code>reduce</code> 是错的，它最后应该永远回传数组才对！</p></blockquote><p><code>scan</code> 很常用在状态的计算处理，最简单的就是对一个数字的加减，我们可以绑定一个 button 的 <code>click</code> 事件，并用 <code>map</code> 把 <code>click</code> 事件转成 <code>1</code>，之后送到 <code>scan</code> 计算值再做显示。</p><p>最简单的加减示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addButton = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;addButton&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> minusButton = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;minusButton&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> state = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;state&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addClick = Rx.Observable.fromEvent(addButton, <span class="string">&#x27;click&#x27;</span>).mapTo(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> minusClick = Rx.Observable.fromEvent(minusButton, <span class="string">&#x27;click&#x27;</span>).mapTo(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberState = Rx.Observable.empty()</span><br><span class="line">  .startWith(<span class="number">0</span>)</span><br><span class="line">  .merge(addClick, minusClick)</span><br><span class="line">  .scan(<span class="function">(<span class="params">origin, next</span>) =&gt;</span> origin + next, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">numberState</span><br><span class="line">  .subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; state.innerHTML = value;&#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这里我们使用了两个 button，一个是 add 按钮，另一个是 minus 按钮。</p><p>我们把这两个按钮的点击事件各自建立了 <code>addClick</code>, <code>minusClick</code> 两个 Observable，这两个 Observable 直接 <code>mapTo(1)</code> 和 <code>map(-1)</code>，代表点击后各自送出的数字！</p><p>接着我们用 <code>empty()</code> 建立一个空的 Observable 代表画面上数字的状态，搭配 <code>startWith(0)</code> 来设定初始值，接着用 <code>merge</code> 把两个 Observable 合并通过 <code>scan</code> 处理之后的逻辑，最后在 Observable 来更改画面的显示。</p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>buffer 是一整个家族，总共有五个相关的 Operator</p><ul><li>buffer</li><li>bufferCount</li><li>bufferToggle</li><li>bufferWhen</li></ul><p>这里比较常用的是 <code>buffer</code>, <code>bufferCount</code> 跟 <code>bufferTime</code> 这三个，我们直接看示例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.buffer(source2);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0,1,2]</span></span><br><span class="line"><span class="comment">// [3,4,5]</span></span><br><span class="line"><span class="comment">// [6,7,8]...</span></span><br></pre></td></tr></table></figure><p>画成 Marble Diagrams 则像是</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source : --<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>--<span class="number">5</span>--<span class="number">6</span>--<span class="number">7.</span>.</span><br><span class="line"><span class="attr">source2</span>: ---------<span class="number">0</span>---------<span class="number">1</span>--------...</span><br><span class="line">            buffer(source2)</span><br><span class="line"><span class="attr">example</span>: ---------([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])---------([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><code>buffer</code> 要传入一个 Observable，它会把原来的 Observable 送出的元素缓存在数组中，等到传入的 Observable 送出元素时，就会触发把缓存的元素送出。</p><p>这里的示例 <code>source2</code> 是每一秒就会送出一个元素，我们可以改用 <code>bufferTime</code> 简洁表达，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.bufferTime(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0,1,2]</span></span><br><span class="line"><span class="comment">// [3,4,5]</span></span><br><span class="line"><span class="comment">// [6,7,8]...</span></span><br></pre></td></tr></table></figure><p>除了用时间来做缓存外，我们更常用数量来做缓存，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.bufferCount(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0,1,2]</span></span><br><span class="line"><span class="comment">// [3,4,5]</span></span><br><span class="line"><span class="comment">// [6,7,8]...</span></span><br></pre></td></tr></table></figure><p>在示例上，我们可以用 <code>buffer</code> 来做某个事件的过滤，例如像是滑鼠连点才能真的执行，这里我们一样写了一个小示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> click = Rx.Observable.fromEvent(button, <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> example = click</span><br><span class="line">                .bufferTime(<span class="number">500</span>)</span><br><span class="line">                .filter(<span class="function"><span class="params">arr</span> =&gt;</span> arr.length &gt;= <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们只有在 500 毫秒内连点两下，才能成功印出 <code>&#39;success&#39;</code>，这个功能在某些特殊的需求中非常好用，也能用在批次处理降低 request 传送的次数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - delay, delayWhen</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20delay,%20delayWhen/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20delay,%20delayWhen/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-delay-delayWhen"><a href="#RxJS：Operator-delay-delayWhen" class="headerlink" title="RxJS：Operator - delay, delayWhen"></a>RxJS：Operator - delay, delayWhen</h1><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p><code>delay</code> 可以延迟 Observable 一开始发送元素的时间点，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.delay(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>当然直接从 log 出来的信息来看，是完全看不出差异的。</p><p>Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : --<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>|</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line"><span class="attr">example</span>: -------<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>|</span><br></pre></td></tr></table></figure><p>从 Marble Diagrams 可以看得出来，第一次送出元素的时间变慢了，虽然在这里看起来没什么用，但是在 UI 操作上是非常有用的，这部分最后展示。</p><p><code>delay</code> 除了可以传入毫秒之外，也可以传入 <code>Date</code> 类型的变量，如下使用方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.delay(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="delayWhen"><a href="#delayWhen" class="headerlink" title="delayWhen"></a>delayWhen</h3><p><code>delayWhen</code> 的作用跟 <code>delay</code> 很像，最大的区别是 <code>delayWhen</code> 可以影响每个元素，而且需要传一个 <code>callback</code> 并回传一个 Observable，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">              .delayWhen(</span><br><span class="line">                  <span class="function"><span class="params">x</span> =&gt;</span> Rx.Observable.empty().delay(<span class="number">100</span> * x * x)</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这时我们的 Marble Diagrams 如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : --<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>|</span><br><span class="line">    .delayWhen(<span class="function"><span class="params">x</span> =&gt;</span> Rx.Observable.empty().delay(<span class="number">100</span> * x * x));</span><br><span class="line">example: --<span class="number">0</span>---<span class="number">1</span>----<span class="number">2</span>-----<span class="number">3</span>-----<span class="number">4</span>|</span><br></pre></td></tr></table></figure><p>这里传进来的 <code>x</code> 就是 <code>source</code> 送出的每个元素，这样我们就能对每一个做延迟。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - skip, takeLast, last, concat, startWith, merge</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20skip,%20takeLast,%20last,%20concat,%20startWith,%20merge/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20skip,%20takeLast,%20last,%20concat,%20startWith,%20merge/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-skip-takeLast-last-concat-startWith-merge"><a href="#RxJS：Operator-skip-takeLast-last-concat-startWith-merge" class="headerlink" title="RxJS：Operator - skip, takeLast, last, concat, startWith, merge"></a>RxJS：Operator - skip, takeLast, last, concat, startWith, merge</h1><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.skip(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5...</span></span><br></pre></td></tr></table></figure><p>原本从 0 开始的就会变成 3 开始，但是记得原本元素的等待时间仍然存在，也就是说此示例第一个取得的元素需要等待 4 秒，用 Marble Diagrams 表示如下。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>----<span class="number">5</span>--....</span><br><span class="line">                    skip(<span class="number">3</span>)</span><br><span class="line"><span class="attr">example</span>: -------------------<span class="number">3</span>----<span class="number">4</span>----<span class="number">5</span>--...</span><br></pre></td></tr></table></figure><h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h3><p>除了可以用 take 取前几个之外，我们也可以倒过来取最后几个，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.takeLast(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>这里我们先取了前 6 个元素，再取最后 2 个。所以最后会发送 4、5 complete，这里有一个重点，就是 <code>takeLast</code> 必须等到整个 Observable 完成，才知道最后的元素有哪些，并且 <strong>同步发送</strong>，如果用 Marble Diagrams 表示如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>----<span class="number">5</span>|</span><br><span class="line">                takeLast(<span class="number">2</span>)</span><br><span class="line"><span class="attr">example</span>: ------------------------------(<span class="number">45</span>)|</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>takeLast</code> 后，必须等到原来的 Observable 完成后，才立即同步发送 4、5、complete。</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>跟 <code>take(1)</code> 相同，我们有一个 <code>takeLast(1)</code> 的简化写法，那就是 <code>last(1)</code> 用来取得最后一个元素。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.last();</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>用 Marble Diagrams 表示如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>----<span class="number">5</span>|</span><br><span class="line">                    last()</span><br><span class="line"><span class="attr">example</span>: ------------------------------(<span class="number">5</span>)|</span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code>concat</code> 可以把多个 Observable 实例合并成一个，示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.of(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> source3 = Rx.Observable.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">var</span> example = source.concat(source2, source3);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>和 <code>concatAll</code> 一样，必须等到前一个 Observable 完成，才会继续下一个，用 Marble Diagrams 表示如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>|</span><br><span class="line">source2: (<span class="number">3</span>)|</span><br><span class="line">source3: (<span class="number">456</span>)|</span><br><span class="line">            concat()</span><br><span class="line"><span class="attr">example</span>: ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>(<span class="number">3456</span>)|</span><br></pre></td></tr></table></figure><p>另外 <code>concat</code> 还可以当做静态方法来使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.of(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> source3 = Rx.Observable.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> example = Rx.Observable.concat(source, source2, source3);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h3><p><code>startWith</code> 可以在 Observable 的一开始塞要发送的元素，有点像 <code>concat</code> 但参数不是 Observable 而是要发送的元素，使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.startWith(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3...</span></span><br></pre></td></tr></table></figure><p>这里可以看到我们在 source 的一开始塞了一个 <code>0</code>，让 example 会在一开始就立即发送 <code>0</code>，用 Marble Diagrams 表示如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>--...</span><br><span class="line">                startWith(<span class="number">0</span>)</span><br><span class="line"><span class="attr">example</span>: (<span class="number">0</span>)----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>--...</span><br></pre></td></tr></table></figure><p>记得 <code>startWith</code> 的值是一开始就同步发出的，这个 Operator 很常被用来保存程序的起始状态。</p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><code>merge</code> 跟 <code>concat</code> 一样都是用来合并 Observable，但他们行为上有非常大的不同</p><p>直接看例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.merge(source2);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>上面可以看得出来，<code>merge</code> 把多个 Observable 同时处理，这跟 <code>concat</code> 一次处理一个 Observable 是完全不一样的，由于是同时处理行为会变得较为复杂，这里我们用 Marble Diagrams 会比较好解释。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source : ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>|</span><br><span class="line">source2: --<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>--<span class="number">5</span>|</span><br><span class="line">            merge()</span><br><span class="line"><span class="attr">example</span>: --<span class="number">0</span>-<span class="number">01</span>--<span class="number">21</span>-<span class="number">3</span>--(<span class="number">24</span>)--<span class="number">5</span>|</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>merge</code> 之后的 example 在时间序上同时跑 source 与 source2，当两件事情同时发生时，会同步发送资料，当两个 Observable 都结束时才会真正结束。</p><p><code>merge</code> 同样也可以当做静态方法用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> example = Rx.Observable.merge(source, source2);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>merge</code> 的逻辑有点像是 OR (||)，就当做两个 Observable 其中一个被处罚时都可以被处理，这很常用在一个以上的按钮具有部分相同的行为。</p><p>例如一个影片播放器，一个是暂停 (||)，另一个是结束播放。这两个俺妞妞都具有相同的行为就是影片会被停止，只是结束播放会让影片回到 00 秒，这时我们就可以把这两个按钮的事件 merge 起来处理影片暂停这件事。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stopVideo = Rx.Observable.merge(stopButton, endButton);</span><br><span class="line"></span><br><span class="line">stopVideo.subscribe(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 暂停播放影片</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - switch, mergeAll, concatAll</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20switch,%20mergeAll,%20concatAll/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20switch,%20mergeAll,%20concatAll/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-switch-mergeAll-concatAll"><a href="#RxJS：Operator-switch-mergeAll-concatAll" class="headerlink" title="RxJS：Operator - switch, mergeAll, concatAll"></a>RxJS：Operator - switch, mergeAll, concatAll</h1><p>本文讲解的三个 Operator 都是用来处理 Higher Order Observable。所谓的 Higher Order Observable 就是指一个 Observable 送出的元素还是一个 Observable，就像是二维数组一样，一个数组中的每个元素都是数组。如果用泛型来表达就像是</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Observable&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>通常我们需要的是第二层 Observable 送出的元素，所以我们希望可以把二位的 Observable 改成一维的，像是下面这样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Observable&lt;T&gt;&gt; =&gt; Observable&lt;T&gt;</span><br></pre></td></tr></table></figure><p>其实想要做到这件事有三个方法 <code>switch</code>、<code>mergeAll</code>、<code>concatAll</code>，其中 <code>concatAll</code> 我们在之前的文章已经稍微讲过了，今天这篇文章会讲解这三个 Operator 各自的效果和差异。</p><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="concatAll"><a href="#concatAll" class="headerlink" title="concatAll"></a>concatAll</h3><p><code>concatAll</code> 最重要的重点是他处理完前一个 Observable 才会再处理下一个 Observable，直接看示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.concatAll();</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// (点击后)</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5 ...</span></span><br></pre></td></tr></table></figure><p>上面这段代码，当我们点击画面就会开始送出数值，对应 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click  : ---------c-c------------------c--.. </span><br><span class="line">        map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>))</span><br><span class="line"><span class="attr">source</span> : ---------o-o------------------o--..</span><br><span class="line">                   \ \</span><br><span class="line">                    \ ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>--...</span><br><span class="line">                     ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>--...</span><br><span class="line">                     concatAll()</span><br><span class="line"><span class="attr">example</span>: ----------------<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>--..</span><br></pre></td></tr></table></figure><p>从 Marble Diagrams 可以看出，当我们点击一下 <code>click</code> 事件就会被转成一个 Observable 而这个 Observable 会每一秒送出一个递增的数值，当我们用 <code>concat</code> 之后会把二维的 Observable 摊平成一维的 Observable，但 <code>concatAll</code> 会一个一个处理，一定是等前一个 Observable 完成才会处理下一个 Observable，因为现在送出 Observable 是无限的永远不会完成，就导致他永远不会处理第二个送出的 Observable。</p><p>再看一个例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.concatAll();</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们把送出的 Observable 变成有限的，只会送出三个元素，这时就能看得出来 <code>concatAll</code> 不管两个 Observable 送出的时间多么相近，一定会先处理前一个 Observable 再处理下一个。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><code>switch</code> 同样能把二维的 Observable 摊平成一维的，但他们在行为上有很大的不同，我们看以下示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.switch();</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应的 Marble Diagrams 如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click  : ---------c-c------------------c--.. </span><br><span class="line">        map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>))</span><br><span class="line"><span class="attr">source</span> : ---------o-o------------------o--..</span><br><span class="line">                   \ \                  \----<span class="number">0</span>----<span class="number">1</span>--...</span><br><span class="line">                    \ ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>--...</span><br><span class="line">                     ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>--...</span><br><span class="line">                     <span class="keyword">switch</span>()</span><br><span class="line"><span class="attr">example</span>: -----------------<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>--------<span class="number">0</span>----<span class="number">1</span>--...</span><br></pre></td></tr></table></figure><p><code>switch</code> 最重要的就是他会在新的 Observable 送出后直接处理新的 Observable 不管前一个 Observable 是否完成，每当有新的 Observable 送出就会直接把旧的 Observable 退订 (unsubscribe)，永远只处理最新的 Observable。</p><p>所以在这上面的 Marble Diagrams 可以看得出来第一次送出的 Observable 跟 第二次送出的 Observable 时间点太相近了，导致第一个 Observable 还来不及送出元素就直接退订了，当下一次 Observable 就又把前一次的 Observable 退订了。</p><h3 id="mergeAll"><a href="#mergeAll" class="headerlink" title="mergeAll"></a>mergeAll</h3><p>我们之前讲过 <code>mergeAll</code> 他可以让多个 Observable 同时送出元素，<code>mergeAll</code> 也是同样的道理，它会把二维的 Observable 转成一维的，并且能够同时处理所有的 Observable，看看这个示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.mergeAll();</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应的 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click  : ---------c-c------------------c--.. </span><br><span class="line">        map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>))</span><br><span class="line"><span class="attr">source</span> : ---------o-o------------------o--..</span><br><span class="line">                   \ \                  \----<span class="number">0</span>----<span class="number">1</span>--...</span><br><span class="line">                    \ ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>--...</span><br><span class="line">                     ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>----<span class="number">3</span>----<span class="number">4</span>--...</span><br><span class="line">                     <span class="keyword">switch</span>()</span><br><span class="line"><span class="attr">example</span>: ----------------<span class="number">00</span>---<span class="number">11</span>---<span class="number">22</span>---<span class="number">33</span>---(<span class="number">04</span>)<span class="number">4</span>--...</span><br></pre></td></tr></table></figure><p>从 Marble Diagrams 可以看出，所有的 Observable 是并行处理的，也就是 <code>mergeAll</code> 不会像 <code>switch</code> 一样退订原先的 Observable，而是并行处理多个 Observable。以我们的示例来说，当我们点击越多下，最后送出的频率就会越快。</p><p>另外 <code>mergeAll</code> 可以传入一个数值，这个数值代表他可以同时处理的 Observable 数量，看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.mergeAll(<span class="number">2</span>);</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们送出的 Observable 改成取前三个，并且让 <code>mergeAll</code> 最多只能同时处理 2 个Observable，对应的 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click  : ---------c-c----------o----------.. </span><br><span class="line">        map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>))</span><br><span class="line"><span class="attr">source</span> : ---------o-o----------c----------..</span><br><span class="line">                   \ \          \----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>|     </span><br><span class="line">                    \ ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>|  </span><br><span class="line">                     ----<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>|</span><br><span class="line">                     mergeAll(<span class="number">2</span>)</span><br><span class="line"><span class="attr">example</span>: ----------------<span class="number">00</span>---<span class="number">11</span>---<span class="number">22</span>---<span class="number">0</span>----<span class="number">1</span>----<span class="number">2</span>--..</span><br></pre></td></tr></table></figure><p>当 <code>mergeAll</code> 传入参数后，就会等处理中的其中一个 Observable 完成，再去处理下一个。以我们的例子来说，前面两个 Observable 可以被并行处理，但第三个 Observable 必须等到第一个 Observable 结束后，才会开始。</p><p>我们可以利用这个参数来决定要同时处理几个 Observable，如果我们传入 <code>1</code> 其行为就会跟 <code>concatAll</code> 是一模一样，这点在源码可以看到他们是完全相同的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - switchMap, mergeMap, concatMap</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20switchMap,%20mergeMap,%20concatMap/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20switchMap,%20mergeMap,%20concatMap/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-switchMap-mergeMap-concatMap"><a href="#RxJS：Operator-switchMap-mergeMap-concatMap" class="headerlink" title="RxJS：Operator - switchMap, mergeMap, concatMap"></a>RxJS：Operator - switchMap, mergeMap, concatMap</h1><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h3><p><code>concatMap</code> 其实就是 <code>map</code> 加上 <code>concatAll</code> 的简化写法，直接看一个例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>))</span><br><span class="line">                .concatAll();</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面这个示例可以简化成</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .concatMap(</span><br><span class="line">                    <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>前后两个行为是一致的，<code>concatMap</code> 也会先处理前一个送出的 Observable 在处理下一个 Observable，对应 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : -----------c--c------------------...</span><br><span class="line">        concatMap(<span class="function"><span class="params">c</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>))</span><br><span class="line"><span class="attr">example</span>: -------------<span class="number">0</span>-<span class="number">1</span>-<span class="number">2</span>-<span class="number">0</span>-<span class="number">1</span>-<span class="number">2</span>---------...</span><br></pre></td></tr></table></figure><p>这样的行为也很常被用在发送 request 如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPostData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.concatMap(</span><br><span class="line">                    <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.from(getPostData()));</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们每点击一下画面就会送出一个 HTTP request，如果我们快速的连续点击，大家可以在开发者工具的 network 看到每个 request 是等到前一个 request 完成才会送出下一个 request，如下图</p><p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/wd5oo0.jpg" alt="alt"></p><p>从 network 的图形可以看得出来，第二个 request 的发送时间是接在第一个 request 之后的，我们可以确保每一个 request 会等前一个 request 完成才做处理。</p><p><code>concatMap</code> 还有第二个参数是一个 <code>selector callback</code>，这个 <code>callback</code> 会传入四个参数，分别是</p><ul><li>外部 Observable 送出的元素</li><li>内部 Observable 送出的元素</li><li>外部 Observable 送出元素的 index</li><li>内部 Observable 送出元素的 index</li></ul><p>回传我们想要的值，示例如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPostData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.concatMap(</span><br><span class="line">                <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.from(getPostData()), </span><br><span class="line">                <span class="function">(<span class="params">e, res, eIndex, resIndex</span>) =&gt;</span> res.title);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个示例的外部 Observable 送出的元素就是 <code>click event</code> 实例，内部 Observable 送出的元素就是 <code>response</code> 实例，这里我们回传 <code>response</code> 实例的 <code>title</code> 属性，这样一来我们就可以直接收到 <code>title</code>，这个方法很适合用在 <code>response</code> 要选取的值跟前一个事件或顺位相关。</p><h3 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h3><p><code>switchMap</code> 其实就是 <code>map</code> 加上 <code>switch</code> 简化的写法，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>))</span><br><span class="line">                .switch();</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码可以简化成</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .switchMap(</span><br><span class="line">                    <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应的 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : -----------c--c-----------------...</span><br><span class="line">        concatMap(<span class="function"><span class="params">c</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>))</span><br><span class="line"><span class="attr">example</span>: -------------<span class="number">0</span>--<span class="number">0</span>-<span class="number">1</span>-<span class="number">2</span>-----------...</span><br></pre></td></tr></table></figure><p>只要注意一个重点 <code>switchMap</code> 会在下一个 Observable 被送出后直接退订前一个未完成的 Observable。</p><p>另外我们也可以把 <code>switchMap</code> 用在发送 HTTP request。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPostData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.switchMap(</span><br><span class="line">                    <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.from(getPostData()));</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们快速的连续点击 5 下，可以在开发者工具的 network 看到每个 request 会在点击时发送，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/4MdIAL.jpg" alt="alt"></p><blockquote><p>灰色是浏览器原生的停顿行为，实际上灰色的一开始就是 <code>fetch</code> 执行送出 request，只是卡在浏览器等待发送。</p></blockquote><p>从上图可以看到，虽然我们发送了多个 request 但最后真正印出来的 <code>log</code> 只会有一个，代表前面发送的 request 已经不会造成任何的 side-effect 了，这个很适合用在只看最后一次 request 的情景，比如说 自动完成 (Auto Complete)，我们只需要显示使用者最后一次打在画面上的文字，来做建议选项而不用每一次的。</p><p><code>switchMap</code> 和 <code>concatMap</code> 一样有第二个参数 <code>selector callback</code> 可用来回传我们想要的值，这部分的行为跟 <code>concatMap</code> 是一样的。</p><h3 id="mergeMap"><a href="#mergeMap" class="headerlink" title="mergeMap"></a>mergeMap</h3><p><code>mergeMap</code> 其实就是 <code>map</code> 加上 <code>mergeAll</code> 简化的写法，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>))</span><br><span class="line">                .mergeAll();</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码可以简化成</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .mergeMap(</span><br><span class="line">                    <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应 Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : -----------c-c------------------...</span><br><span class="line">        concatMap(<span class="function"><span class="params">c</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>))</span><br><span class="line"><span class="attr">example</span>: -------------<span class="number">0</span>-(<span class="number">10</span>)-(<span class="number">21</span>)-<span class="number">2</span>----------...</span><br></pre></td></tr></table></figure><p><code>mergeMap</code> 可以并行处理多个 Observable，以这个例子来讲当我们快速点按 2 下，元素发送的时间点是有机会重叠的，这个部分的细节大家可以看上一篇文章 <code>merge</code> 部分。</p><p>另外也可以把 <code>switchMap</code> 用在发送 HTTP request</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPostData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.mergeMap(</span><br><span class="line">                    <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.from(getPostData()));</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们快速的连续点击 5 下，大家可以在开发者工具的 network 看到每个 request 会在点击时发送并且会 <code>log</code> 出 5 个实例，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/ohyqkB.jpg" alt="alt"></p><p><code>mergeMap</code> 也能传入第二个参数 <code>selector callback</code>，这个 <code>selector callback</code> 跟 <code>concatMap</code> 第二个参数也是完全一致的，但 <code>mergeMap</code> 的重点我们可以传入第三个参数，来限制并行处理的数量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPostData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.mergeMap(</span><br><span class="line">                <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.from(getPostData()), </span><br><span class="line">                <span class="function">(<span class="params">e, res, eIndex, resIndex</span>) =&gt;</span> res.title, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们传入 3 就能限制，HTTP request 最多只能同时送出 3 个，并且要等其中一个完成再处理下一个，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/fonvDO.jpg" alt="alt"></p><p>可以注意一下这张图，连续点了 5 下，但第四个 request 是在第一个完成之后才送出，这个适合在特殊的需求下，可以限制同时发送 request 的数量</p><blockquote><p>RxJS 还保留了 <code>mergeMap</code> 的别名叫 <code>flatMap</code>，虽然官方文档上没有，但这两个方法是完全一致的</p></blockquote><h3 id="switchMap-mergeMap-concatMap"><a href="#switchMap-mergeMap-concatMap" class="headerlink" title="switchMap, mergeMap,  concatMap"></a>switchMap, mergeMap,  concatMap</h3><p>这三个 Operator 还有一个共同的特性，那就是这三个 Operator 可以把第一个参数所回传的 <code>Promise</code> 实例直接转成 Observable，这样我们就不用再用 <code>Rx.Observable.from</code> 转一次，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.concatMap(<span class="function"><span class="params">e</span> =&gt;</span> getPersonData());</span><br><span class="line">                                    <span class="comment">//直接回传 promise 实例</span></span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至于在上面如何选择三个 Operator？其实还是要看具体使用情景而定，这里简单列一下大部分的使用场景</p><ul><li><code>concatMap</code> 用在可以确定内部的 Observable 结束时间比外部 Observable 发送时间快的情景，并且不希望有任何并行处理行为，适合少数要一次一次完成到底的 UI 动画或特别的 HTTP request 行为。</li><li><code>switchMap</code> 用在只要最后一次行为的结果，适合绝大多数的使用情景。</li><li><code>mergeMap</code> 用在并行处理多个 Observable，适合需要并行处理的行为，像是多个 I/O 的并行处理。</li></ul><blockquote><p>不确定选择哪一种时，使用 <code>switchMap</code></p></blockquote><blockquote><p>在使用 <code>concatAll</code> 或 <code>concatMap</code> 时，请注意内部的 Observable 一定要能够结束，且外部的 Observable 发送元素的速度不能俾内部的 Observable 结束时间快太多，不然会有内存问题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：Operator - throttle, debounce</title>
      <link href="/2021/07/07/RxJS%EF%BC%9AOperator%20-%20throttle,%20debounce/"/>
      <url>/2021/07/07/RxJS%EF%BC%9AOperator%20-%20throttle,%20debounce/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：Operator-throttle-debounce"><a href="#RxJS：Operator-throttle-debounce" class="headerlink" title="RxJS：Operator - throttle, debounce"></a>RxJS：Operator - throttle, debounce</h1><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><p>跟 <code>buffer</code>，<code>bufferTime</code> 一样，Rx 有 <code>debounce</code> 跟 <code>debounceTime</code> 一个是传入 Observable，另一个则是传入毫秒，比较常用到的是 <code>debounceTime</code>，直接看一个示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.debounceTime(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>这里只印出了 <code>4</code> 然后就结束了，因为 <code>debounce</code> 运行的方式是每次收到元素，会先把元素 cache 住并等待一段时间，如果这段时间内没有收到任何元素，则把元素送出；如果这段时间内又收到新的元素，则会把原本 cache 住的元素释放掉并重新计时，不断重复。</p><p>以现在这个示例来说，我们每 300 毫秒就会送出一个数值，但我们的 <code>debounceTime</code> 是 1000 毫秒，也就是说每次 <code>debounce</code> 收到元素还等不到 1000 毫秒，就会收到下一个新元素，然后重新等待 1000 毫秒，如此重复知道第五个元素送出时，Observable 结束了。</p><p>Marble Diagrams</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source : --<span class="number">0</span>--<span class="number">1</span>--<span class="number">2</span>--<span class="number">3</span>--<span class="number">4</span>|</span><br><span class="line">        debounceTime(<span class="number">1000</span>)</span><br><span class="line"><span class="attr">example</span>: --------------<span class="number">4</span>|        </span><br></pre></td></tr></table></figure><p><code>debounce</code> 会在收到元素后等待一段时间，很适合用来处理间歇行为，间歇行为就是指这个行为是一段一段的，例如要做 Auto Complete 时，我们要打字搜寻不会一直不断打字，可以等我们听了一小段时间再送出，才不会每打一个字就送出一次 request！</p><p>例子，假设我们想要自动传送使用者打的字到后端</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;searchInput&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> theRequestValue = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;theRequestValue&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Rx.Observable.fromEvent(searchInput, <span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    theRequestValue.textContent = value;</span><br><span class="line">    <span class="comment">// 在这里发 request</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>如果用上面这段代码，就会每打一个字就送一次 request，当很多人在使用时就会对 server 造成很大的负担，实际上我们只需要使用者最后打出来的问题就好了，不用每次都送，这时就能用 <code>debounceTime</code> 做优化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;searchInput&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> theRequestValue = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;theRequestValue&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Rx.Observable.fromEvent(searchInput, <span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .debounceTime(<span class="number">300</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    theRequestValue.textContent = value;</span><br><span class="line">    <span class="comment">// 在这里发 request</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>基本上每次看到 <code>debounce</code> 就会看到 <code>throttle</code>，他们两个的作用都是降低事件的触发频率，但行为上有很大的不同。</p><p>跟 <code>debounce</code> 一样 Rx 有 <code>throttle</code> 跟 <code>throttleTime</code> 两个方法，一个是传入 Observable，另一个是传入毫秒，比较常用到的也是 <code>throttleTime</code>，直接看示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.throttleTime(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>跟 <code>debounce</code> 的不同是 <code>throttle</code> 会先开放送出元素，等到有元素被送出就会沉默一段时间，等到时间过了又会开放发送元素。</p><p><code>throttle</code> 比较像是控制行为的最高频率，也就是说如果我们设定 1000 毫秒，那该事件频率的最大值就是每秒触发一次，不会再更快，<code>debounce</code> 则比较像是必须等待的时间，要等到一定的时间过了才会收到元素。</p><p><code>throttle</code> 更适合用在连续性行为，比如说 UI 动画的运算过程，因为 UI 动画是连续的，像我们之前在做拖拉时，就可以加上 <code>throttleTime(12)</code> 让 <code>mousemove</code> 事件不要发送得太快，避免画面更新的速度跟不上样式的切换速度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：如何使用 RxJS 实现高效的 HTTP 请求</title>
      <link href="/2021/07/07/RxJS%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20RxJS%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84%20HTTP%20%E8%AF%B7%E6%B1%82/"/>
      <url>/2021/07/07/RxJS%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20RxJS%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84%20HTTP%20%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：如何使用-RxJS-实现高效的-HTTP-请求"><a href="#RxJS：如何使用-RxJS-实现高效的-HTTP-请求" class="headerlink" title="RxJS：如何使用 RxJS 实现高效的 HTTP 请求"></a>RxJS：如何使用 RxJS 实现高效的 HTTP 请求</h1><p>在项目中，经常碰到这样的需求：用户在输入框输入数据，需要实时调用后端 API，拿到结果显示在页面上。如果用传统方式一般实现方式是在输入框上绑定一个 <code>keydown</code> 或者 <code>keyup</code> 事件，然后每次输入值以后都调用一次后端 API，拿到返回数据。这样会有一个问题，比如我们输入 ‘liujiahao’，<code>l</code> <code>li</code> <code>liu</code> <code>liuj</code> <code>liuji</code> <code>liujia</code> <code>liujiah</code> <code>liujiaha</code> <code>liujiahao</code> 这五次会分别调用一次 API。这样就会有五个 Response，但是这个五个 Response 的顺序是不可控的，可能最后返回的是 <code>liu</code> 的结果，这种方法不仅效率低下，而且没有办法保证正确性。</p><p>这篇文章会介绍如何在 RxJS 中结合操作符 <code>debounceTime</code> <code>map</code> <code>filter</code> <code>distinctUtilChanged</code> 和 <code>switchMap</code> 实现：输入完 ‘liujiahao’ 之后只调用一次 API，最后拿到这个 API 返回的输入显示在页面上。</p><p>我们来实现一个搜索 Github 用户的功能，页面上有一个输入框，在输入框中输入 Github 用户名，然后将搜索结果显示在页面上：</p><p>我们先来定义一个 Service 如下：</p><p>实例代码用的是 Angular + RxJS：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsSearchableInputService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">searchUser</span>(<span class="params">val: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;Observable&lt;SearchResult&gt;&gt;(<span class="string">&quot;https://api.github.com/search/users?q=&quot;</span> + val)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">response</span> =&gt;</span> response),</span><br><span class="line">                catchError(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong, &quot;</span> + error);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 component 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsSearchableInputComponent</span> <span class="title">implements</span> <span class="title">OnInit</span>, <span class="title">OnDestroy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">users</span>: <span class="built_in">Array</span>&lt;User&gt; = [];</span><br><span class="line">    onSearchUser$ = <span class="keyword">new</span> Subject&lt;KeyboardEvent&gt;();</span><br><span class="line"></span><br><span class="line">    validSearch$: Observable&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">    emptySearch$: Observable&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line">    subscription: Subscription;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> rxjsSearchableInputService: RxjsSearchableInputService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.validSearch$ = <span class="built_in">this</span>.onSearchUser$</span><br><span class="line">            .pipe(</span><br><span class="line">                debounceTime(<span class="number">1000</span>),</span><br><span class="line">                map(<span class="function"><span class="params">event</span> =&gt;</span> (&lt;HTMLInputElement&gt;event.target).value),</span><br><span class="line">                distinctUntilChanged(),</span><br><span class="line">                filter(<span class="function"><span class="params">input</span> =&gt;</span> input !== <span class="string">&quot;&quot;</span>),</span><br><span class="line">                switchMap(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">this</span>.rxjsSearchableInputService.searchUser(data))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.emptySearch$ = <span class="built_in">this</span>.onSearchUser$.pipe(</span><br><span class="line">            debounceTime(<span class="number">1000</span>),</span><br><span class="line">            map(<span class="function"><span class="params">event</span> =&gt;</span> (&lt;HTMLInputElement&gt;event.target).value),</span><br><span class="line">            filter(<span class="function"><span class="params">input</span> =&gt;</span> input === <span class="string">&quot;&quot;</span>),</span><br><span class="line">            switchMap(<span class="function"><span class="params">data</span> =&gt;</span> <span class="keyword">of</span>([]))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.subscription = merge(<span class="built_in">this</span>.validSearch$, <span class="built_in">this</span>.emptySearch$)</span><br><span class="line">            .subscribe(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (resp &amp;&amp; resp.items &amp;&amp; resp.items.length) &#123;</span><br><span class="line">                    <span class="keyword">let</span> result = resp <span class="keyword">as</span> SearchResult;</span><br><span class="line">                    <span class="built_in">this</span>.users = result.items;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.users = [];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngOnDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subscription.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>component 对应的 html 文件如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;margin-large&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-flex margin-small&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;margin-right-small&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span> Search Github user: <span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> (<span class="attr">keyup</span>)=<span class="string">&quot;onSearchUser$.next($event)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin: 20px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-flex&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font: 0.9em;width:20%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name: <span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font:0.9em;width:10%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>ID: <span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font:0.9em;width:30%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL: <span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;!users.length&quot;</span> <span class="attr">class</span>=<span class="string">&quot;margin-small&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>no search result!<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 component 中先定义一个名为 <code>onSearchUser$</code> 的 <code>Subject</code>，然后在 input 上绑定一个 <code>keyup</code> 事件 <code>(keyup)=&quot;onSearchUser$.next($event)&quot;</code>，每次输入框输入有变化的时候，<code>onSearchUser$</code> 都会发送当前输入框的值。</p><p>然后在 component 中定义两个 <code>Observable</code> ：<code>validSearch$</code> 和 <code>emptySearch$</code>，<code>validSearch$</code> 是每隔 1 秒拿到 <code>input</code> 框中的非空值，并且是本次拿到的值和上次的值不一样的情况下调用对应 API 把搜索结果显示在页面上。<code>emptySearch$</code> 是每隔 1 秒拿到 <code>input</code> 框中的空值，并不调用 API，直接返回一个空的用户列表。在 <code>validSearch$</code> 中用 <code>switchMap</code> 的原因是：本次调用 API 的时候，上一次的 API 如果还没有返回，<code>switchMap</code> 会取消上一次的 API，这样就可以保证每次 API 返回的结果是正确的。</p><p>最后再用 <code>merge</code> 把 <code>emptySearch$</code>，<code>validSearch$</code> 两个 <code>Observable</code> 合并。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：如何通过 RxJS 实现缓存</title>
      <link href="/2021/07/07/RxJS%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%20RxJS%20%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98/"/>
      <url>/2021/07/07/RxJS%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%20RxJS%20%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：如何通过-RxJS-实现缓存"><a href="#RxJS：如何通过-RxJS-实现缓存" class="headerlink" title="RxJS：如何通过 RxJS 实现缓存"></a>RxJS：如何通过 RxJS 实现缓存</h1><ul><li>Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Cold Observable。</li><li>HttpClient Observable 每次被订阅都需要调用 http request，对于共用的 API 返回同样的值，在不同页面重复调用会浪费 http 资源降低性能。</li><li>如何通过 ReplaySubject 实现缓存效果，提高性能。</li></ul><h2 id="HttpClient-返回的-Observables-是-Cold-Observable"><a href="#HttpClient-返回的-Observables-是-Cold-Observable" class="headerlink" title="HttpClient 返回的 Observables 是 Cold Observable"></a>HttpClient 返回的 Observables 是 Cold Observable</h2><p>在 Angular 2.0 以上的版本，都是通过 HttpClient 跟后端 API 交互；所有的 Http 请求方法，比如 get、post、put、delete 都是返回一个 Observable。之前介绍了 Cold Observable 与 Hot Observable 的区别。</p><p>那么在 Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Hot Observables 还是 Cold Observables？先写一段代码测试一下，在页面中显示 30 个 GitHub user 的基本信息：</p><p>先定义一个 service：RxjsCacheService，在这个 service 中定义一个方法去拿 github 的用户信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/common/http&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;../interface/rxjs-cache.interface&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map, catchError &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">of</span>, Observable &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsCacheService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">users</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.requestUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">requestUsers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// get the latest 30 github users: start from id =2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;(<span class="string">&quot;https://api.github.com/users?since=1&quot;</span>)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">respone</span> =&gt;</span> respone),</span><br><span class="line">                catchError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong &quot;</span> + error)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口 rxjs-cache.interface 定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface User &#123;</span><br><span class="line">    <span class="attr">login</span>: string,</span><br><span class="line">    <span class="attr">id</span>: number,</span><br><span class="line">    <span class="attr">node_id</span>: string,</span><br><span class="line">    <span class="attr">avatar_url</span>: string,</span><br><span class="line">    <span class="attr">gravatar_id</span>: string,</span><br><span class="line">    <span class="attr">url</span>: string,</span><br><span class="line">    <span class="attr">html_url</span>: string,</span><br><span class="line">    <span class="attr">followers_url</span>: string,</span><br><span class="line">    <span class="attr">following_url</span>: string,</span><br><span class="line">    <span class="attr">gists_url</span>: string,</span><br><span class="line">    <span class="attr">starred_url</span>: string,</span><br><span class="line">    <span class="attr">subscriptions_url</span>: string,</span><br><span class="line">    <span class="attr">organizations_url</span>: string,</span><br><span class="line">    <span class="attr">repos_url</span>: string,</span><br><span class="line">    <span class="attr">events_url</span>: string,</span><br><span class="line">    <span class="attr">received_events_url</span>: string,</span><br><span class="line">    <span class="attr">type</span>: string,</span><br><span class="line">    <span class="attr">site_admin</span>: boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个 component：RxjsCacheComponent，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; RxjsCacheService &#125; <span class="keyword">from</span> <span class="string">&quot;./service/rxjs-cache.service&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;./interface/rxjs-cache.interface&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    <span class="attr">templateUrl</span>: <span class="string">&quot;./rxjs-cache.component.html&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsCacheComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private users$: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private rxjsCacheService: RxjsCacheService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users$ = <span class="built_in">this</span>.rxjsCacheService.users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rxjs-cache.component.html 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>here is the github user lists:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; display: flex;flex-direction: row;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 10%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 50%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行以上代码，在页面上列出了 30 位 Github 用户的用户名和相对应的 Github 地址，从上面的代码还是不能看出 HttpClient 返回的 Observable 是 Hot Observables 还是 Cold Observables。我们把 html 代码改一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>here is the github user lists:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; display: flex;flex-direction: row;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 10%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 50%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>here is the github user lists2:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; display: flex;flex-direction: row;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 10%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 50%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>F12 打开浏览器的 DevTools，当前页面会调用两次 GET API，并且两个 user list 列出的 30 位用户的信息一模一样：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/scNswE.jpg" alt="alt"></p><p>两个 userList 订阅 users$，生成了两个 Observable 实例并且都是订阅开始之后才开始发送值，<em><strong>也就是说 Angular 中通过 HttpClient 执行 Http Request 返回的 Observable 是 Cold Observable</strong></em>。</p><h2 id="性能问题？"><a href="#性能问题？" class="headerlink" title="性能问题？"></a>性能问题？</h2><p>每次调用 API ，都会生成一个新的 Observable 实例，有订阅之后才开始发送值，这也符合现在前端的开发需求。但在实际开发过程中，有时候后端会提供一些公用的常量 API，不同页面都需要用这些常量，按现在的调用 API 的方式，会导致常量 API 在不同的页面重复多次调用，这种方式显然性能不好。</p><h2 id="通过-RxJS-实现缓存效果"><a href="#通过-RxJS-实现缓存效果" class="headerlink" title="通过 RxJS 实现缓存效果"></a>通过 RxJS 实现缓存效果</h2><p>ReplaySubject(size) 可以发送之前的旧值给新的订阅者，size 是定义发送具体多少个旧值给新的订阅者。那么在示例代码中可以用 ReplaySubject 实现缓存效果。</p><p>shareReplay 这个操作符会自动创建一个 ReplaySubject，一旦 http request 执行一次以后，就会在后续的订阅和源头 Observable 之间建立一个 ReplaySubject，ReplaySubject 是一个多播的 Hot Observable，后续订阅都是从这个中间的 ReplaySubject 拿到最后一个值，从而达到缓存效果。</p><p>我们把 RxjsCacheService 改成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/common/http&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;../interface/rxjs-cache.interface&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map, catchError, shareReplay &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">of</span>, Observable &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CACHE_SIZE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsCacheService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private cacheUsers$:Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">users</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.cacheUsers$)&#123;</span><br><span class="line">            <span class="built_in">this</span>.cacheUsers$ = <span class="built_in">this</span>.requestUsers()</span><br><span class="line">            .pipe(</span><br><span class="line">                shareReplay(CACHE_SIZE)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.cacheUsers$;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">requestUsers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;(<span class="string">&quot;https://api.github.com/users?since=1&quot;</span>)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">respone</span> =&gt;</span> respone),</span><br><span class="line">                catchError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong &quot;</span> + error)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码发现，页面里两个 user list 都是列出了相同的30位 Github 用户信息，但是只调用了一次 GET API，也就是说第二订阅不是从通过后端 API 拿到用户信息，而是从 ReplaySubject 中拿到的。</p><p>整个流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/icGsXB.jpg" alt="alt"></p><p>页面的第一个 userlist 也就是第一个 consumer，是通过调用API拿到30个用户信息，第二个 userlist 也就是第二个 consumer，直接从 cacheUsers$ 拿到这30个用户信息。cacheUsers$ 是 ReplaySubject(1) 把最后一个旧值（30个用户信息）发送给新的订阅者（第二个 userlist ），从而实现了缓存效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：建立 Observable (一)</title>
      <link href="/2021/07/07/RxJS%EF%BC%9A%E5%BB%BA%E7%AB%8B%20Observable%20(%E4%B8%80)/"/>
      <url>/2021/07/07/RxJS%EF%BC%9A%E5%BB%BA%E7%AB%8B%20Observable%20(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：建立-Observable-一"><a href="#RxJS：建立-Observable-一" class="headerlink" title="RxJS：建立 Observable (一)"></a>RxJS：建立 Observable (一)</h1><h2 id="建立-Observable：create"><a href="#建立-Observable：create" class="headerlink" title="建立 Observable：create"></a>建立 Observable：<code>create</code></h2><p>建立 Observable 的方法有非常多种，其中 <code>create</code> 是最基本的方法。<code>create</code> 方法在 <code>Rx.Observable</code> 事件中，要传入一个 <code>callback function</code>，这个 <code>callback function</code> 会接收一个 <code>observer</code> 参数，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable</span><br><span class="line">.create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">observer.next(<span class="string">&#x27;Jerry&#x27;</span>); <span class="comment">// RxJS 4.x 以前的版本用 onNext</span></span><br><span class="line">observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个 <code>callback function</code> 会定义 <code>observable</code> 将如何发送值。</p><blockquote><p>虽然 <code>Observable</code> 可以被 <code>create</code>，但实际上我们通常都使用 create operator 像是 <code>from</code>, <code>of</code>, <code>fromEvent</code>, <code>fromPromise</code> 等。这里只是为了从基本的开始讲解才用 <code>create</code>。</p></blockquote><p>我们可以订阅这个 <code>observable</code>，来接收他发送的值，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable</span><br><span class="line">.create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">observer.next(<span class="string">&#x27;Jerry&#x27;</span>); <span class="comment">// RxJS 4.x 以前的版本用 onNext</span></span><br><span class="line">observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅这个 observable</span></span><br><span class="line">observable.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们订阅这个 <code>observable</code>，就会依序发送 <code>&#39;Jerry&#39;</code>, <code>&#39;Anna&#39;</code> 两个字符串。</p><blockquote><p>订阅 <code>Observable</code> 跟 <code>addEventListener</code> 在实例上其实有非常大的不同。虽然行为上很像，但实际上 <code>Observable</code> 根本没有管理一个订阅清单，最后会说明</p></blockquote><p>这里有一个重点，很多人认为，RxJS 是在做非同步处理，所以所有行为都是非同步的。但其实这个观念是错误的，RxJS 确实主要在处理非同步的行为没错，但也同时能处理同步行为，像是上面的代码就是同步执行的。</p><p>证明如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable</span><br><span class="line">.create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">observer.next(<span class="string">&#x27;Jerry&#x27;</span>); <span class="comment">// RxJS 4.x 以前的版本用 onNext</span></span><br><span class="line">observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">observable.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面这段代码会打印出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">Jerry</span><br><span class="line">Anna</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">Jerry</span><br><span class="line">Anna</span><br></pre></td></tr></table></figure><p>所以明显的，这段代码是同步执行的，当然我们也可以拿它来处理非同步的行为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable</span><br><span class="line">.create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">observer.next(<span class="string">&#x27;Jerry&#x27;</span>); <span class="comment">// RxJS 4.x 以前的版本用 onNext</span></span><br><span class="line">observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">observer.next(<span class="string">&#x27;RxJS 30 days!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">30</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">observable.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样就会打印：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">Jerry</span><br><span class="line">Anna</span><br><span class="line">end</span><br><span class="line">RxJS <span class="number">30</span> days!</span><br></pre></td></tr></table></figure><p>从上可见，<code>Observable</code> 同时可以处理同步与非同步的行为</p><h2 id="观察者-Observer"><a href="#观察者-Observer" class="headerlink" title="观察者 Observer"></a>观察者 <code>Observer</code></h2><p><code>Observable</code> 可以被订阅 <code>subscribe</code>，或说可以说被观察，而订阅 <code>Observable</code> 的事件又称为观察者 <code>Observer</code>。观察者是一个具有三个方法的事件，每当 <code>Observable</code> 发生事件时，便会呼叫观察者相对应的方法。</p><blockquote><p>这里说的观察者 <code>Observer</code> 跟上一篇讲的观察者模式无关，观察者模式是一种设计模式，是思考问题的解决过程，而这里讲的观察者是一个被定义的事件。</p></blockquote><p>观察者的三个方法：</p><ul><li><p><code>next</code>：每当 <code>Observable</code> 发送新的值，<code>next</code> 方法就会被呼叫</p></li><li><p><code>complete</code>：在 <code>Observable</code> 没有其他资料可以取得时，<code>complete</code> 方法就会被呼叫，在 <code>complete</code> 被呼叫之后，<code>next</code> 方法就不会再起作用。</p></li><li><p><code>error</code>：每当 <code>Observable</code> 内发生错误时，<code>error</code> 方法就会被呼叫。</p></li></ul><p>直接建立一个观察者：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable</span><br><span class="line">.create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">observer.next(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">observer.complete();</span><br><span class="line">observer.next(<span class="string">&#x27;not work&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立一个观察者，具备 next, error, complete 三个方法</span></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用我们定义好的观察者，来订阅这个 observable</span></span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure><p>上面这段代码印出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jerry</span><br><span class="line">Anna</span><br><span class="line">complete</span><br></pre></td></tr></table></figure><p>执行完 <code>complete</code> 执行后，<code>next</code> 就会自动失效。</p><p>下面则是发送错误的示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable</span><br><span class="line">  .create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      observer.next(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">      observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;some exception&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      observer.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立一个观察者，具备 next, error, complete 三个方法</span></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span>, error)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用我们定义好的观察者，来订阅这个 observable</span></span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure><p>这里就会执行 <code>error</code> 的 function 印出 <code>Error：some exception</code>。</p><p>另外观察者可以是不完整的，可以只具有一个 <code>next</code> 方法，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有时候 Observable 会是一个无限的序列，例如 <code>click</code> 事件，这时 <code>complete</code> 方法就有可能永远不会被呼叫！</p></blockquote><p>我们也可以直接把 <code>next</code>, <code>error</code>, <code>complete</code> 三个 function 依序传入 <code>Observable.subscribe</code>，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span>, error); &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>Observable.subscribe</code> 会在内部自动生成 Observer 事件来操作。</p><h2 id="实例细节"><a href="#实例细节" class="headerlink" title="实例细节"></a>实例细节</h2><p>我们前边提到了，其实 <code>Observable</code> 的订阅和 <code>addEventListener</code> 在实例上有挺大的差异，虽然他们的行为很像</p><p><code>addEventListener</code> 本质上就是观察者模式的实例，在内部会有一份订阅清单。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">addListener</span>(<span class="params">listener</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> listener === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners.push(listener)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;listener 必须是 function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">removeListener</span>(<span class="params">listener</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners.splice(<span class="built_in">this</span>.listeners.indexOf(listener), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">notify</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">listener(message);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在内部存储了一份所有的观察者清单 <code>this.listener</code>，在要发布通知时会逐一的呼叫这份清单的观察者。</p><p>但在 Observable 不是这样的实例，在内部并没有一份订阅者的清单。订阅 Observable 的行为比较像是执行一个事件的方法，并把资料传进这个方法中。</p><p>以下代码做说明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable</span><br><span class="line">.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">observer.next(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observable.subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>像上面这段代码，他的行为比较像这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">observer.next(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>subscribe</code> 是一个 function，这个 function 执行时会传入观察者，而我们在这个 function 内部去执行观察者的方法。</p><p>订阅一个 <code>Observable</code> 就像是执行一个 function。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Observable 可以同时处理同步与非同步行为</li><li>Observer 是一个事件，这个事件具有三个方法，分别是：<code>next</code>, <code>error</code>, <code>complete</code></li><li>订阅一个 Observable 就像在执行一个 function</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS：建立 Observable (二)</title>
      <link href="/2021/07/07/RxJS%EF%BC%9A%E5%BB%BA%E7%AB%8B%20Observable%20(%E4%BA%8C)/"/>
      <url>/2021/07/07/RxJS%EF%BC%9A%E5%BB%BA%E7%AB%8B%20Observable%20(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="RxJS：建立-Observable-二"><a href="#RxJS：建立-Observable-二" class="headerlink" title="RxJS：建立 Observable (二)"></a>RxJS：建立 Observable (二)</h1><h2 id="创建运算符-Creation-Operator"><a href="#创建运算符-Creation-Operator" class="headerlink" title="创建运算符 Creation Operator"></a>创建运算符 <code>Creation Operator</code></h2><p>Observable 有许多创建实例的方法，称为创建运算符。下面是常用的创建运算符：</p><ul><li>create</li><li>of</li><li>from</li><li>fromEvent</li><li>fromPromise</li><li>never</li><li>empty</li><li>throw</li><li>interval</li><li>timer</li></ul><h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><p>Observable 最基本的创建方式是使用 <code>create</code> 来进行创建，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable</span><br><span class="line">    .create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">        observer.next(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">        observer.next(<span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line">        observer.complete();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jerry</span></span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><p>这里先后传递了 <code>&#39;Jerry&#39;</code>, <code>&#39;Anna&#39;</code> 然后结束 <code>complete</code>，当我们想要同步的传递几个值，就可以用 <code>of</code> 这个 <code>operator</code> 来简洁的表达。</p><p>下面代码效果同上：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.of(<span class="string">&#x27;Jerry&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jerry</span></span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><p><code>of</code> 这个 operator 的参数其实就是一个 <code>list</code>，而 <code>list</code> 在 JavaScript 中最常见的形式是数组，那有没有什么方法是直接传一个已知的数组当做参数？</p><p>使用 <code>from</code> 运算符，该运算符可以接受任何可列举的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Jerry&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>, <span class="number">2016</span>, <span class="number">2017</span>, <span class="string">&#x27;30 days&#x27;</span>] </span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.from(arr);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jerry</span></span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// 2016</span></span><br><span class="line"><span class="comment">// 2017</span></span><br><span class="line"><span class="comment">// 30 days</span></span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><p>注意，任何可列举的参数都可以使用，也就是说像 <code>Set</code>, <code>WeakSet</code>, <code>Iterator</code> 等都可当做参数。</p><p>另外 <code>from</code> 还能接收字符串 (string) ，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from(<span class="string">&#x27;铁人赛&#x27;</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 铁</span></span><br><span class="line"><span class="comment">// 人</span></span><br><span class="line"><span class="comment">// 赛</span></span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><p>上面的代码会把字符串中的字一一印出来。</p><p>我们也可以传入 Promise 事件，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable</span><br><span class="line">  .from(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;Hello RxJS!&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello RxJS!</span></span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><p>如果我们传入 Promise 事件实例，当正常回传时，就会被传送到到 <code>next</code>，并立即发送完成通知，如果有错误，则会发送到 error 中。</p><blockquote><p>这里也可以使用 <code>fromPromise</code>，结果一样。</p></blockquote><h3 id="fromEvent"><a href="#fromEvent" class="headerlink" title="fromEvent"></a>fromEvent</h3><p>我们也可以使用 Event 来建立 Observable，通过 <code>fromEvent</code> 方法，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MouseEvent &#123;...&#125;</span></span><br></pre></td></tr></table></figure><p><code>fromEvent</code> 的第一个参数要传入 DOM 事件，第二个参数传入要监听的时间名称。上面的代码会针对 <code>body</code> 的 <code>click</code> 事件做监听，每当点击 <code>body</code> 就会打印出 <code>event</code>。</p><blockquote><p>取得 DOM 事件的常用方法： <code>document.getElementById()</code> <code>document.querySelector()</code> <code>document.getElementsByTagName()</code> <code>document.getElementsByClassName()</code></p></blockquote><p>补充： <code>fromEventPattern</code></p><p>要用 Event 来建立 Observable 实例还有另外一个方法，就是 <code>fromEventPattern</code>，这个方法是给类事件使用。所谓的类事件就是指其行为跟事件相像，同时具有注册监听及移除监听两种行为，就像 DOM Event 有 <code>addEventListener</code> 和 <code>removeEventListener</code> 一样。代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">addListener</span>(<span class="params">listener</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> listener === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners.push(listener)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;listener 必须是 function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">removeListener</span>(<span class="params">listener</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners.splice(<span class="built_in">this</span>.listeners.indexOf(listener), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">notify</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">listener(message);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------- 以上都是之前的代码 -------- //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> egghead = <span class="keyword">new</span> Producer(); </span><br><span class="line"><span class="comment">// egghead 同时具有 注册观察者及移除观察者 两种方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable</span><br><span class="line">    .fromEventPattern(</span><br><span class="line">        <span class="function">(<span class="params">handler</span>) =&gt;</span> egghead.addListener(handler), </span><br><span class="line">        <span class="function">(<span class="params">handler</span>) =&gt;</span> egghead.removeListener(handler)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">egghead.notify(<span class="string">&#x27;Hello! Can you hear me?&#x27;</span>);</span><br><span class="line"><span class="comment">// Hello! Can you hear me</span></span><br></pre></td></tr></table></figure><p>上面的代码可以看到，<code>egghead</code> 是 <code>Producer</code> 的实例，同时具有注册监听和移除监听的两种方法，我们可以把这两个方法传入 <code>fromEventPattern</code> 来建立 Observable 的事件实例。</p><blockquote><p>这里注意不要直接将方法传入，避免 this 出错，也可以用 <code>bind</code> 来写。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">    .fromEventPattern(</span><br><span class="line">        egghead.addListener.bind(egghead), </span><br><span class="line">        egghead.removeListener.bind(egghead)</span><br><span class="line">    )</span><br><span class="line">    .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><h3 id="empty、never、throw"><a href="#empty、never、throw" class="headerlink" title="empty、never、throw"></a>empty、never、throw</h3><p>接下来我们来看几个比较无趣的 operator，之后我们会讲到很多 observables 合并 (combine)、转换 (transform) 的方法，到那个时候无趣的 observable 也会很有用。</p><p>有点像数学上的 0，虽然有时候没什么，但却非常重要。在 Observable 的世界也有类似的东西，就是 <code>empty</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.empty();</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><p><code>empty</code> 会给我们一个空的 observable，如果我们订阅这个 observable，它会立即发送 complete 信息。</p><p>数学上还有一个东西跟 0 很像，那就是无穷 ∞，在 Observable 的世界我们用 <code>never</code> 来建立无穷的 Observable。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.never();</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>never</code> 会给我们一个无穷的 observable，它就是一个一直存在但却什么都不做的 observable。</p><p>最后还有一个 operator <code>throw</code>，它也就只做一件事就是抛出错误。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.throw(<span class="string">&#x27;Oop!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Throw Error: &#x27;</span> + error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Throw Error: Oop!</span></span><br></pre></td></tr></table></figure><p>上面这段代码之后 log 出 <code>&#39;Throw Error Oop&#39;</code></p><h3 id="interval、timer"><a href="#interval、timer" class="headerlink" title="interval、timer"></a>interval、timer</h3><p>JS 中的 <code>setInterval</code> 在 RxJS 中也有对应的 operator <code>interval</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.create(<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        observer.next(i++);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Throw Error: &#x27;</span> + error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// .....</span></span><br></pre></td></tr></table></figure><p>在 Observable 的世界也有一个更方便的 operator 可以做到这件事，就是 <code>interval</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Throw Error: &#x27;</span> + error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>interval</code> 有一个参数必须是数值 (Number)，这个数值代表发出信号的间隔时间 (ms)。这两段代码基本等价，会持续每隔一秒发送一个从零开始递增的数值</p><p>另外一个很相似的 operator 叫 <code>timer</code>，<code>timer</code> 可以给出两个参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.timer(<span class="number">1000</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Throw Error: &#x27;</span> + error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2 ...</span></span><br></pre></td></tr></table></figure><p>当 <code>timer</code> 有两个参数时，第一个参数是发出第一个值的等待时间 (ms)，第二个参数代表第一次之后发送值的间隔时间，所以上面这段代码会等一秒发送 1，之后每 5 秒发送 2、3、4、5……</p><p><code>timer</code> 第一个参数除了可以是数值 (Number) 之外，也可以是日期 (Date)，就会等到指定的时间发送第一个值。</p><p>另外 <code>timer</code> 也可以只接收一个参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.timer(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Throw Error: &#x27;</span> + error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><p>上面这段代码就会等一秒后发送 1 同时通知结束。</p><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>我们有时候需要在某些行为之后不需要这些资源，要做到这件事最简单的方式是 <code>unsubscribe</code>。</p><p>其实在订阅 Observable 后，会回传一个 Subscription 事件，这个事件具有释放资源的 <code>unsubscribe</code> 方法，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.timer(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得 subscription</span></span><br><span class="line"><span class="keyword">var</span> subscription = source.subscribe(&#123;</span><br><span class="line"><span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">complete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;complete!&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Throw Error: &#x27;</span> + error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe() <span class="comment">// 停止订阅(退订)， RxJS 4.x 以前的版本用 dispose()</span></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>这里我们用到了 <code>setTimeout</code> 在 5 秒之后，执行了 <code>subscription.unsubscribe( )</code> 来停止订阅并释放资源，另外 subscription 事件还有其他合并订阅等作用，这个之后会提到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：深浅拷贝</title>
      <link href="/2021/07/06/JS%EF%BC%9A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2021/07/06/JS%EF%BC%9A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：深浅拷贝"><a href="#JS：深浅拷贝" class="headerlink" title="JS：深浅拷贝"></a>JS：深浅拷贝</h1><p>先看一下数组的拷贝，通常我们会使用 slice( )、concat( ) 方法实现数组的拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.concat();</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice();</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>slice( )、concat( ) 都是返回一个新的数组，没有改变原来的数组，看起来像是深拷贝。</p><p>我们再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.concat();</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice();</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br></pre></td></tr></table></figure><p>这里就可以看到，如果数组里有对象，那么不会拷贝对象的值，只是拷贝对象的引用，原来数据对象的值发生改变，由于拷贝的是对象的引用，新拷贝的数据中对象的值也发生改变，拷贝得不是很彻底，slice( )、concat( ) 是浅拷贝，对于对象，我们通常是通过 assign( ) 方法，或者使用展开运算符 ( . . . ) 来实现拷贝，同样，如果对象中嵌套了对象，也只能实现浅拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;mei&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;<span class="attr">city</span>: <span class="string">&quot;shanghai&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;...obj&#125;;</span><br><span class="line">obj.address.city = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name: &quot;mei&quot;, address:&#123;city: &quot;beijing&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123;name: &quot;mei&quot;, address:&#123;city: &quot;beijing&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="利用-JSON-stringify-实现对数组和对象的深拷贝"><a href="#利用-JSON-stringify-实现对数组和对象的深拷贝" class="headerlink" title="利用 JSON.stringify 实现对数组和对象的深拷贝"></a>利用 JSON.stringify 实现对数组和对象的深拷贝</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, &#123; value: 5 &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;mei&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;<span class="attr">city</span>: <span class="string">&quot;shanghai&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">obj.address.city = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name: &quot;mei&quot;, address:&#123;city: &quot;shanghai&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>该方法不能对 undefined、symbol、函数进行深度拷贝。</p><h2 id="利用递归实现数组和对象深拷贝"><a href="#利用递归实现数组和对象深拷贝" class="headerlink" title="利用递归实现数组和对象深拷贝"></a>利用递归实现数组和对象深拷贝</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = deepCopy(arr);</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//1, 2, 3, 4, &#123; value: 5 &#125;]</span></span><br></pre></td></tr></table></figure><p>对于数组和对象的浅拷贝，去掉递归就可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = shallowCopy(arr);</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：箭头函数</title>
      <link href="/2021/07/06/JS%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2021/07/06/JS%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：箭头函数"><a href="#JS：箭头函数" class="headerlink" title="JS：箭头函数"></a>JS：箭头函数</h1><p>先来看下 ES6 中箭头函数的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要传入多个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> value * num;</span><br></pre></td></tr></table></figure><p>上面箭头函数例子中都省略了 return 关键字和代码的花括号，在箭头函数中如果方法体中只有一行的代码，可以省略关键字和方法的花括号，直接简化成 value =&gt; value。</p><p>如果函数的代码块需要多条语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value * num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要返回一个对象，箭头函数的方法体必须放在大括号 ( ) 中，这样做的原因是：没有大括号，JS 引擎没办法区分是正常定义一个对象还是一个箭头函数体：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> (&#123; <span class="attr">value</span>: value, <span class="attr">num</span>: num &#125;); <span class="comment">//正确写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> &#123; <span class="attr">value</span>: value, <span class="attr">num</span>: num &#125;; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><h2 id="与普通函数的区别"><a href="#与普通函数的区别" class="headerlink" title="与普通函数的区别"></a>与普通函数的区别</h2><h3 id="没有-this"><a href="#没有-this" class="headerlink" title="没有 this"></a>没有 this</h3><p>箭头函数式的 this 需要通过查找作用域链来确定，它的 this 是指包在它外面的作用域的 this，我们来看下以下代码中的 this 分别指的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// windows</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>obj.b 是一个箭头函数，它的 this 是包在外层的词法作用域的 this ，obj 对象不是可执行代码，所以它不是离箭头函数最近的词法作用域，再往外就是全局作用域 window 了，所以 obj.b 的 this 指的是 windows。</p><p>再来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomething(event.type);     <span class="comment">// error</span></span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling &quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在调用 pageHandler.init 方法的时候会报错，报错的函数是个回调函数，这个回调函数的 this 指的是全局变量 windows，在全局变量里没有 doSomething 这个方法，所以会报错，有两种方式处理这种错误：</p><p>第一种方式就是通过 bind 来指定 this：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomething(event.type)</span><br><span class="line">        &#125;).bind(<span class="built_in">this</span>), <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.bind(this) 中的 this 是指 pageHandler 这个对象，通过 bind 生成一个 this 指向 pageHandler 的新函数，这样执行 init 方法的时候不会报错，看起来有点奇怪。</p><p>第二种方式就是通过箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomething();</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把 init 中的回调函数改成了箭头函数，箭头函数的 this 是它最近的作用域链上的 this，也就是 init 这个方法的 this，也就是 pageHandler 这个对象，这样就可以达到目的不报错。</p><p><em><strong>需要注意的是，箭头函数不能改变 this 的值，普通函数可以通过 call、apply、bind 来指定 this，但是箭头函数的 this 是不能改变的。</strong></em></p><p><em><strong>上面所说，箭头函数的 this 不能改变某种程度上是不准确的，因为箭头函数中的 this 其实是跟随其外一层的函数的 this，所以如果外层函数中的 this 改变了，对应里边的箭头函数中的 this 指向也是跟随着外层的函数的 this 的。</strong></em></p><p>观察下方的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pageHandler.init();<span class="comment">// pageHandler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testFunc = pageHandler.init;</span><br><span class="line">testFunc.init();<span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>上方代码中的两种调用方式，得到的结果却不一样。</p><p>第一种方式，通过对象来调用方法，相当于把 pageHandler 绑定到了 init 方法中，然后 init 方法中的 箭头函数中的 this 是跟随 init 方法中的 this，因而箭头函数中的 this 也是指向 pageHandler 的。</p><p>第二种方式，通过将对象中的方法赋值给 testFunc 变量，然后在调用 testFunc( )，这时 testFunc 函数中的 this 指针未被指定，因而是默认值 window。 然后 testFunc 方法中的箭头函数中的 this 是跟随外一层的 this 指针，故箭头函数中的 this 也是指向 window 的。</p><p>由此可以看出，箭头函数的 this 指针并非完全不能够改变的，因为箭头函数的 this 指向是跟随外一层函数的 this 指针的，所以如果外一层函数的 this 指针改变了，对应的，其可执行代码中的箭头函数的 this 指针也会跟随改变。</p><h3 id="没有-arguments"><a href="#没有-arguments" class="headerlink" title="没有 arguments"></a>没有 arguments</h3><p>访问箭头函数的 arguments，其实也是访问包在它外面的非箭头函数的 arguments。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>,<span class="number">2</span>)()); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h3><p>没有 prototype，但是有 __proto__ 指向 function。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim：基础操作指南</title>
      <link href="/2021/07/06/Vim%20%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2021/07/06/Vim%20%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><ul><li>h 或 退格：左移一个字符</li><li>l 或 空格：右移一个字符</li><li>j：下移一行</li><li>k：上移一行</li><li>gj：移动到一段内的下一行</li><li>gk：移动到一段内的上一行</li><li>+或 Enter：移动到下一行第一个非空白字符</li><li>-：移动到上一行第一个非空白字符</li><li>w：后移一个单词，光标停在下一个单词开头</li><li>W：移动到下一个单词开头，但忽略一些标点</li><li>e：后移一个单词，光标停在下一个单词的末尾</li><li>E：移动到下一个单词的末尾</li><li>b：前移一个单词，光标停在单词的开头</li><li>B：移动到前一个单词开头，忽略一些标点</li><li>ge：前移一个单词，光标停在上一个单词的末尾</li><li>gE：同 ge ，不过单词包含相邻的标点</li><li>(：前移一句</li><li>)：后移一句</li><li>{：前移一段</li><li>}：后移一段</li><li>fc：把光标移动到同一行的下一个 c 字符处</li><li>Fc：把光标移动到同一行的上一个 c 字符处</li><li>tc：把光标移动到同一行的下一个 c 字符前</li><li>Tc：把光标移动到同一行的上一个 c 字符后</li></ul><p>上面的操作都可以配合 n 使用，比如正常模式下输入 3h，则光标向左移动3个字符。</p><ul><li>0：移动到行首</li><li>g0：移动到所在屏幕行行首</li><li>^：移动到本行第一个非空白字符</li><li>g^：移动到所在屏幕行第一个非空字符处</li><li>$：移动到行尾</li><li>g$：移动到所在屏幕行行尾</li><li>nl：移动到第 n 列</li><li>nG：移动到第 n 行</li><li>:n&lt;cr&gt;：移动到第 n 行</li><li>:$&lt;cr&gt;：移动到最后一行</li><li>H：把光标移到屏幕最顶端一行</li><li>M：把光标移到屏幕最底端一行</li><li>L：把光标移到屏幕最底端一行</li><li>gg：到文件头部</li><li>G：到文件尾部</li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="基本插入"><a href="#基本插入" class="headerlink" title="基本插入"></a>基本插入</h3><ul><li>i：在光标前插入；一个小技巧：按 8 ，再按 i，进入插入模式，输入 =，按 esc 进入命令模式，就会出现 8 个 =。这在插入分割线时非常有用，如：30 i + &lt;esc&gt; 插入了 30 个 + 组成的分割线</li><li>l：在当前行第一个非空字符前插入</li><li>gl：在当前行第一列插入</li><li>a：在光标后插入</li><li>A：在当前行最后插入</li><li>o：在下面新建一行插入</li><li>O：在上面新建一行插入</li><li>:r filename：在当前位置插入另一个文件的内容</li><li>:[n] r filename：在第 n 行插入另一个文件的内容</li><li>:r !date：在光标处插入当前日期与时间。同理，:r !command 可以将其他 shell 命令的输出插入到当前文档</li></ul><h3 id="改写插入"><a href="#改写插入" class="headerlink" title="改写插入"></a>改写插入</h3><ul><li>c[n]w：改写光标后的 1(n) 个词</li><li>c[n]l：改写光标后的 1(n) 个字母</li><li>c[n]h：改写光标前的 1(n) 个字母</li><li>[n]cc：修改当前 1(n) 行</li><li>[n]s：以输入的文本替代光标后的 1(n) 个字符，相当于 c[n]l</li><li>[n]S：删除指定数目的行，并以所输入文本替代之</li></ul><p>注意，类似 cnw、dnw、ynw 的形式同样可以写为 ncw、ndw、nyw</p><h2 id="复制、黏贴和剪切"><a href="#复制、黏贴和剪切" class="headerlink" title="复制、黏贴和剪切"></a>复制、黏贴和剪切</h2><ul><li>[n]x：剪切光标右边 n 个字符，相当于 d[n]l</li><li>[n]X：剪切光标左边 n 个字符，相当于 d[n]h</li><li>y：复制可视模式下选中的文本</li><li>yy or Y：复制整行文本</li><li>y[n]w：复制 1(n) 个词</li><li>y[n]l：复制光标右边 1(n) 个字符</li><li>y[n]h：复制光标左边 1(n) 个字符</li><li>y$：从光标当前位置复制到行尾</li><li>y0：从光标当前位置复制到行首</li><li>:m,n&lt;cr&gt;：复制 m 行到 n 行的内容</li><li>y1G or ygg：复制光标以上的所有行</li><li>yG：复制光标以下的所有行</li><li>yaw or yas：复制一个词和复制一个句子，即使光标不在词首和句首也没有关系</li><li>d：删除 (剪切)，在可视模式下选中的文本</li><li>d$ or D：删除 (剪切) 当前位置到行尾的内容</li><li>d[n]w：删除 (剪切) 1(n)个单词</li><li>d[n]l：删除 (剪切) 光标右边 1(n) 个字符</li><li>d[n]h：删除 (剪切) 光标左边 1(n) 个字符</li><li>d0：删除 (剪切) 当前位置到行首的内容</li><li>[n]dd：删除 (剪切) 1(n) 行</li><li>m,nd&lt;cr&gt;：剪切 m 行到 n 行的内容</li><li>d1G or dgg：剪切光标以上的所有行</li><li>dG：剪切光标以下的所有行</li><li>daw 或 das：剪切一个词或者剪切一个句子，即使光标不在词首和句首也没有关系</li><li>d/f&lt;cr&gt;：高级组合命令，它将删除当前位置到下一个 f 之间的内容</li><li>p：在光标之后黏贴</li><li>P：在光标之前黏贴</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：JavaScript 中可能模拟出私有变量吗？</title>
      <link href="/2021/07/02/JS%EF%BC%9AJavaScript%20%E4%B8%AD%E6%9C%89%E5%8F%AF%E8%83%BD%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F/"/>
      <url>/2021/07/02/JS%EF%BC%9AJavaScript%20%E4%B8%AD%E6%9C%89%E5%8F%AF%E8%83%BD%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：JavaScript-中有可能模拟出私有变量吗？"><a href="#JS：JavaScript-中有可能模拟出私有变量吗？" class="headerlink" title="JS：JavaScript 中有可能模拟出私有变量吗？"></a>JS：JavaScript 中有可能模拟出私有变量吗？</h1><p>JavaScript 中谈私有属性和私有方法就是扯淡，不知道什么时候提上来真正的私有，我们来看看 JS 是如何根据当前特性来实现私有成员。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JavaScript 实现私有属性必须依赖闭包特性，看以下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueId;</span><br><span class="line">  uniqueId = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prefix + <span class="string">&quot;_&quot;</span> + index++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="comment">//c_0</span></span><br><span class="line">  <span class="built_in">console</span>.log(uniqueId(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">  <span class="comment">//c_1</span></span><br><span class="line">  <span class="built_in">console</span>.log(uniqueId(<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure><p>通常我们所说的或者看到的闭包就是这样子的 — (function() {}) ()，但这不是它的全部或者本质。在定义 uniqueId 这个函数的时候，我们使用了匿名函数表达式（请注意 (function( ){}) 是函数表达式）定义了一个函数且立即执行，把此时这个 function(prefix) {/<em>some code</em>/} 已经生成了函数实例，在函数实例生成的过程中：</p><p>1、通俗的讲，将 index 这个外部函数定义的变量记住了。</p><p>2、再次我们没法通过什么 this.index 或者 someObj.index 引用到 index，改变其值了，(function( ) { })( )这个一执行完，局部变量 index 在外面没有办法访问到。</p><p>3、怎么调得到，只能靠 function(prefix) {/<em>sone code</em>/}，因为我们还能通过它间接的取得或改变 index 值，这就是闭包了。</p><p>比较学术的解释：</p><p>1、JS 是词法作用域（就是程序上看上去是怎么样就是怎么样），使用一个叫 [[scope]] 的内部属性来标识每个执行上下文的作用域（我们可以读写哪些变量，调用哪些函数）；每个函数执行时都由该 [[scope]] 作用域加上活动对象构成真实的执行上下文。</p><p>2、而这个执行上下文 [[scope]] 属性是在函数生成时就指定的了。</p><p>3、于是 function(prefix){/<em>some code</em>/} 生成时其内部的 [[scope]] 属性引用了 (function( ){ })( ) 执行上下文的 scope 链；该 scope 链即包含了该函数的 [[scope]] 和活动对象，且活动对象包含了 index 的定义引用。</p><p>4、GC 的回收规则，没人用我，我就是垃圾。因此 uniqueId 引用了 function(prefix) {/<em>some code</em>/} 函数实例，而该函数的实例 [[scope]] 引用了 (function( ){ })( ) 执行期的 scope 链，其包含活动对象，即有 index 的引用；还有人引用它，它就不是垃圾，因此闭包就形成了，我们可以通过 uniqueId 函数间接地读取或者修改 index。</p><p>总结：其实学术解释和通俗解释都是一个意思，不过闭包其实是相对的，并不是我们不能修改 index，只是需要间接方法。</p><h2 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h2><p>构造单例对象的私有属性和私有方法都比较简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aira;</span><br><span class="line">aira = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    <span class="comment">//private variable</span></span><br><span class="line">    __name = <span class="string">&quot;HTC mobile&quot;</span>;</span><br><span class="line">    <span class="comment">//private method</span></span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">    aira = &#123;</span><br><span class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//change private variable inner</span></span><br><span class="line">            __name = <span class="string">&quot;aira&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">hello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//execute private method inner</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> aira;</span><br><span class="line">&#125;)();</span><br><span class="line">aira.init();</span><br><span class="line"><span class="comment">//hello,my name is aira</span></span><br><span class="line">aira.hello();</span><br></pre></td></tr></table></figure><p>使用下划线 “_“ 表示私有；aira 手机有一个私有属性 “_name” 和私有方法 “_getName”；我们可以在 init 中修改 “_name”，在 hello 中调用 “_getName”，且在闭包外面无法直接调用和修改这两个成员。这样就可以实现私有变量和私有方法了。</p><p>但是确切的说，其实 aira 能够有私有属性和方法仅仅是因为它有一个私有的一个闭包，即 init 和 hello 成员的 [[scope]] 都引用了闭包的活动对象。</p><p>然而，一个构造函数（类）的私有属性和方法就是这么简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira;</span><br><span class="line"><span class="comment">//wrap by function</span></span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> phone;</span><br><span class="line">    phone = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> __getName, __name;</span><br><span class="line">        __name = name;</span><br><span class="line">        __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> __name;</span><br><span class="line">        &#125;;</span><br><span class="line">        phone = &#123;</span><br><span class="line">            <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">                __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">hello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> phone;</span><br><span class="line">&#125;;</span><br><span class="line">aira1 = Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line"></span><br><span class="line">aira2 = Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2</span></span><br><span class="line">aira2.hello();</span><br></pre></td></tr></table></figure><p>我们先来简单的将单例对象的构造包裹一个函数，实现产生不同的对象。我们可以说 Phone 是一个类，因为它可以产生不同的对象，有类似的功能。同样 aria1 和 aria2 都有自己的闭包，于是都有自己的私有属性和私有方法。</p><p>JS 中类的概念就是构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira1, aira2;</span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    __name = name;</span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.init = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">        __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">aira1 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line"></span><br><span class="line">aira2 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2</span></span><br><span class="line">aira2.hello();</span><br></pre></td></tr></table></figure><p>Phone 构造函数其实就是闭包的功能，每个 Phone 实例的 init 和 hello 都能引用其构造期间的形成的私有的 “_name” 和 “_getName”。</p><p>每个实例都必须由闭包产生私有属性和方法，因此只能在该闭包中定义公共方法暴露出来（比如说 init 和 hello），这就意味着每次构造一个实例我们都必须生成 init 和 hello 的函数实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira;</span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    __name = name;</span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Phone.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">&#125;;</span><br><span class="line">Phone.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">&#125;;</span><br><span class="line">aira = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的代码是错误的（在 init 中 “_name” 是全局的，hello 中的 “_getName” 方法因为不存在，所以会报错），这就是问题所在，能够引用私有属性和变量的公共方法必须在闭包中定义，然后暴露出来，然而原型方法并不能在闭包中定义。</p><p>下面这段代码是私有方法吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira1, aira2;</span><br><span class="line">Phone = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        __name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Phone.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">        __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">    &#125;;</span><br><span class="line">    Phone.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Phone;</span><br><span class="line">&#125;)();</span><br><span class="line">aira1 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1 right!</span></span><br><span class="line">aira1.hello();</span><br><span class="line">aira2 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2 right!</span></span><br><span class="line">aira2.hello();</span><br><span class="line"><span class="comment">//hello,my name is aira#2 wrong!</span></span><br><span class="line">aira1.hello();</span><br></pre></td></tr></table></figure><p>试图用闭包包住构造函数，形成闭包，但是得到的结果是 “_name” 和 “_getName” 其实都是类的私有属性，而不是实例。aira1 和 aira2 共用了 “_name” 和 “_getName”。</p><p>再来确定一下什么是私有属性和私有方法，即每个类实例都拥有且只能在类内访问的变量和函数。也就是说变量和方法只能由类的方法来调用。说到这里，我们或许可以尝试一下，不让类外的方法调用类的私有方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inner, outer;</span><br><span class="line">outer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;;</span><br><span class="line">inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  function()&#123;</span></span><br><span class="line"><span class="comment">      inner();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>从 arguments 的 callee 中可获取当前的执行函数 inner，而 inner 的动态属性 caller 指向了调用 inner 的外层函数 outer，由此看来我们可以使用 arguments.callee.caller 来确定函数的执行环境，实现私有方法和属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira1, aira2;</span><br><span class="line"><span class="built_in">Function</span>.prototype.__public = <span class="function"><span class="keyword">function</span> (<span class="params">klass</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.klass = klass;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.__private = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that;</span><br><span class="line">    that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.constructor === <span class="built_in">arguments</span>.callee.caller.klass) &#123;</span><br><span class="line">            <span class="keyword">return</span> that.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&quot;</span> + that + <span class="string">&quot; is a private method!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __name;</span><br><span class="line">    __name = name;</span><br><span class="line">    <span class="built_in">this</span>.__getName = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;).__private();</span><br><span class="line">    <span class="built_in">this</span>.__setName = (<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        __name = name;</span><br><span class="line">    &#125;).__private();</span><br><span class="line">&#125;;</span><br><span class="line">Phone.prototype.init = (<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.__setName(<span class="built_in">this</span>.__getName() + <span class="string">&quot;#&quot;</span> + number);</span><br><span class="line">&#125;).__public(Phone);</span><br><span class="line">Phone.prototype.hello = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (<span class="built_in">this</span>.__getName()));</span><br><span class="line">&#125;).__public(Phone);</span><br><span class="line">aira1 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line">aira2 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2</span></span><br><span class="line">aira2.hello();</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    aira1.__getName();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error Object</span></span><br><span class="line"><span class="comment">    message:&quot;function () &#123;return __name;&#125; is a private method!&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、我给 Function 原型上添加了两个方法 _public 和 _private 以此来实现私有方法的调用环境测试；</p><p>2、其次我无法给私有属性添加检测，所以私有属性直接不可见，使用私有 get，set 方法访问；</p><p>3、本身在 aira1 外部调用时，我们还是能看到 _getName 和 _setName 方法，只是不能调用而已；</p><p>4、唯一好的一点是原型方法（公共方法）终于可以从构造函数闭包中解放出来了；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：原型</title>
      <link href="/2021/07/01/JS%EF%BC%9AJavaScript%20%E5%8E%9F%E5%9E%8B/"/>
      <url>/2021/07/01/JS%EF%BC%9AJavaScript%20%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：JavaScript-原型"><a href="#JS：JavaScript-原型" class="headerlink" title="JS：JavaScript 原型"></a>JS：JavaScript 原型</h1><h2 id="引入：普通对象与函数对象"><a href="#引入：普通对象与函数对象" class="headerlink" title="引入：普通对象与函数对象"></a>引入：普通对象与函数对象</h2><p>在 JavaScript 中，一直有一个说法，万物皆对象，事实上，对象也是有区别的，我们可以将其划分为 <em><strong>普通对象</strong></em> 和 <em><strong>函数对象</strong></em>。Object 和 Function 便是 JavaScript 自带的两个典型的函数对象，而函数对象就是一个纯函数，所谓的函数对象，其实就是使用 JavaScript 在模拟类。</p><p>那么究竟什么是普通对象，什么是函数对象，请看下方例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;language&#x27;</span>, <span class="string">&#x27;console.log(language)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ob1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ob2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">const</span> ob3 = <span class="keyword">new</span> fn1()</span><br></pre></td></tr></table></figure><p>打印以下结果，可以得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob1); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob2); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob3); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn1); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn2); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn3); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p>在上述例子中，ob1、ob2、ob3为普通对象（均为 Object 的实例），而 fn1、fn2、fn3 均是 Function 的实例，称之为 函数对象。</p><p>如何区分，记住这句话就可以了：</p><p>所有的 Function 的实例都是函数对象，而其他的都是普通对象。</p><p>上面提到，Object 和 Function 均是函数对象，我们也说到了，所有的 Function 的实例都是函数对象，难道 Function 也是 Function 的实例？</p><p>保留这个疑问，我们做一个总结：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/S7IhPO.jpg" alt="alt"></p><p>从图中可以看出，对象本身的实现还是要依靠构造函数。那原型链到底是用来干嘛的？</p><p>众所周知，作为一门面向对象的语言，必定具有以下特征：</p><ul><li>对象唯一性</li><li>抽象性</li><li>继承性</li><li>多态性</li></ul><p>而原型链最大的目的，就是为了<strong>实现继承</strong>。</p><h2 id="进阶：prototype-和-proto"><a href="#进阶：prototype-和-proto" class="headerlink" title="进阶：prototype 和 __proto__"></a>进阶：prototype 和 __proto__</h2><p>原型链究竟是如何实现继承的？首先，先引入两兄弟：prototype 和 __proto__，这是在 JavaScript 中无处不在的两个变量（如果你经常调试的话），然而，这两个变量并不是在所有的对象上都存在，先看一张表：</p><p>​                    prototype           __proto__</p><p>普通对象            X                    V</p><p>函数对象            V                    V</p><p>首先，我们先给出结论：</p><p>1、只有函数对象具有 prototype 这个属性；</p><p>2、prototype 和 __proto__ 都是 JavaScript 在定义一个函数对象时自动创建的预定义属性；</p><p>接下来我们验证上述的两个结论：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn.__proto__); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn.prototype); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ob = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob.__proto__); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob.prototype); <span class="comment">// undefined，哇！果然普通对象没有 prototype</span></span><br></pre></td></tr></table></figure><p>既然是语言层面的预置属性，那么两者究竟有什么区别？我们依然从结论出发，给出以下两个结论：</p><p>1、prototype 被实例的 __proto__ 所指向（被动）</p><p>2、__proto__ 指向构造函数的 prototype（主动）</p><p>也就是说以下代码成立：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ob.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>那么问题来了，既然 fn 是一个函数对象，那么 fn.prototype.__proto__到底等于什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>创建一个函数时，JavaScript 对该函数原型的初始化代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 自动执行</span></span><br><span class="line">fn1.protptype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: fn1,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="built_in">Object</span>.prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1.__proto__ = <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure><p>普通对象就是通过函数对象实例化得到的，而一个实例不可能再次进行实例化，也就不会让另一个对象的 __proto__ 指向它的 prototype，因此普通对象没有 prototype 属性这个结论就非常好理解了。而且我们也看出来了，fn1.prototype 就是一个普通对象，它也不存在 prototype 属性。</p><p>我们在上面还留下了一个疑问</p><ul><li>难道 Function 也是 Function 的实例？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="重点：原型链"><a href="#重点：原型链" class="headerlink" title="重点：原型链"></a>重点：原型链</h2><p>上面我们了解了 prototype 和 __proto__，实际上，这两兄弟主要就是为了构造原型链而存在的。</p><p>先看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125; <span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125; <span class="comment">/* 2 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">&#125; <span class="comment">/* 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person(<span class="string">&#x27;ulivz&#x27;</span>, <span class="number">24</span>); <span class="comment">/* 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ulivz) <span class="comment">/* 5 */</span></span><br><span class="line"><span class="built_in">console</span>.log(ulivz.getName(), ulivz.getAge()) <span class="comment">/* 6 */</span></span><br></pre></td></tr></table></figure><p>解释一下执行细节：</p><ul><li>执行 1，创建了一个构造函数 Person，要注意，前面已经提到，此时 Person.prototype 已经被自动创建，它包含 constructor 和 __proto__这两个属性；</li><li>执行2，给对象 Person.prototype 增加了一个方法 getName()；</li><li>执行3，给对象 Person.prototype 增加了一个方法 getAge()；</li><li>执行4, 由构造函数 Person 创建了一个实例 ulivz，值得注意的是，一个构造函数在实例化时，一定会自动执行该构造函数。</li><li>在浏览器得到 5 的输出，即 ulivz 应该是：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;ulivz&#x27;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">     <span class="attr">__proto__</span>: <span class="built_in">Object</span> <span class="comment">// 实际上就是 `Person.prototype`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的结论，以下等式成立：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ulivz.__proto__ == Person.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>执行6的时候，由于在 ulivz 中找不到 getName() 和 getAge() 这两个方法，就会继续朝着原型链向上查找，也就是通过 __proto__ 向上查找，于是，很快在 ulviz.__proto__ 中，即 Person.prototype 中找到了这两个方法，于是停止查找并执行得到结果。</li></ul><p><em><strong>这便是 JavaScript 的原型继承。准确的说，JavaScript 的原型继承时通过 __proto__ 并借助 prototype 来实现的。</strong></em></p><p>于是便有以下总结：</p><p>1、函数对象的 __proto__ 指向 Function.prototype；</p><p>2、instance.__proto__ 指向函数对象的 prototype；</p><p>3、普通对象的 __proto__ 指向 Object.prototype；</p><p>4、普通对象没有 prototype 属性；</p><p>5、在访问一个对象的某个属性 / 方法的时候，如果在当前对象上没有找到，则会尝试 ob.__proto__，也就是访问该对象的构造函数的原型 obCtr.prototype，如果还是找不到，会继续查找 obCtr.prototype.__proto__，依次查找下去，若在某一刻，找到了该属性，则会立刻返回值并停止对原型链的搜索，若找不到，则返回 undefined。</p><p>为了加深理解，参考以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ulivz.__proto__ == <span class="built_in">Function</span>.prototype);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Function</span>.prototype);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Object</span>.prototype);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Function</span>.prototype);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="终极：原型链图"><a href="#终极：原型链图" class="headerlink" title="终极：原型链图"></a>终极：原型链图</h2><p>上面我们还遗留了一个问题：</p><ul><li>如果原型链一直找不到的话，那么什么时候停止，原型链的尽头在哪？</li></ul><p>我们可以用代码验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(ulivz.name);</span><br></pre></td></tr></table></figure><p>很明显，会输出 undefined。简述查找过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ulivz                <span class="comment">// 是一个对象，可以继续 </span></span><br><span class="line">ulivz[<span class="string">&#x27;name&#x27;</span>]           <span class="comment">// 不存在，继续查找 </span></span><br><span class="line">ulivz.__proto__            <span class="comment">// 是一个对象，可以继续</span></span><br><span class="line">ulivz.__proto__[<span class="string">&#x27;name&#x27;</span>]        <span class="comment">// 不存在，继续查找</span></span><br><span class="line">ulivz.__proto__.__proto__          <span class="comment">// 是一个对象，可以继续</span></span><br><span class="line">ulivz.__proto__.__proto__[<span class="string">&#x27;name&#x27;</span>]     <span class="comment">// 不存在, 继续查找</span></span><br><span class="line">ulivz.__proto__.__proto__.__proto__       <span class="comment">// null !!!! 停止查找，返回 undefined</span></span><br></pre></td></tr></table></figure><p>最后来看一下上一节的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125; <span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125; <span class="comment">/* 2 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">&#125; <span class="comment">/* 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person(<span class="string">&#x27;ulivz&#x27;</span>, <span class="number">24</span>); <span class="comment">/* 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ulivz) <span class="comment">/* 5 */</span></span><br><span class="line"><span class="built_in">console</span>.log(ulivz.getName(), ulivz.getAge()) <span class="comment">/* 6 */</span></span><br></pre></td></tr></table></figure><p>我们来画一个原型链图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/MbRe8T.jpg" alt="alt"></p><p>画完这张图，所有疑问都已经得到了解答了。</p><h2 id="调料：Constructor"><a href="#调料：Constructor" class="headerlink" title="调料：Constructor"></a>调料：Constructor</h2><p>前面已经有所提及了，只有原型对象才具有 constructor 这个属性，constructor 用来指向引用它的函数对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor === Person <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor.prototype.constructor === Person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这是一种循环引用。</p><h2 id="补充：JavaScript-中的-6-大内置（函数）对象的原型继承"><a href="#补充：JavaScript-中的-6-大内置（函数）对象的原型继承" class="headerlink" title="补充：JavaScript 中的 6 大内置（函数）对象的原型继承"></a>补充：JavaScript 中的 6 大内置（函数）对象的原型继承</h2><p>通过前文的论述，结合相应的代码验证，整理出以下原型链图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/dsJdGM.jpg" alt="alt"></p><p>由此可见，我们更加强化了这两个观点；</p><p>1、任何内置函数对象（类）本身的 __proto__ 都指向 Function 的原型对象；</p><p>2、除了 Object 的原型对象的 __proto__ 指向 null，其他所有内置函数对象的原型对象的 __proto__ 都指向 Object.prototype；</p><p>请看以下代码：</p><p><em><strong>Array</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ == <span class="built_in">Array</span>.prototype)   <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__== <span class="literal">null</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><em><strong>RegExp</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(reg.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(reg.__proto__ == <span class="built_in">RegExp</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><em><strong>Date</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(date.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(date.__proto__ == <span class="built_in">Date</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><em><strong>Boolean</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boo = <span class="keyword">new</span> <span class="built_in">Boolean</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(boo.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(boo.__proto__ == <span class="built_in">Boolean</span>.prototype) <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><em><strong>Number</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Number</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><em><strong>String</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(str.__proto__ == <span class="built_in">String</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>若 A 通过 new 创建了 B，那么 B.__proto__ == A.prototype；</li><li>__proto__ 是原型链查找的起点；</li><li>执行 B.a，若在 B 中找不到 a，则会在 B.__proto__ 中，也就是 A.prototype 中查找，若 A.prototype 中仍然没有，则会继续向上查找，最终，一定会找到 Object.prototype，倘若还找不到，因为 Object.prototype.__proto__ 指向 null，因此一定会返回 undefined。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：Map 和 Set</title>
      <link href="/2021/07/01/JS%EF%BC%9AMap%20%E5%92%8C%20Set/"/>
      <url>/2021/07/01/JS%EF%BC%9AMap%20%E5%92%8C%20Set/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：Map-和-Set"><a href="#JS：Map-和-Set" class="headerlink" title="JS：Map 和 Set"></a>JS：Map 和 Set</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map是JS(ES6)的一种字典数据结构，key值不重复，如果有重复，就会覆盖前面的，任何值都可以作为Map的key，包括对象，字符，数字，NaN，symbol。</p><p>Map跟Object很像，但是Object只能用string / symbol作为key，Map可以通过size获取键值个数，而Object只能手动计算。</p><p>在JS中，NaN === NaN是false，不过在Map中，NaN却被认为是同一个key：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>但是对于Object的Key，不同的对象，代表的key值不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().set(&#123;&#125;, <span class="number">1</span>).set(&#123;&#125;, <span class="number">2</span>).size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Map有以下3种创建方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emptyMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">.set(<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">.set(<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>)</span><br></pre></td></tr></table></figure><p>复制Map：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">.set(<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="keyword">new</span> <span class="built_in">Map</span>(original);</span><br></pre></td></tr></table></figure><p>通过 key 拿到 value：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 123</span></span><br><span class="line">map.get(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>其他 Map 的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .has() checks if a Map has an entry with a given key</span></span><br><span class="line">map.has(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .delete() remove entries</span></span><br><span class="line">map.delete(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">map.has(<span class="string">&#x27;foo&#x27;</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .size retrun the number of entries in a Map</span></span><br><span class="line">map1.size; <span class="comment">//2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .clear() removes all entries of a Map</span></span><br><span class="line">map1.clear();</span><br><span class="line">map1.size; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">  .set(<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .keys() returns an iterable over the keys of a Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">of</span> map2.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// output: false true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we can use spreading(...) to convert iterable returned by .keys() to an Array</span></span><br><span class="line">[... map2.keys()] <span class="comment">// [false, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .values() quite like .keys(), but for values instead of keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.entries() return an interable over the entries of a Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map2.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">//output:</span></span><br><span class="line">    <span class="comment">//[false, &#x27;no&#x27;]</span></span><br><span class="line">    <span class="comment">//[ture, &#x27;yes&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we can use sperading(...) to convert iterable returned by .entries() to an Array;</span></span><br><span class="line">[...map.entries()] <span class="comment">// [[false, &#x27;no&#x27;], [true, &#x27;yes&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we also can use below way to access key and value</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">    <span class="comment">// output:</span></span><br><span class="line">    <span class="comment">//false, &#x27;no&#x27;</span></span><br><span class="line">    <span class="comment">//true, &#x27;yes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要 Map 只含有 strings 和 symbols 作为 key，那么就可以直接把这个 Map 转为 Object：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map); <span class="comment">// &#123; a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><p>也可以把 Object 转换为 Map：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// new Map([[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]])</span></span><br></pre></td></tr></table></figure><p>应用：计算字符串中，字符出现的次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countChars</span>(<span class="params">chars: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> charsCounts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> chars) &#123;</span><br><span class="line">    ch = ch.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> prevCount = charCounts.get(ch);</span><br><span class="line">    charCounts.set(ch, prevCount ? prevCount + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> charsCounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要像数组一样，map 和 filter，那么就必须要把 Map 先转化成为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">.set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">.set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mappedMap = <span class="keyword">new</span> <span class="built_in">Map</span>( <span class="comment">//step 3</span></span><br><span class="line">[...originalMap] <span class="comment">// step 1</span></span><br><span class="line">  .map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v]) <span class="comment">// step 2</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 相当于：new Map([[2, &#x27;_a&#x27;], [4, &#x27;_b&#x27;], [6, &#x27;_c&#x27;]])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredMap = <span class="keyword">new</span> <span class="built_in">Map</span>( <span class="comment">// step 3</span></span><br><span class="line">[...originalMap] <span class="comment">// step 1</span></span><br><span class="line">  .filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>) <span class="comment">// step 2</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 相当于：new Map([[1, &#x27;a&#x27;], [2, &#x27;b&#x27;]])</span></span><br></pre></td></tr></table></figure><p>如果想要合并两个 Map：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">&#x27;1a&#x27;</span>)</span><br><span class="line">.set(<span class="number">2</span>, <span class="string">&#x27;1b&#x27;</span>)</span><br><span class="line">.set(<span class="number">3</span>, <span class="string">&#x27;1c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="number">2</span>, <span class="string">&#x27;2b&#x27;</span>)</span><br><span class="line">.set(<span class="number">3</span>, <span class="string">&#x27;2c&#x27;</span>)</span><br><span class="line">.set(<span class="number">4</span>, <span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combinedMap = <span class="keyword">new</span> <span class="built_in">Map</span>([...map1, ...map2]);</span><br><span class="line"><span class="comment">// 相当于：new Map([[1, &#x27;1a&#x27;], [2, &#x27;2b&#x27;], [3, &#x27;2c&#x27;], [4, &#x27;2d&#x27;]])</span></span><br></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 跟 Map 非常像，只不过多了以下限制：</p><ul><li><p>WeakMap 就是一个黑盒子</p><ul><li>我们不能直接通过 keys / values / entries 来 iterate 或者是 loop WeakMap，并且不能计算它的size。</li><li>我们不能清除 WeakMap，如有需要，只能重新创建一个。</li></ul></li><li><p>WeakMap 的 key，必须是 objects</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(<span class="number">123</span>, <span class="string">&#x27;test&#x27;</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure></li><li><p>WeakMap 的 key 是弱饮用</p><ul><li><p>正常来说，如果有对象还被引用，那么就不会被垃圾回收。但是 WeakMap 不一样，在 object 作为 key 的时候，是可以被垃圾回收的，这会导致整个 entry 也被删掉，并且这个没有办法检测到这种行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  vm.set(obj, <span class="string">&#x27;attachedValue&#x27;</span>); <span class="comment">// (A)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (Bc)</span></span><br></pre></td></tr></table></figure><p>在 (A) 这一行我们给 obj 这个 key 赋值，但是在 (B) 这一行，obj 这个 entry 就有可能被垃圾回收掉了，但是 vm 还在，并且没有办法手动删掉 vm</p></li></ul><p>应用：</p><ul><li><p>用 WeakMap 来保存计算结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countOwnKeys</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(obj))  &#123;</span><br><span class="line">    <span class="keyword">return</span> [cache.get(obj), <span class="string">&#x27;cached&#x27;</span>];</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">    cache.set(obj, count);</span><br><span class="line">    <span class="keyword">return</span> [count, <span class="string">&#x27;computed&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 WeakMap 来保存 private data</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">counter, action</span>)</span> &#123;</span><br><span class="line">        _counter.set(<span class="built_in">this</span>, counter);</span><br><span class="line">        _action.set(<span class="built_in">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = _counter.get(<span class="built_in">this</span>);</span><br><span class="line">        counter--;</span><br><span class="line">        _counter.set(<span class="built_in">this</span>, counter);</span><br><span class="line">        <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">            _action.get(<span class="built_in">this</span>)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakMap 的方法有：</p></li><li><p>new WeakMap( )</p></li><li><p>.delete( key )</p></li><li><p>.get( key )</p></li><li><p>.has( key )</p></li><li><p>.set( key, value )</p></li></ul></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 跟数组很像，但是成员的值都是唯一的，没有重复的值，并且 Set 对象允许存储任何类型的值，无论是原始值或者是对象引用。Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><p>有以下三种方式创建 Set：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emptySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">.add(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">.add(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">.add(<span class="string">&#x27;blue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>常用的 Set 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .add() adds an element to a Set</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> set();</span><br><span class="line">set.add(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .has() checks if an elements is a member of a Set</span></span><br><span class="line">set.has(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .delete() removes an element from a Set</span></span><br><span class="line">set.delete(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">set.has(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .size contains the number of elements in a Set</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  .add(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  .add(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">set1.size; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .clear() removes all elements of a Set</span></span><br><span class="line">set1.clear(); </span><br><span class="line">set1.size; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterating over Sets</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> set2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="comment">//outouts:</span></span><br><span class="line">    <span class="comment">//&#x27;red&#x27;</span></span><br><span class="line">    <span class="comment">//&#x27;green&#x27;,</span></span><br><span class="line">    <span class="comment">//&#x27;blue&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use spreading(...) to convert set to array</span></span><br><span class="line"><span class="keyword">const</span> set3 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...set3]; <span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure><p>应用</p><p>移除数组中的重复项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set4 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...set4]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>字符串是 iterable，所以也可以作为 Set 的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]); <span class="comment">// 这两个是一样的</span></span><br></pre></td></tr></table></figure><p>NaN 对于 Set 来说也是一个值，对于任何 Object 都是不同的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]);</span><br><span class="line">set.size; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([&#123;&#125;, &#123;&#125;]);</span><br><span class="line">set1.size; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Union 两个 Set：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]); <span class="comment">// new Set([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><p>Intersection 两个 Set：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(</span><br><span class="line">[...a]</span><br><span class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x))</span><br><span class="line">); <span class="comment">// new Set([2, 3])</span></span><br></pre></td></tr></table></figure><p>Difference 两个 Set：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>(</span><br><span class="line">  [...a]</span><br><span class="line">  .filter(<span class="function"><span class="params">x</span>=&gt;</span> !b.has(x))</span><br><span class="line">); <span class="comment">// new Set([1, 4])</span></span><br></pre></td></tr></table></figure><p>Mapping over Set:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> mappedSet = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span>=&gt;</span>x*<span class="number">2</span>)); <span class="comment">// new Set([2,4,6])</span></span><br></pre></td></tr></table></figure><p>Filtering Set:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> filteredSet = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">x</span>=&gt;</span>(x%<span class="number">2</span>)===<span class="number">0</span>)); <span class="comment">// new Set([2,4])</span></span><br></pre></td></tr></table></figure><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 跟 Set 很像，只不过多了下面的限制：</p><ul><li>WeakSet 是个黑盒子<ul><li>我们不能直接通过 keys / values / entries 来 iterate 或者 loop WeakMap，并且不能计算它的size。</li><li>我们不能清除 WeakSet，如有需要，只能重新创建一个。</li></ul></li><li>WeakSet 的 key 是弱引用<ul><li>正常来说，如果有对象还被引用，那么就不会 被垃圾回收。但是 WeakSet 不一样，在 object 作为 key 的时候，是可以被垃圾回收的，这会导致整个 entry 也被删掉，并且这个没有办法检测到这种行为</li></ul></li></ul><p>WeakSet 的方法有：</p><ul><li>new WeakSet( )</li><li>.delete( value )</li><li>.get( value )</li><li>.has( value )</li><li>.set( value )</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：从执行上下文视角讲解 this</title>
      <link href="/2021/07/01/JS%EF%BC%9A%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%86%E8%A7%92%E8%AE%B2%20this/"/>
      <url>/2021/07/01/JS%EF%BC%9A%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%86%E8%A7%92%E8%AE%B2%20this/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：从执行上下文视角讲-this"><a href="#JS：从执行上下文视角讲-this" class="headerlink" title="JS：从执行上下文视角讲 this"></a>JS：从执行上下文视角讲 this</h1><p>观察以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    <span class="attr">myName</span>:<span class="string">&quot;time.geekbang.com&quot;</span>,</span><br><span class="line">    <span class="attr">printName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myName)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">return</span> bar.printName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line"><span class="keyword">let</span> _printName = foo()</span><br><span class="line">_printName()</span><br><span class="line">bar.printName()</span><br></pre></td></tr></table></figure><p>这里其实是个障眼法，只需要确定好函数调用栈就可以轻松地回答，调用了 foo( ) 后，返回的是 bar.printName，后续就跟 foo 函数没有关系了，所以结果就是调用了两次 bar.printName( ) 函数，根据词法作用域，结果都是 “极客邦”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构确定的。</p><p>不过按照常理来说，调用 bar.printName 方法时，该方法内部的变量 myName 应该使用 bar 对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的。所以在对象内部的方法中使用对象内部的属性是一种非常普遍的的需求，但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出了另外一套 this 机制。</p><p>所以在 JavaScript 中可以使用 this 实现在 printName 函数中访问到 bar 对象中的 myName 属性了。具体的代码，如下显示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript-中的-this"><a href="#JavaScript-中的-this" class="headerlink" title="JavaScript 中的 this"></a>JavaScript 中的 this</h2><p>关于 this，我们还是得从执行上下文说起，其实执行上下文中包含了变量环境、词法环境、外部环境，但其实还有一个 this 没有提及，具体可以参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/VZ8Dym.jpg" alt="alt"></p><p>从图中可以看出，this 是和执行上下文绑定的，也就是说每个执行上下文都有一个 this。执行上下文包含了：全局执行上下文、函数执行上下文、eval执行上下文。</p><h2 id="全局执行上下文中的-this"><a href="#全局执行上下文中的-this" class="headerlink" title="全局执行上下文中的 this"></a>全局执行上下文中的 this</h2><p>全局执行上下文中输入 console.log( this )，最终输出的是 window 对象，这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。</p><h2 id="函数执行上下文中的-this"><a href="#函数执行上下文中的-this" class="headerlink" title="函数执行上下文中的 this"></a>函数执行上下文中的 this</h2><p>重点分析函数执行上下文，先看代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这段代码打印出来的也是 window 对象，这说明在默认情况下调用一个函数，其执行上下文也是指向 window 对象的。但是我们可以设置执行上下文中的 this 来指向其他对象，通常有三种方式来设置函数执行上下文中的 this 值。</p><h3 id="1、通过函数的-call-方法设置"><a href="#1、通过函数的-call-方法设置" class="headerlink" title="1、通过函数的 call 方法设置"></a>1、通过函数的 call 方法设置</h3><p>可以通过函数的 call 方法来设置函数执行上下文的 this 指向，比如下面的这段代码，我们就并没有直接调用 foo 函数，而是调用了 foo 的call 函数，并将 bar 对象作为 call 方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot; 极客邦 &quot;</span>,</span><br><span class="line">  <span class="attr">test1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar)</span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="built_in">console</span>.log(myName)</span><br></pre></td></tr></table></figure><p>执行这段代码，观察输出，就可以发现 foo 函数内部的 this 已经指向了 bar 对象，因为通过打印 bar 对象，可以看出 bar 的 myName 属性已经由 “极客邦” 变为 “极客时间” 了，同时在全局执行上下文中打印 myName，JavaScript 引擎提示该变量未定义。</p><p>其实除了 call 方法，还可以使用 bind 和 apply 方法来设置函数执行上下文的 this，它们在使用上还是有一些区别的。</p><h3 id="2、通过对象调用方法设置"><a href="#2、通过对象调用方法设置" class="headerlink" title="2、通过对象调用方法设置"></a>2、通过对象调用方法设置</h3><p>要改变函数执行上下文中的 this 指向，除了通过函数的 call 方法来实现以外，还可以通过对象调用的方式，比如下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个 myObj 对象，该对象是由一个 name 属性和一个 showThis 方法组成的，然后再通过 myObj 对象来调用 showThis 方法。执行这段代码，你可以看到，最终输出的 this 值是指向 myObj 的。</p><p>所以，你可以得出这样的结论：使用对象来调用其内部的方法，该方法的 this 是指向对象本身的。</p><p>也可以这样认为 JavaScript 引擎在执行 myObject.showThis( ) 时，将其转化为了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.showThis.call(myObj)</span><br></pre></td></tr></table></figure><p>接下来我们稍微改变下调用方式，把 showThis 赋给一个全局对象，然后再调用该对象，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot; 极客邦 &quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj.showName;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>执行这段代码，你会发现 this 指向又是全局 window 对象。</p><p>所以通过以上两个例子的对比，你可以得出下面这样的结论：</p><p>在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。</p><p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。</p><h3 id="3、通过构造函数中设置"><a href="#3、通过构造函数中设置" class="headerlink" title="3、通过构造函数中设置"></a>3、通过构造函数中设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;极客时间&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObje = <span class="keyword">new</span> CreateObj();</span><br></pre></td></tr></table></figure><p>在这段代码中，使用了 new 创建了对象 myObj。</p><p>其实，当执行 new CreateObj( ) 的时候，JavaScript 引擎做了如下四件事：</p><ul><li>首先创建了一个空对象 tempObj；</li><li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；</li><li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li><li>最后返回 tempObj 对象；</li></ul><p>为了直观理解，我们用代码来演示一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure><p>这样，我们就通过 new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。</p><h2 id="this-的设计缺陷以及应对方案"><a href="#this-的设计缺陷以及应对方案" class="headerlink" title="this 的设计缺陷以及应对方案"></a>this 的设计缺陷以及应对方案</h2><p>this 并不是一个很好的设计，因为它很多使用方法都冲击人的直觉，在使用过程中比较多坑，下面来看看 this 的设计缺陷</p><h3 id="1、嵌套函数中的-this-不会从外层函数中继承"><a href="#1、嵌套函数中的-this-不会从外层函数中继承" class="headerlink" title="1、嵌套函数中的 this 不会从外层函数中继承"></a>1、嵌套函数中的 this 不会从外层函数中继承</h3><p>分析一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure><p>我们在这段代码的 showThis 方法中添加了一个 bar 方法，然后接着在 showThis 函数中调用了 bar 函数，那么现在的问题是：bar 函数中的 this 是什么？</p><p>如果是刚刚接触 JavaScript，那么会很自然地觉得，bar 中的 this 应该和其外层 showThis 函数中的 this 是一致的都是指向 myObj 对象，这很符合人的直觉。但是实际情况却并非如此，执行这段代码后，发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象，这就是 JavaScript 中容易让人迷惑的地方之一，也是很多问题的源头。</p><p>可以通过一个小技巧来解决这一个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      self.name = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure><p>执行这段代码，你会发现它也输出了我们想要的结果，最终 myObj 中的 name 属性值变成了 “极客邦”。其实这个方法的本质就是把 this 体系转换成了作用域体系。</p><p>同样的也可以使用 ES6 中的箭头函数来解决这个问题，结合一下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure><p>执行这段代码，会发现它也输出了我们想要的结果，也就是说箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p><p>通过上面的讲解，你应该知道了 this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。解决这个问题，有两种思路：</p><ul><li>把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。</li><li>继续使用 this，但是需要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。</li></ul><h3 id="2、普通函数中的-this-默认指向全局对象-window"><a href="#2、普通函数中的-this-默认指向全局对象-window" class="headerlink" title="2、普通函数中的 this 默认指向全局对象 window"></a>2、普通函数中的 this 默认指向全局对象 window</h3><p>在默认情况下，调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。</p><p>不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式就是说通过 call 方法来实现调用。</p><p>这个问题可以通过设置 JavaScript 的 “严格模式” 来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是undefined，这就解决上面的问题了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：作用域链和闭包</title>
      <link href="/2021/07/01/JS%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8CJS%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/"/>
      <url>/2021/07/01/JS%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8CJS%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择"><a href="#JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择" class="headerlink" title="JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择"></a>JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择</h1><p>理解作用域链时理解闭包的基础，而闭包在 JavaScript 中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。</p><p>首先先来看这一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>你觉得这段代码中的 bar 函数和 foo 函数打印出来的是什么吗？</p><p>分析代码，当代码执行到 bar 函数内部，调用栈的状态如图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/7amvbs.jpg" alt="alt"></p><p>从图中可以看出，全局执行上下文和 foo 函数的执行上下文中都包含变量 myName，那 bar 函数中的 myName应该选择哪一个呢？这里就需要了解作用域链了。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>其实每一个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部因你用哪个称为 outer。</p><p>当一段代码使用了一个变量，JavaScript 引擎首先会在“当前执行上下文”中查找该变量，比如上面的那段代码在查找 myName 变量时，如果在当前的变量环境中没有查到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以直接看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/zRdlhw.jpg" alt="alt"></p><p>从图中可以看到，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎就会去全局执行上下文中查找。我们把这个查找的链条就称作为作用域链。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><em><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong></em></p><p>可以直接看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/zcmf66.jpg" alt="alt"></p><p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域 -&gt; bar 函数作用域 -&gt; main 函数作用域 -&gt; 全局作用域。</p><p>回过头看上边的代码，foo 函数调用了 bar 函数，但是 bar 函数的外部引用是全局执行上下文。</p><p>因为词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个没有定义的变量，那么它们就会到全局作用域中寻找，故，词法作用域是代码阶段就决定好的，和函数的调用没有关系。</p><h2 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客世界 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> myName = <span class="string">&quot;Chrome 浏览器 &quot;</span></span><br><span class="line">        <span class="built_in">console</span>.log(test)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">        bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中，对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，调用栈的情况如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/%E4%B8%8B%E8%BD%BD.png" alt="alt"></p><p>现在是执行到 bar 函数的 if 语句块之内，需要打印出来的变量 test，那么久需要查找到 test 变量的值，其查找过程我已经在上图中使用了序号1、2、3、4、5标记出来了。</p><p>下面我就来解释一下这个过程。首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有 定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>了解了作用域链，接着就可以了解闭包了。关于闭包，理解起来稍微有一点难度。结合以下代码就可以理解什么是闭包了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure><p>首先我们看看当执行到 foo 函数内部的 return innerBar 这行代码时，调用栈的情况你可以参考此图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/uPznOY.jpg" alt="alt"></p><p>从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。</p><p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数结束了，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/20NJwJ.jpg" alt="alt"></p><p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然存在在内存当中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p><p>之所以时专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。</p><p>最后给闭包完整的定义，在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合统称为闭包。比如外部函数 foo，那么这些变量的集合就称为 foo 函数的闭包。</p><p>闭包的使用。当执行到 bar.setName 方法中的 myName = “极客邦” 这句代码时，JavaScript 引擎会沿着 “当前执行上下文 -&gt; foo 函数闭包 -&gt; 全局执行上下文” 的顺序来查找 myName 变量，你可以参考下面调用栈状态图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/RxMYdM.jpg" alt="alt"></p><p>从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以当调用 setName 时，会修改 foo 闭包中的 myName 变量的值。</p><p>同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。</p><p>可以通过 “开发者工具” 来看看闭包的情况，打开 Chrome 的 “开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/cEAEuG.jpg" alt="alt"></p><p>从图中可以看出来，当调用 bar.getName 的时候，右边 Scope 就体现了作用域链的情况：Local 就是当前的 getName 函数的作用域，Closure( foo )是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从 “Local -&gt; Closure( foo ) -&gt; Global” 就是一个完整的作用域链。</p><p>所以，可以通过 Scope 来查看实际代码作用域链的情况。</p><h2 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h2><p>一般来说，当某个函数被调用时，会创建 <span style="background: yellow">一个执行环境</span>  (excution context) 及 <span style="background: yellow">相应的作用域链</span> 。然后使用 <span style="background: green">arguments</span> 和 <span style="background: green">其他命名参数的值</span> 来初始化 函数的 <span style="background: green">活动对象 (activation object)</span> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>代码的作用域链如下图所示：</p><p>1、<span style="color: green">活动对象</span> 包含 <span style="color: green">arguments</span> 和 <span style="color: green">参数</span> </p><p>2、全局 <span style="color: orange">变量对象</span> 包含 <span style="color: orange">函数名</span> 和 <span style="color: orange">变量</span> </p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/iRrx6Q.jpg" alt="alt"></p><p>在创建 <code>compare()</code> 函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的 <code>[[Scope]]</code> 属性中，当调用 <code>compare()</code> 函数时，会为函数创建一个执行环境，然后通过复制函数的 <code>[[Scope]]</code> 属性中的对象来构建起执行环境的作用域链。此后，又有一个活动对象 (在此作为变量对象使用) 被创建并且被推入执行环境作用域的前端。对于这个例子中的 <code>compare()</code> 函数的执行环境而言，其作用域链中包含两个变量对象：<strong>本地活动对象</strong>和<strong>全局变量对象</strong>。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象！！！</p><p>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存只能够仅保存全局作用域 (全局执行环境的变量对象) 。但是，<strong>闭包的情况又有所不同</strong> 。看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在另一个函数内部定义的函数会将包含函数 (即外部函数) 的活动对象添加到它的作用域链中，因此，在 <code>createComparisonFunction()</code> 函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 <code>createComparisonFunction()</code> 的活动对象。(活动对象包含 arguments 和 参数)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123;<span class="attr">name</span>:<span class="string">&quot;Nicholas&quot;</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">&quot;Greg&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>在匿名函数从 <code>createComparisonFunction()</code> 中被返回后，他的作用域链被初始化为包含 <code>createComparisonFunction()</code> 函数的活动对象和全局变量对象。这样，匿名函数就可以访问在 <code>createComparisonFunction()</code> 中定义的所有变量。更为重要的是，<code>createComparisonFunction()</code> 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象，换句话说，当 <code>createComparisonFunction()</code> 函数返回后，其执行环境的作用域链就会被销毁，但他的活动对象还会留在内存；直到匿名函数被销毁后，<code>createComparisonFunction()</code> 的活动对象才会被销毁，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建函数，这里 返回的 是一个 匿名函数 赋值给 compareNames</span></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 调用 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123;<span class="attr">name</span>:<span class="string">&quot;Nicholas&quot;</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">&quot;Greg&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除 对 匿名函数 的 引用（以便 释放 内存）</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>首先，<code>createComparisonFunction()</code> 返回的匿名函数保存在变量 <code>compareNames</code> 中，而通过将 <code>compareNames</code> 设置为 <code>null</code> 解除该函数的引用，就等于通知垃圾回收线程将其清除。随着匿名函数的作用域被销毁，其他作用域 (除了全局作用域) 也都可以安全地销毁了。</p><h2 id="闭包的回收"><a href="#闭包的回收" class="headerlink" title="闭包的回收"></a>闭包的回收</h2><p>通常如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但是如果这个闭包以后不再使用就会导致内存泄漏。</p><p>所以在使用闭包的时候，尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存比较大的话，那就尽量让它成为一个局部变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：块级作用域，let、const 的必要性</title>
      <link href="/2021/07/01/JS%EF%BC%9A%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cvar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5let%E3%80%81const/"/>
      <url>/2021/07/01/JS%EF%BC%9A%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cvar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5let%E3%80%81const/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：块级作用域，var缺陷以及为什么引入let、const"><a href="#JS：块级作用域，var缺陷以及为什么引入let、const" class="headerlink" title="JS：块级作用域，var缺陷以及为什么引入let、const"></a>JS：块级作用域，var缺陷以及为什么引入let、const</h1><h2 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h2><p><strong>作用域是指在程序中定义变量的区域，该位置决定了变量的声明周期，通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</strong></p><p>在 ES6 之前，ES 的作用域只有两种，全局作用域和函数作用域。</p><ul><li>全局作用域中的对象在代码中的任何地方都能访问，其声明周期伴随着页面的声明周期。</li><li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或函数只能在函数内部被访问。函数执行结束后，函数内部定义的变量就会被销毁。</li></ul><p>在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则普遍支持块级作用域。块级作用域就是使用一对大括号包裹的代码，比如函数、判断语句、循环语句、甚至单独的一个 { } 都可以被看作一个块级作用域。</p><p>为了更好地理解块级作用域，参考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if块</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while块</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//for循环块</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独一个块</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>简单来说，如果一个语言支持块级作用域，那么其代码块内部定义的变量在代码块外是访问不到的，并且等该代码块执行完成后，代码块中定义的变量会被销毁。</p><h2 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h2><p>由于变量提升的问题，使用 JavaScript 来编写和其他语言相同的逻辑的代码，都有可能产生不一样的结果。主要有以下两种原因</p><h3 id="1、变量容易在不被察觉的情况下被覆盖掉"><a href="#1、变量容易在不被察觉的情况下被覆盖掉" class="headerlink" title="1、变量容易在不被察觉的情况下被覆盖掉"></a>1、变量容易在不被察觉的情况下被覆盖掉</h3><p>比如我们使用 JavaScript 实现以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot;极客时间&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> myname = <span class="string">&quot;极客邦&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">&#125;</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><p>打印出来的结果是 undefined 。</p><p>直接展示最终的调用栈状态如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/iZeQCb.jpg" alt="alt"></p><p>showName 函数的执行上下文创建后，JavaScript 引擎便开始执行 showName 函数内部的代码了。首先执行的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myname);</span><br></pre></td></tr></table></figure><p>JavaScript 会优先从当前的执行上下文中查找变量，由于变量提升，所以当前执行上下文就包括了变量 myname，并且值是 undefined。所以获取得到的值就是 undefined。</p><h3 id="2、本应销毁的变量没有销毁"><a href="#2、本应销毁的变量没有销毁" class="headerlink" title="2、本应销毁的变量没有销毁"></a>2、本应销毁的变量没有销毁</h3><p>再看看这一段误解更大的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>如果使用 C语言或者其他大部分的语言实现类似的代码，在for循环结束之后，i 就已经被销毁了，但是在JavaScript 代码中，i 的值未被销毁，所以最后打印出来的值为 7 。</p><h2 id="ES6-如何解决变量提升带来的问题"><a href="#ES6-如何解决变量提升带来的问题" class="headerlink" title="ES6 如何解决变量提升带来的问题"></a>ES6 如何解决变量提升带来的问题</h2><p>为了解决变量提升带来的问题，ES6 引入了 let 和 const 关键字，使得 JavaScript 也像其他语言一般拥有了块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">6</span></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">y = <span class="number">9</span> <span class="comment">//报错，const声明的变量不可以修改</span></span><br></pre></td></tr></table></figure><p>从这段代码中，可以看出使用 let 关键字的变量可以改变值，使用 const 关键字的变量则不可以改变的。</p><p>参考一段存在变量提升的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有两个地方定义了变量 x，由于使用 var 关键字，在编译阶段会生成如下的执行上下文</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/6r82N9.jpg" alt="alt"></p><p>最终只生成了一个 x 值，并且函数体内所有对 x 的赋值操作都会直接改变变量环境中的 x 值。所以上述代码最后通过console.log( x )输出的应该是 2 。而其他语言最后一步输出的应该是 1。如果要让他支持块级作用域只需要将 var 关键字改成 let 关键字即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码的输出结果就和我们的预期是一致的。</p><h2 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h2><p>观察以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>当执行上面这段代码的时候，JavaScript 引擎线对其进行编译并创建上下文，然后再按照顺序执行代码，关于如何创建上下文已经分析过了，但是现在的情况有点不一样，let 关键字会创建块级作用域，那么 let 关键字如何影响执行上下文的，接下来一步步分析</p><p><strong>第一步、编译并创建执行上下文</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/ZuNPJi.jpg" alt="alt"></p><p>通过上图，可以得出结论：</p><ul><li>函数内部通过 <strong>var</strong> 声明的变量，在编译阶段全被存到变量环境当中。</li><li>通过 <strong>let</strong> 声明的变量，在编译阶段会存放到 <strong>词法环境（Lexical Environment）</strong>中。</li><li>在函数的作用域内部，通过 <strong>let</strong> 声明的变量没有被存放到词法环境中。</li><li>继续执行代码，当执行到代码块中，变量环境中的a已经设置为1，词法环境中的b设置为了2。</li></ul><p>这时函数的执行上下文就如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/yjmTSJ.jpg" alt="alt"></p><p>从图中可以看出，当进入了函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</p><p>其实，在词法环境内部，维护了一个小型栈结构，栈底是最外层的变量，进入了一个作用域中，就会把该作用域内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意一下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p><p>再接下来，当执行到作用域块中的console.log( a )这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方法：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有找到，那么继续在变量环境中查找。</p><p>这样一个变量查找的过程就完成了，你可以参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/ChGluo.jpg" alt="alt"></p><p>从上图可以清晰看到查找变量的流程，不过要完整理解查找变量或者查找函数的流程，就需要涉及到作用域链了。</p><p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/vpNfIR.jpg" alt="alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：展开运算符</title>
      <link href="/2021/07/01/JS%EF%BC%9A%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/07/01/JS%EF%BC%9A%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：展开运算符"><a href="#JS：展开运算符" class="headerlink" title="JS：展开运算符"></a>JS：展开运算符</h1><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符 ( . . . )"></a>展开运算符 ( . . . )</h2><p>展开运算符，是 ES6 中的新语法，是把可迭代的对象 ( string, object, 数组 )展开，可以用在函数调用 / 数组构造的时候，将数组表达式 / string 在语法层面展开，还可以将对象表达式按照 key-value 的方式展开。</p><p>展开运算符只能用于可迭代对象。</p><p><strong>函数调用：</strong></p><p>假如你把 . . . 放在函数的参数里，就说明这个参数必须是 interable object，然后这个对象就会被展开成为函数的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> someIterable = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">func(...someIterable);</span><br><span class="line"><span class="comment">// same as func(&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(-<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(...[-<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(-<span class="number">1</span>, ...[-<span class="number">5</span>, <span class="number">11</span>], <span class="number">3</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr1.push(...arr2); <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>数组构造或字符串</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...numbers, <span class="string">&#x27;4&#x27;</span>, ...<span class="string">&#x27;hello&#x27;</span>, <span class="number">6</span>];) <span class="comment">// Array [1, 2, 3, &quot;4&quot;, &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parts = [<span class="string">&#x27;shoulders&#x27;</span>, <span class="string">&#x27;knees&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> lyrics = [<span class="string">&#x27;head&#x27;</span>, ...parts, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;toes&#x27;</span>]; <span class="comment">//  [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr];</span><br><span class="line">arr2.push(<span class="number">4</span>); <span class="comment">// arr2 此时变成了 [1,2,3,4]. arr不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接多个数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2]; <span class="comment">// [0,1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象拷贝（浅拷贝，并且不包含prototype）和合并</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>:<span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">foo</span>:<span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>:<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> cloneObj = &#123;...obj1&#125;; <span class="comment">// &#123;foo:&#x27;bar&#x27;, x:42&#125;</span></span><br><span class="line"><span class="keyword">var</span> mergeObj = &#123;...obj1, ...obj2&#125;; <span class="comment">// &#123;foo:&#x27;baz&#x27;, x:42, y:13&#125;</span></span><br></pre></td></tr></table></figure><p><strong>函数参数收集</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 foo([1, 2, 3, 4, 5, 6])</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><strong>为对象增加属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> basicSquirtle = &#123; <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> fullSquirtle = &#123;</span><br><span class="line">  ...basicSquirtle,</span><br><span class="line">  <span class="attr">species</span>: <span class="string">&#x27;Tiny Turtle&#x27;</span>,</span><br><span class="line">  <span class="attr">evolution</span>: <span class="string">&#x27;Wartortle&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullSquirtle); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, species: &#x27;Tiny Turtle&#x27;, evolution: &#x27;Wartortle&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>复制具有嵌套结构的数据 / 对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span>,</span><br><span class="line">  <span class="attr">abilities</span>: [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain Dish&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon &#125;;</span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">&#x27;Charmander&#x27;</span>;</span><br><span class="line">pokemon.abilities.push(<span class="string">&#x27;Surf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squirtleClone); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, abilities: [ &#x27;Torrent&#x27;, &#x27;Rain Dish&#x27;, &#x27;Surf&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><p>当我们修改原对象的 name 属性时，我们的克隆对象的 name 属性没有受到影响，这个符合预期。</p><p>但是当我们修改原对象的 abilities 属性时，我们的克隆对象也被修改了。</p><p>原因很简单，因为复制过来的 abilities 时一个引用类型，原数据改了，用到它的地方也会跟着改。</p><p>知道原因，再解决就很简单了</p><p><strong>复制引用类型的数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span>,</span><br><span class="line">  <span class="attr">abilities</span>: [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain Dish&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon, <span class="attr">abilities</span>: [...pokemon.abilities] &#125;;</span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">&#x27;Charmander&#x27;</span>;</span><br><span class="line">pokemon.abilities.push(<span class="string">&#x27;Surf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squirtleClone); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, abilities: [ &#x27;Torrent&#x27;, &#x27;Rain Dish&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><p><strong>增加条件属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abilities = [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain dish&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPokemon = abilities ? &#123; ...pokemon, abilities &#125; : pokemon;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullPokemon);</span><br></pre></td></tr></table></figure><p><strong>短路</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abilities = [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain dish&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPokemon = &#123;</span><br><span class="line">  ...pokemon,</span><br><span class="line">  ...(abilities &amp;&amp; &#123; abilities &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullPokemon);</span><br></pre></td></tr></table></figure><p>如果 abilities 为 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullPokemon = &#123;</span><br><span class="line">  ...pokemon,</span><br><span class="line">  ...&#123; abilities &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：JavaScript 继承原理</title>
      <link href="/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%20JavaScript%20%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86/"/>
      <url>/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%20JavaScript%20%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：深入-JavaScript-继承原理"><a href="#JS：深入-JavaScript-继承原理" class="headerlink" title="JS：深入 JavaScript 继承原理"></a>JS：深入 JavaScript 继承原理</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>我们回顾一下 ES6 /  TypeScript /  ES5 类的写法以做对比。首先我们创建一个 GithubUser 类，它拥有一个 login 方法，和一个静态方法 getPublicServices，用于获取 public 的方法列表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GithubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getPublicServices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username</span><br><span class="line">        <span class="built_in">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + <span class="built_in">this</span>.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，ES6 这个类的写法有一个弊病，密码 password 应该是 Github 用户一个私有变量，接下来用 TypeScript 重写一下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GithubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getPublicServices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> username: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">private</span> password: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username</span><br><span class="line">        <span class="built_in">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> login(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + <span class="built_in">this</span>.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，password 就只能在类的内部访问了。</p><p>结合原型讲解那一篇文章讲解的知识，来用 ES5 来实现这个类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// private属性</span></span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="comment">// public属性</span></span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    <span class="comment">// public方法</span></span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">GithubUser.getPublicServices = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>值得注意的是，我们一般都会把共有的方法放在类的原型上，而不会采用 this.login = function () {} 这种写法。因为只有这样，才能让多个实例引用同一个共有方法，从而避免了重复创建方法的浪费。</strong></em></p><p>留下两个疑问：</p><p>1、如何实现 private 方法</p><p>2、能否实现 protected 属性 / 方法 </p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果创建了一个 JuejinUser 来继承 GithubUser，那么 JuejinUser 及其实例就可以调用 Github 的login 方法了。首先，先写出这个简单的 JuejinUser 类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO need implementation</span></span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先概述几种继承方法：</p><ul><li>类式继承</li><li>构造函数式继承</li><li>组合式继承</li><li>原型继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ul><h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><p><em><strong>若通过 new Parent( ) 创建了 Child，则 Child.__proto__ = Parent.prototype，而原型链则是顺着 __proto__ 依次向上查找。因此，可以通过修改 子类的原型为父类的实例来实现继承</strong></em></p><p>第一直觉的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    JuejinUser.prototype = <span class="keyword">new</span> GithubUser(username, password)</span><br><span class="line">    JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br></pre></td></tr></table></figure><p>在浏览器中查看原型链：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/WMixMl.jpg" alt="alt"></p><p>从上图可以看出，明显 juejinUser1.__proto__ 并不是 GithubUser 的一个实例。</p><p>实际上，JuejinUser.prototype 在定义函数的时候就已经将其指针指向对应的地址，利用构造函数实例化对象的时候，同样地也将 JuejinUser.prototype 当前指向的地址赋给了 juejinUser.__proto__ 这个变量，然而，在构造函数中，将 JuejinUser.prototype 指向了一个新对象的地址，就造成了 JuejinUser.prototype 和 juejinUser.__proto__的指向不一致，一个指向新对象，一个指向旧对象。所以重新赋值一下实例的 __proto__ 就可以解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    <span class="keyword">const</span> prototype = <span class="keyword">new</span> GithubUser(username, password)</span><br><span class="line">    <span class="comment">// JuejinUser.prototype = prototype // 这一行已经没有意义了</span></span><br><span class="line">    prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.__proto__ = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br></pre></td></tr></table></figure><p>接着查看原型链：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/71V7S6.jpg" alt="alt"></p><p>原型链已经出来了，问题好想解决了，但实际上还有问题：</p><p>1、在原型链上创建了属性（这不是一个好的实践）</p><p>2、私自篡改 __proto__，导致 juejinUser1.__proto__ === JuejinUser.prototype 不成立！从而导致了 juejinUser1 instanceof JuejinUser也不成立。</p><p>造成这个问题的根本原因就在于，我们在实例化的时候动态修改了原型，那有没有一种方法可以在实例化之前就固定好类的原型的  reference 呢？</p><p>事实上，我们可以考虑把类的原型的赋值挪出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时构造函数还未运行，无法访问 username 和 password !!</span></span><br><span class="line">JuejinUser.prototype =  <span class="keyword">new</span> GithubUser() </span><br><span class="line"></span><br><span class="line">prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样做又有更明显的缺点：</p><p>1、父类过早被创建，导致无法接受子类的动态参数；</p><p>2、仍然在原型上创建了属性，此时，多个子类的实例将共享一个父类属性，会互相影响；</p><p>举例说明缺点2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.username = <span class="string">&#x27;Unknown&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">JuejinUser.prototype =  <span class="keyword">new</span> GithubUser() </span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> juejinUser2 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;egoist&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  这就是把属性定义在原型链上的致命缺点，你可以直接访问，但修改就是一件难事了！</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// &#x27;Unknown&#x27;</span></span><br><span class="line">juejinUser1.__proto__.username = <span class="string">&#x27;U&#x27;</span> </span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// &#x27;U&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 卧槽，无情地影响了另一个实例!!!</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser2.username) <span class="comment">// &#x27;U&#x27;</span></span><br></pre></td></tr></table></figure><p>由此可见，类式继承的两种方式缺陷太多！</p><h2 id="构造函数式继承"><a href="#构造函数式继承" class="headerlink" title="构造函数式继承"></a>构造函数式继承</h2><p>通过 call( ) 来实现继承（相应的，你也可以用 apply）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password)</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// ulivz</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// xxx</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.login()) <span class="comment">// TypeError: juejinUser1.login is not a function</span></span><br></pre></td></tr></table></figure><p>当然，如果继承那么简单，那么本文就没有存在的必要了，本继承方法也有一个明显的缺陷，那就是 <em><strong>构造函数式继承</strong></em> 并没有继承父类原型上的方法。</p><h2 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h2><p>既然上述两种方法都各有缺点，又各有所长，能否将其结合起来，这种方式就叫做 <em><strong>组合式继承</strong></em>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password) <span class="comment">// 第二次执行 GithubUser 的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JuejinUser.prototype = <span class="keyword">new</span> GithubUser(); <span class="comment">// 第二次执行 GithubUser 的构造函数</span></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br></pre></td></tr></table></figure><p>虽然这种方式弥补了上述两种方式的一些缺陷，但是仍然存在着问题：</p><p>1、子类仍旧无法动态传递参数给父类</p><p>2、父类的构造函数被调用了两次</p><p>本方法很明显执行了两次父类的构造函数，因此，这也不是我们最终想要的继承方式。</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>原型继承实际上是对类式继承的一种封装，只不过其独特之处在于，定义了一个干净的中间类，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改类的原型为o, 于是f的实例都将继承o上的方法</span></span><br><span class="line">    f.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉 ES5 的同学会注意到，这不就是 Object.create( ) 吗？确实可以这样认为。</p><p>既然是类式继承的一种封装，其使用方式自然就是如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JuejinUser.prototype = createObject(GithubUser)</span><br></pre></td></tr></table></figure><p>也就是仍然没有解决类式继承的一些问题。</p><h2 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h2><p>寄生继承是依托于一个对象而生的一种继承方式，因此称之为寄生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> juejinUserSample = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;ulivz&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">     o.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myComputer = <span class="keyword">new</span> CreateComputer(computer);</span><br></pre></td></tr></table></figure><p>由于实际生产中，继承一个单例对象的场景实在是太少了，因此还没有找到最佳的实现方法。</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>先上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生组合式继承的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承父类的原型</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Object</span>.create(parent.prototype)</span><br><span class="line">    <span class="comment">// 重写子类的原型</span></span><br><span class="line">    child.prototype = p</span><br><span class="line">    <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">    p.constructor = child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GithubUser, 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GithubUser, 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password) <span class="comment">// 继承属性</span></span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型上的方法</span></span><br><span class="line">inherit(JuejinUser, GithubUser)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型上添加新方法</span></span><br><span class="line">JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br></pre></td></tr></table></figure><p>浏览器查看结果：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/k1AGHC.jpg" alt="alt"></p><p>简单说明一下：</p><ul><li>子类继承了父类的属性和方法，同时属性没有被创建在原型链上，因此多个子类不会共享同一个属性。</li><li>子类可以传递动态参数给父类。</li><li>父类构造函数只执行了一次。</li></ul><p>然而，还是存在一个美中不足的问题：</p><ul><li>子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖原有原型上的方法，这样的话，如果已经存在的两个类，就不好办了。</li></ul><h2 id="终极版继承"><a href="#终极版继承" class="headerlink" title="终极版继承"></a>终极版继承</h2><p>为了让代码更清晰，我用 ES6 的一些 API，写出了这个我认为最合理的继承方法：</p><ul><li>用 Reflect 代替了 Object；</li><li>用 Reflect.getPrototypeOf 来代替 ob.__proto__</li><li>用 Reflect.ownKeys 来读取所有可枚举 / 不可枚举 / Symbol 的属性</li><li>用 Reflect.getOwnPropertyDescriptor 读取属性描述符</li><li>用 Reflect.setPrototypeOf 来设置 __proto__</li></ul><p>源代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * fancy-inherit</span></span><br><span class="line"><span class="comment"> * (c) 2016-2018 ULIVZ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不同于object.assign, 该 merge方法会复制所有的源键</span></span><br><span class="line"><span class="comment">// 不管键名是 Symbol 或字符串，也不管是否可枚举</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fancyShadowMerge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.defineProperty(target, key, <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(source, key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Core</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> objectPrototype = <span class="built_in">Object</span>.prototype</span><br><span class="line">    <span class="comment">// 继承父类的原型</span></span><br><span class="line">    <span class="keyword">const</span> parentPrototype = <span class="built_in">Object</span>.create(parent.prototype)</span><br><span class="line">    <span class="keyword">let</span> childPrototype = child.prototype</span><br><span class="line">    <span class="comment">// 若子类没有继承任何类，直接合并子类原型和父类原型上的所有方法</span></span><br><span class="line">    <span class="comment">// 包含可枚举/不可枚举的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.getPrototypeOf(childPrototype) === objectPrototype) &#123;</span><br><span class="line">        child.prototype = fancyShadowMerge(parentPrototype, childPrototype)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若子类已经继承子某个类</span></span><br><span class="line">        <span class="comment">// 父类的原型将在子类原型链的尽头补全</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">Reflect</span>.getPrototypeOf(childPrototype) !== objectPrototype) &#123;</span><br><span class="line">childPrototype = <span class="built_in">Reflect</span>.getPrototypeOf(childPrototype)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(childPrototype, parent.prototype)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">    parentPrototype.constructor = child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GithubUser</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password</span><br><span class="line">    <span class="built_in">this</span>.username = username</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JuejinUser</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password)</span><br><span class="line">    WeiboUser.call(<span class="built_in">this</span>, username, password)</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeiboUser</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WeiboUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.key = username + password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WeiboUser.prototype.compose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;compose&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先让 JuejinUser 继承 GithubUser，然后就可以用github登录掘金了</span></span><br><span class="line">inherit(JuejinUser, GithubUser) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 再让 JuejinUser 继承 WeiboUser，然后就可以用weibo登录掘金了</span></span><br><span class="line">inherit(JuejinUser, WeiboUser)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1 <span class="keyword">instanceof</span> GithubUser) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1 <span class="keyword">instanceof</span> WeiboUser) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/KQi6Uj.jpg" alt="alt"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>我们可以使用 function 来模拟一个类</li><li>JavaScript 类的继承是基于原型的，一个完善的继承方法，其继承过程是相当复杂的</li><li>虽然建议实际生产中直接使用 ES6 的继承，但仍建议深入内部继承机制</li><li>在 ES6 中，默认所有类都是不可枚举的</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：执行上下文</title>
      <link href="/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20JavaScript%20-%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20JavaScript%20-%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：深入理解-JavaScript-执行上下文"><a href="#JS：深入理解-JavaScript-执行上下文" class="headerlink" title="JS：深入理解 JavaScript - 执行上下文"></a>JS：深入理解 JavaScript - 执行上下文</h1><p>JS 每次执行回调函数，会把方法以 <strong>执行上下文</strong> 的方式压入 <strong>执行栈</strong> ，执行完会被弹出执行栈。</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>而 <strong>执行上下文</strong> 的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/Wm3r0E.jpg" alt="alt"></p><p>从上图可以了解到，执行上下文分为了两个环境，一个是 <strong>变量环境（VariableEnvironment）</strong>，另一个是 <strong>词法环境（LexicalEnvironment）</strong>，其中这两个环境之间的差别就在于，<strong>变量环境</strong> 是登记对应的 <strong>var、function</strong> 的声明。而另外的 <strong>词法环境</strong> 是用来登记对应的 <strong>let、const、class</strong> 等变量声明。<strong>词法环境</strong> 的出现是为了实现块级作用域的同时不影响 <strong>var、function</strong> 声明。</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>先看一段代码，观察其输出结果是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname);</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot;极客时间&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数showName被执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数showName被执行</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>按照顺序执行的逻辑来看，这段代码是无法执行的，但是结果这段代码不但没有报错，并且能够正常输出。</p><p>出现这个非正常的现象的原因就在于一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成后，才会进入执行阶段。</p><h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><h3 id="第一部分：变量提升的代码。"><a href="#第一部分：变量提升的代码。" class="headerlink" title="第一部分：变量提升的代码。"></a>第一部分：变量提升的代码。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数showName被执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二部分：执行部分代码。"><a href="#第二部分：执行部分代码。" class="headerlink" title="第二部分：执行部分代码。"></a>第二部分：执行部分代码。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname);</span><br><span class="line">myname = <span class="string">&quot;极客时间&quot;</span></span><br></pre></td></tr></table></figure><p>下图就是把 Javascript 的执行流程细化，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/vNRkwQ.jpg" alt="alt"></p><p>你可以简单认为变量环境对象是如下结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; <span class="literal">undefined</span>, </span><br><span class="line">     showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure><p>我们详细分析一下代码是如何生成变量环境对象的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;极客时间&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;函数showName被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第1行和第2行，由于这两行代码不是声明操作，所以JavaScript引擎不会做任何处理；</li><li>第3行，由于这行是经过var声明的，因此JavaScript引擎将在环境对象中创建一个名为myname的属性，并使用undefined对其初始化；</li><li>第4行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建一个showName的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript的执行堆和执行栈我会在后续文章中介绍）。 这样就生成了变量环境对象。接下来JavaScript引擎会把声明以外的代码编译为字节码，至于字节码的细节，我也会在后面文章中做详细介绍，你可以类比如下的模拟代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line">myname = <span class="string">&#x27;极客时间&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><ul><li>当执行到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出“函数showName被执行”结果。</li><li>接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。</li><li>接下来执行第3行，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”，变量环境如下所示：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; <span class="string">&quot;极客时间&quot;</span>, </span><br><span class="line">     showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS：词法环境</title>
      <link href="/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%20-%20%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/"/>
      <url>/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%20-%20%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="JS：深入理解JavaScript-词法环境"><a href="#JS：深入理解JavaScript-词法环境" class="headerlink" title="JS：深入理解JavaScript - 词法环境"></a>JS：深入理解JavaScript - 词法环境</h1><p>JS引擎中的栈桢有一个专业名称叫做**执行上下文 (Execution Context)**，紧接着就是一大串的名词：Lexical Environment Execution Context 变量对象 作用域链 原型链 this 闭包等等。</p><h2 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h2><p>V8引擎JS的编译执行过程，大致上分为了三个阶段：</p><ul><li>第一步：V8刚拿到执行上下文的时候，会将代码从上到下一行一行的先做分词 / 词法分析。分词指的是：比如 var a =    2；这段代码，会被分词成：var a 2和；这样的原子符号；词法分析是指：登记变量声明，函数声明，函数声明的行参。</li><li>第二步：在分词结束后，会做代码解析，引擎将token解析翻译成一个AST (抽象语法树)，这一步的时候，如果发现语法错误，就会直接报错，不再往下执行。</li><li>第三步：引擎生成 CPU 可以执行的机器码</li></ul><p>在第一步有个词法分析，它用来登记变量声明，函数声明，函数声明的形参，后续代码执行的时候就知道去哪里拿变量的值和函数了，这个登记的地方就是<strong>Lexical Environment (词法环境)</strong></p><p>词法环境有两个组成部分：</p><ul><li><strong>1：环境记录（Environment Record）</strong>，这个就是真正登记变量的地方<ul><li><strong>1.1：声明式环境记录（Declarative Environment Record）</strong>，用来记录直接有标识符定义的元素，比如变量、常量、let、class、module、import以及函数声明。</li><li><strong>1.2：对象式环境记录（Object Environment Record）</strong>，主要用于with、global的词法环境。</li></ul></li><li><strong>2：对外部词法环境的引用（outer）</strong>，它是作用域链能够连起来的关键。</li></ul><p>其中 <strong>声明式环境记录（Declarative Environment Record）</strong>，又分为两种类型：</p><ul><li><strong>函数环境记录（Function Environment Record）</strong>：用于函数作用域。</li><li><strong>模块环境记录（Module Environment Record）</strong>：模块环境记录用于体现一个模块的外部作用域，即模块 export 所在环境</li></ul><p>词法环境与我们自己写的代码结构相对应，也就是我们自己代码写成什么样子，词法环境就成什么样子。词法环境式在代码定义的时候决定的，跟代码在哪调用没有关系，所以说JavaScript采用的是词法作用域（静态作用域）。</p><p>我们来看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a * b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure><p>它的词法环境关系图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/qvxwBg.jpg" alt="alt"></p><p>我们可以用伪代码来模拟上面代码的词法环境：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局词法环境</span></span><br><span class="line">GlobalEnvironment = &#123;</span><br><span class="line">    <span class="attr">outer</span>: <span class="literal">null</span>, <span class="comment">//全局环境的外部环境引用为null</span></span><br><span class="line">    <span class="attr">GlobalEnvironmentRecord</span>: &#123;</span><br><span class="line">        <span class="comment">//全局this绑定指向全局对象</span></span><br><span class="line">        [[GlobalThisValue]]: ObjectEnvironmentRecord[[BindingObject]],</span><br><span class="line">        <span class="comment">//声明式环境记录，除了全局函数和var，其他声明都绑定在这里</span></span><br><span class="line">        <span class="attr">DeclarativeEnvironmentRecord</span>: &#123;</span><br><span class="line">            <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">y</span>: <span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//对象式环境记录，绑定对象为全局对象</span></span><br><span class="line">        <span class="attr">ObjectEnvironmentRecord</span>: &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">foo</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span><br><span class="line"><span class="function">            <span class="title">baz</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="function">            <span class="title">isNaNl</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">            <span class="title">isFinite</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">parseInt</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">parseFloat</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">Array</span>: &lt;&lt; <span class="title">construct</span> <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">Object</span>: &lt;&lt; <span class="title">construct</span> <span class="function"><span class="keyword">function</span>&gt;&gt;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            ...</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            ...</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        &#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">foo</span>函数词法环境</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">fooFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">GlobalEnvironment</span>,//外部词法环境引用指向全局环境</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        <span class="title">bar</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt; </span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">bar</span>函数词法环境</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">barFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">fooFunctionEnviroment</span>,//外部词法环境引用指向<span class="title">foo</span>函数词法环境</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        <span class="title">b</span>: 3</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">baz</span>函数词法环境</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">bazFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">GlobalEnvironment</span>,//外部词法环境引用指向全局环境</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">        <span class="title">a</span>: 10</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p>我们可以看到词法环境和我们定义代码定义一一对应，每个词法环境都有一个outer指向上一层的词法环境，当运行上方的代码，函数 bar 的词法环境里没有变量 a，所以就会到它的上一层词法环境去找（foo 词法环境）。foo 函数词法环境中也没有 a。然后沿着 foo词法环境一直往上找，在全局词法环境中找到了 var a = 2，沿着 outer 一层层找变量的值就是作用域链。如果找到第一个就会停止，如果在全局词法环境还是找不到，就会停止查找并返回 null，因为全局词法环境里的 outer 是 null。就会报 ReferenceError。</p><h2 id="变量提升-vs-函数提升"><a href="#变量提升-vs-函数提升" class="headerlink" title="变量提升 vs 函数提升"></a>变量提升 vs 函数提升</h2><p>V8 引擎执行代码分为三步，先做分词和词法分析，然后解析生成AST，最后生成机器码执行代码，词法分析时会生成词法环境登记变量，对于变量声明和函数声明，词法环境的处理不一样的。</p><p>在词法分析的时候：</p><ul><li>对于变量声明，<strong>var a = 2；</strong>，<strong>let x = 1；</strong>，给变量分配内存并初始化为 undefined，赋值语句是在第三步生成机器码真正执行代码的时候才执行的。</li><li>对于函数声明，**function foo ( ) { . . . }**，会在内存里创建函数对象，并且直接初始化为该函数对象。</li></ul><p>这就是 JS 的<strong>变量提升和函数提升</strong>，我们来看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionDec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functionDec();</span><br></pre></td></tr></table></figure><p>最后运行的结果是：undefined</p><p><img src="https://cdn.jsdelivr.net/gh/LauGaHo/blog-img@master/uPic/5eLpjb.jpg" alt="alt"></p><p>如果整个变量就没有定义，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionDec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functionDec();</span><br></pre></td></tr></table></figure><p>运行代码，结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">ReferenceError</span>: c is not defined</span><br><span class="line">    at functionDec (&lt;anonymous&gt;:<span class="number">4</span>:<span class="number">17</span>)</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">8</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深入理解JS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
