<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS：Flex 布局</title>
    <url>/2021/07/09/CSS%EF%BC%9AFlex%20%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="CSS：Flex-布局"><a href="#CSS：Flex-布局" class="headerlink" title="CSS：Flex 布局"></a>CSS：Flex 布局</h1><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>盒模型由 <code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code> 组成</p>
<h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><ul>
<li><p>margin 可以让块状元素居中显示，注意是块状元素。实现方式是：<code>margin: 10px, auto</code></p>
</li>
<li><p>设置 margin 可能会导致上下的两个元素出现外间距合并的情况，类似的上边的 div (块级元素) 设置了 margin 为 100px，然后下边的 div 设置了 50px，那么就会导致这两个元素间的间距并不是 150px，而是变成了 100px，这个就是外间距合并，这种的解决方式就是在这两个 div 的外边的父元素触发成一个 BFC。这样就可以解决了。</p>
</li>
<li><p>行内元素实际上不占上下外边距。行内元素的左右外边距不合并</p>
</li>
<li><p>浮动元素的外边距也不会合并</p>
</li>
<li><p>允许指定负的外边距，不过使用的时候要小心</p>
</li>
</ul>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>padding 的宽高要是记录在盒子模型的宽高之内，与此同时的是 border 也要记录在盒子模型的宽高之内，但是 margin 并不算在宽高之内。所以各位在书写宽高时注意减掉内边距和边框。box-sizing 属性有两个值，一个是 content-box (标准)，此时 padding 和 border 不被包含在 width 和 height 内，元素的实际大小为宽高 + border + padding，此为标准模式下的盒模型。border-boxing (怪异) padding 和 border 被包含在定义的 width 和 height 中。元素实际的大小为你定义了多宽就是多宽。此属性为怪异模式下的盒模型。</p>
<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Flex是“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为Flex布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>行内元素也可以使用Flex布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，设为Flex布局后，子元素的float、clear和vertical-align属性将失效。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用了 Flex 布局的元素，称为 Flex 容器，简称“容器”。它的所有子元素自动称为容器成员，称为 Flex 项目，简称“项目”</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/4COzFw.jpg" alt="alt"></p>
<p>容器默认存在两根轴：水平方向的主轴 (main axis) 和垂直方向的交叉轴 (cross axis)。主轴的开始位置 (与边框的交叉点) 叫 main start，结束位置叫做 main end；交叉轴的开始位置叫做 (cross end)。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 (main size)，占据的交叉轴空间叫做 (cross size)。</p>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><p>以下 6 个属性设置在容器上</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>flex-direction 属性决定主轴的方向 (即项目的排列方向)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/7t8Gu5.jpg" alt="alt"></p>
<p>它的取值有 4 种可能：</p>
<ul>
<li>row (默认值)：主轴为水平方向，起点在左端</li>
<li>row-reverse：主轴为水平方向，起点在右边</li>
<li>column：主轴为垂直方向，起点在上方</li>
<li>column-reverse：主轴为垂直方向，起点在下方</li>
</ul>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>默认情况下，项目都排在一条线 (又称“轴线”) 上。flex-wrap属性定义，如果一条轴线排不下，如何换行</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/2FW5XI.jpg" alt="alt"></p>
<p>它的取值有三种可能：</p>
<ul>
<li>norwrap (默认值)：不换行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/6d2FWW.jpg" alt="alt"></p>
<ul>
<li>wrap：换行，第一行在上方</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/JA3nNx.jpg" alt="alt"></p>
<ul>
<li>wrap-reverse：换行，第一行在下方</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/hOo7m9.jpg" alt="alt"></p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row norwrap</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content 属性定义了项目在主轴的对齐方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/NFWbgj.jpg" alt="alt"></p>
<p>它的取值有 5 种可能，具体对齐方式跟轴的方向有关，下面假设主轴为从左到右</p>
<ul>
<li>flex-start (默认值)：左对齐</li>
<li>flex-end：右对齐</li>
<li>center：居中</li>
<li>space-between：两端对齐，项目之间的间隔相等</li>
<li>space-around：每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items 属性定义项目在交叉轴上如何对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/rttbFb.jpg" alt="alt"></p>
<p>它的取值有 5 种可能：</p>
<ul>
<li>flex-start：交叉轴起点对齐</li>
<li>flex-end：交叉轴终点对齐</li>
<li>center：交叉轴中点对齐</li>
<li>baseline：项目的第一项文字的基线</li>
<li>stretch (默认值)：如果项目未设置高度或设为 auto，将占满整个容器的高度</li>
</ul>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>align-content 属性定义了多根轴线的对齐方式。如果项目只有一个轴线，该属性不起作用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">align-content</span>: flex-start | flex-end | center | space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/W8DGmG.jpg" alt="alt"></p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分配</li>
<li>space-around：每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框间隔大一倍</li>
<li>stretch（默认值）：轴线占满整个交叉轴</li>
</ul>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><p>以下 6 个属性设置在项目上</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/iTaKZ4.jpg" alt="alt"></p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有项目的 flex-grow 属性都为 1，则他们将等分剩余空间 (如果有的话)，如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不够，该项目会缩小</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/sn1tSc.jpg" alt="alt"></p>
<p>如果所有项目 flex-shrink 属性为 1，那么当空间不够的时候，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间 (main size)。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目本来大小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以设为跟 width 或 height 属性一样的值，比如 350px，则项目将占据固定空间。</p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex 属性是 flex-grow、flex-shrink、flex-basis 的简写，默认值为 0、1、auto。后两个属性可选。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该属性有两个快捷键：auto(1 1 auto) 和 auto(0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写是哪个分离的属性，因为浏览器会推算相关值。</p>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items，如果没有父元素，则等同 stretch。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline |</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/KeVUWJ.jpg" alt="alt"></p>
<p>该属性可能取值为 6 个，除了 auto，其他都与 align-items 属性完全一致。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS：定位</title>
    <url>/2021/07/09/CSS%EF%BC%9A%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="CSS：定位"><a href="#CSS：定位" class="headerlink" title="CSS：定位"></a>CSS：定位</h1><h2 id="浮动定位"><a href="#浮动定位" class="headerlink" title="浮动定位"></a>浮动定位</h2><h3 id="浮动属性"><a href="#浮动属性" class="headerlink" title="浮动属性"></a>浮动属性</h3><ul>
<li>将元素排除在普通流之外</li>
<li>元素将不在页面中占据位置</li>
<li>将浮动元素放在包含框的左边或右边</li>
<li>浮动元素依旧位于包含框内</li>
<li>浮动的框可以向左或者向右移动，直到他的边缘碰到父元素边框或者另一个浮动框的边框为止</li>
<li>浮动元素的外边缘不会超过其父元素的内边缘</li>
<li>浮动元素不会互相重叠</li>
<li>浮动元素不会上下浮动</li>
<li>任何元素一旦浮动，display 属性将完全失效均可以设置宽高，并且不会独占一行</li>
<li>语法：float: none / left / right</li>
<li>div 作为父元素没有设置宽高属性的话，那么 div 的高度是由其子元素的高度撑开的。如果其子元素全部设置为浮动了，那么会导致父元素的高度坍塌。</li>
</ul>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul>
<li>结尾处加空 div 标签 clear: both (或在下一个元素上加 clear: both)</li>
<li>浮动元素的父级 div 定义 overflow: hidden，设置了 overflow: hidden 之后相当于触发了 BFC 容器</li>
<li>浮动元素的父元素定宽高</li>
</ul>
<h2 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h2><h3 id="Position-定位"><a href="#Position-定位" class="headerlink" title="Position 定位"></a>Position 定位</h3><ul>
<li><p>absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位，元素的位置通过 left、top、right、bottom 进行规定，***<u>绝对定位的元素不会占据原有的物理位置</u>***，以其他元素作为参照物移动指定距离的定位方式。</p>
<ul>
<li>如果元素的外层元素是***<u>非 static</u>*** (有了除默认值之外的定位设置) 那么这个外层元素就成为该元素的定位参考点。</li>
<li>如果元素的外层元素没有设置任何的 position 值，那么该元素将寻找距离自己最近的其他设置过 position 的外层元素作为参照物 (必须为嵌套层)。</li>
<li>如果该元素的外层元素没有一个元素采用 position 定位，那么此时定位参考元素就变为 body 或者页面</li>
</ul>
</li>
<li><p>fixed：生成固定定位的元素，相对于浏览器窗口进行定位。元素也是通过 left、top、right、bottom 进行定位。</p>
</li>
<li><p>relative：生成相对定位的元素，相对于其正常位置进行定位，因此，left: 20 会向元素的 left 位置添加 20 像素，以当前参照物移动指定的距离，被定位的元素会占据原有的物理位置。</p>
</li>
<li><p>static：默认值，没有定位，元素出现在正常的流中 (忽略 top、bottom、left、right 或者 z-Index 声明)。</p>
</li>
<li><p>z-Index 属性只支持定位元素</p>
</li>
</ul>
<h2 id="Display-属性"><a href="#Display-属性" class="headerlink" title="Display 属性"></a>Display 属性</h2><p>每一个网页元素都有一个 display 属性，用于确认该元素的类型，每一个元素都有默认的 display 属性值，比如 div 元素，它的默认 display 属性值为 block，称为块元素，而 span 元素的默认 display 属性值为 inline，称为行内元素。块元素和行内元素可以转换。</p>
<h3 id="常见属性值"><a href="#常见属性值" class="headerlink" title="常见属性值"></a>常见属性值</h3><ul>
<li>none：隐藏对象，这里隐藏了对象之后，会导致对象不占据原有的位置</li>
<li>inline：指定对象为内联对象 (即行内对象)，特点是没有宽高属性，不会独占一行</li>
<li>block：指定对象为块元素，特点是具有宽高属性，并且独占一行</li>
<li>inline-block：指定对象为内联块对象，特点是具有宽高，并且不会独占一行</li>
<li>table-cell：指定对象为表格单元格</li>
<li>flex：弹性盒</li>
</ul>
<p>注意：visibility: hidden 和 opacity: 0 会将元素隐藏，但是物理空间实际还存在；display: none 隐藏元素，不保留物理空间。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：原型</title>
    <url>/2021/07/01/JS%EF%BC%9AJavaScript%20%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JS：JavaScript-原型"><a href="#JS：JavaScript-原型" class="headerlink" title="JS：JavaScript 原型"></a>JS：JavaScript 原型</h1><h2 id="引入：普通对象与函数对象"><a href="#引入：普通对象与函数对象" class="headerlink" title="引入：普通对象与函数对象"></a>引入：普通对象与函数对象</h2><p>在 JavaScript 中，一直有一个说法，万物皆对象，事实上，对象也是有区别的，我们可以将其划分为 <em><strong>普通对象</strong></em> 和 <em><strong>函数对象</strong></em>。Object 和 Function 便是 JavaScript 自带的两个典型的函数对象，而函数对象就是一个纯函数，所谓的函数对象，其实就是使用 JavaScript 在模拟类。</p>
<p>那么究竟什么是普通对象，什么是函数对象，请看下方例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;language&#x27;</span>, <span class="string">&#x27;console.log(language)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ob1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ob2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">const</span> ob3 = <span class="keyword">new</span> fn1()</span><br></pre></td></tr></table></figure>

<p>打印以下结果，可以得到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob1); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob2); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob3); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn1); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn2); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn3); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，ob1、ob2、ob3为普通对象（均为 Object 的实例），而 fn1、fn2、fn3 均是 Function 的实例，称之为 函数对象。</p>
<p>如何区分，记住这句话就可以了：</p>
<p>所有的 Function 的实例都是函数对象，而其他的都是普通对象。</p>
<p>上面提到，Object 和 Function 均是函数对象，我们也说到了，所有的 Function 的实例都是函数对象，难道 Function 也是 Function 的实例？</p>
<p>保留这个疑问，我们做一个总结：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/S7IhPO.jpg" alt="alt"></p>
<p>从图中可以看出，对象本身的实现还是要依靠构造函数。那原型链到底是用来干嘛的？</p>
<p>众所周知，作为一门面向对象的语言，必定具有以下特征：</p>
<ul>
<li>对象唯一性</li>
<li>抽象性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<p>而原型链最大的目的，就是为了<strong>实现继承</strong>。</p>
<h2 id="进阶：prototype-和-proto"><a href="#进阶：prototype-和-proto" class="headerlink" title="进阶：prototype 和 __proto__"></a>进阶：prototype 和 __proto__</h2><p>原型链究竟是如何实现继承的？首先，先引入两兄弟：prototype 和 __proto__，这是在 JavaScript 中无处不在的两个变量（如果你经常调试的话），然而，这两个变量并不是在所有的对象上都存在，先看一张表：</p>
<p>​                    prototype           __proto__</p>
<p>普通对象            X                    V</p>
<p>函数对象            V                    V</p>
<p>首先，我们先给出结论：</p>
<p>1、只有函数对象具有 prototype 这个属性；</p>
<p>2、prototype 和 __proto__ 都是 JavaScript 在定义一个函数对象时自动创建的预定义属性；</p>
<p>接下来我们验证上述的两个结论：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn.__proto__); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn.prototype); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ob = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob.__proto__); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ob.prototype); <span class="comment">// undefined，哇！果然普通对象没有 prototype</span></span><br></pre></td></tr></table></figure>

<p>既然是语言层面的预置属性，那么两者究竟有什么区别？我们依然从结论出发，给出以下两个结论：</p>
<p>1、prototype 被实例的 __proto__ 所指向（被动）</p>
<p>2、__proto__ 指向构造函数的 prototype（主动）</p>
<p>也就是说以下代码成立：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ob.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>那么问题来了，既然 fn 是一个函数对象，那么 fn.prototype.__proto__到底等于什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>创建一个函数时，JavaScript 对该函数原型的初始化代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 自动执行</span></span><br><span class="line">fn1.protptype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: fn1,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="built_in">Object</span>.prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1.__proto__ = <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>

<p>普通对象就是通过函数对象实例化得到的，而一个实例不可能再次进行实例化，也就不会让另一个对象的 __proto__ 指向它的 prototype，因此普通对象没有 prototype 属性这个结论就非常好理解了。而且我们也看出来了，fn1.prototype 就是一个普通对象，它也不存在 prototype 属性。</p>
<p>我们在上面还留下了一个疑问</p>
<ul>
<li>难道 Function 也是 Function 的实例？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="重点：原型链"><a href="#重点：原型链" class="headerlink" title="重点：原型链"></a>重点：原型链</h2><p>上面我们了解了 prototype 和 __proto__，实际上，这两兄弟主要就是为了构造原型链而存在的。</p>
<p>先看一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125; <span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125; <span class="comment">/* 2 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">&#125; <span class="comment">/* 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person(<span class="string">&#x27;ulivz&#x27;</span>, <span class="number">24</span>); <span class="comment">/* 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ulivz) <span class="comment">/* 5 */</span></span><br><span class="line"><span class="built_in">console</span>.log(ulivz.getName(), ulivz.getAge()) <span class="comment">/* 6 */</span></span><br></pre></td></tr></table></figure>

<p>解释一下执行细节：</p>
<ul>
<li>执行 1，创建了一个构造函数 Person，要注意，前面已经提到，此时 Person.prototype 已经被自动创建，它包含 constructor 和 __proto__这两个属性；</li>
<li>执行2，给对象 Person.prototype 增加了一个方法 getName()；</li>
<li>执行3，给对象 Person.prototype 增加了一个方法 getAge()；</li>
<li>执行4, 由构造函数 Person 创建了一个实例 ulivz，值得注意的是，一个构造函数在实例化时，一定会自动执行该构造函数。</li>
<li>在浏览器得到 5 的输出，即 ulivz 应该是：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;ulivz&#x27;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">     <span class="attr">__proto__</span>: <span class="built_in">Object</span> <span class="comment">// 实际上就是 `Person.prototype`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上面的结论，以下等式成立：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ulivz.__proto__ == Person.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行6的时候，由于在 ulivz 中找不到 getName() 和 getAge() 这两个方法，就会继续朝着原型链向上查找，也就是通过 __proto__ 向上查找，于是，很快在 ulviz.__proto__ 中，即 Person.prototype 中找到了这两个方法，于是停止查找并执行得到结果。</li>
</ul>
<p><em><strong>这便是 JavaScript 的原型继承。准确的说，JavaScript 的原型继承时通过 __proto__ 并借助 prototype 来实现的。</strong></em></p>
<p>于是便有以下总结：</p>
<p>1、函数对象的 __proto__ 指向 Function.prototype；</p>
<p>2、instance.__proto__ 指向函数对象的 prototype；</p>
<p>3、普通对象的 __proto__ 指向 Object.prototype；</p>
<p>4、普通对象没有 prototype 属性；</p>
<p>5、在访问一个对象的某个属性 / 方法的时候，如果在当前对象上没有找到，则会尝试 ob.__proto__，也就是访问该对象的构造函数的原型 obCtr.prototype，如果还是找不到，会继续查找 obCtr.prototype.__proto__，依次查找下去，若在某一刻，找到了该属性，则会立刻返回值并停止对原型链的搜索，若找不到，则返回 undefined。</p>
<p>为了加深理解，参考以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ulivz.__proto__ == <span class="built_in">Function</span>.prototype);	<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Function</span>.prototype);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Object</span>.prototype);	<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Function</span>.prototype);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="终极：原型链图"><a href="#终极：原型链图" class="headerlink" title="终极：原型链图"></a>终极：原型链图</h2><p>上面我们还遗留了一个问题：</p>
<ul>
<li>如果原型链一直找不到的话，那么什么时候停止，原型链的尽头在哪？</li>
</ul>
<p>我们可以用代码验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(ulivz.name);</span><br></pre></td></tr></table></figure>

<p>很明显，会输出 undefined。简述查找过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ulivz                <span class="comment">// 是一个对象，可以继续 </span></span><br><span class="line">ulivz[<span class="string">&#x27;name&#x27;</span>]           <span class="comment">// 不存在，继续查找 </span></span><br><span class="line">ulivz.__proto__            <span class="comment">// 是一个对象，可以继续</span></span><br><span class="line">ulivz.__proto__[<span class="string">&#x27;name&#x27;</span>]        <span class="comment">// 不存在，继续查找</span></span><br><span class="line">ulivz.__proto__.__proto__          <span class="comment">// 是一个对象，可以继续</span></span><br><span class="line">ulivz.__proto__.__proto__[<span class="string">&#x27;name&#x27;</span>]     <span class="comment">// 不存在, 继续查找</span></span><br><span class="line">ulivz.__proto__.__proto__.__proto__       <span class="comment">// null !!!! 停止查找，返回 undefined</span></span><br></pre></td></tr></table></figure>

<p>最后来看一下上一节的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125; <span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125; <span class="comment">/* 2 */</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">&#125; <span class="comment">/* 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ulivz = <span class="keyword">new</span> Person(<span class="string">&#x27;ulivz&#x27;</span>, <span class="number">24</span>); <span class="comment">/* 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ulivz) <span class="comment">/* 5 */</span></span><br><span class="line"><span class="built_in">console</span>.log(ulivz.getName(), ulivz.getAge()) <span class="comment">/* 6 */</span></span><br></pre></td></tr></table></figure>

<p>我们来画一个原型链图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/MbRe8T.jpg" alt="alt"></p>
<p>画完这张图，所有疑问都已经得到了解答了。</p>
<h2 id="调料：Constructor"><a href="#调料：Constructor" class="headerlink" title="调料：Constructor"></a>调料：Constructor</h2><p>前面已经有所提及了，只有原型对象才具有 constructor 这个属性，constructor 用来指向引用它的函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.constructor === Person <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor.prototype.constructor === Person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这是一种循环引用。</p>
<h2 id="补充：JavaScript-中的-6-大内置（函数）对象的原型继承"><a href="#补充：JavaScript-中的-6-大内置（函数）对象的原型继承" class="headerlink" title="补充：JavaScript 中的 6 大内置（函数）对象的原型继承"></a>补充：JavaScript 中的 6 大内置（函数）对象的原型继承</h2><p>通过前文的论述，结合相应的代码验证，整理出以下原型链图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/dsJdGM.jpg" alt="alt"></p>
<p>由此可见，我们更加强化了这两个观点；</p>
<p>1、任何内置函数对象（类）本身的 __proto__ 都指向 Function 的原型对象；</p>
<p>2、除了 Object 的原型对象的 __proto__ 指向 null，其他所有内置函数对象的原型对象的 __proto__ 都指向 Object.prototype；</p>
<p>请看以下代码：</p>
<p><em><strong>Array</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];		</span><br><span class="line">		<span class="built_in">console</span>.log(arr.__proto__)</span><br><span class="line">		<span class="built_in">console</span>.log(arr.__proto__ == <span class="built_in">Array</span>.prototype)   <span class="comment">// true </span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__== <span class="literal">null</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>RegExp</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(reg.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(reg.__proto__ == <span class="built_in">RegExp</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>Date</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(date.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(date.__proto__ == <span class="built_in">Date</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>Boolean</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> boo = <span class="keyword">new</span> <span class="built_in">Boolean</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(boo.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(boo.__proto__ == <span class="built_in">Boolean</span>.prototype) <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>Number</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Number</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><strong>String</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str.__proto__)</span><br><span class="line">    <span class="built_in">console</span>.log(str.__proto__ == <span class="built_in">String</span>.prototype)  <span class="comment">// true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__== <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>若 A 通过 new 创建了 B，那么 B.__proto__ == A.prototype；</li>
<li>__proto__ 是原型链查找的起点；</li>
<li>执行 B.a，若在 B 中找不到 a，则会在 B.__proto__ 中，也就是 A.prototype 中查找，若 A.prototype 中仍然没有，则会继续向上查找，最终，一定会找到 Object.prototype，倘若还找不到，因为 Object.prototype.__proto__ 指向 null，因此一定会返回 undefined。</li>
</ul>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：JavaScript 中可能模拟出私有变量吗？</title>
    <url>/2021/07/02/JS%EF%BC%9AJavaScript%20%E4%B8%AD%E6%9C%89%E5%8F%AF%E8%83%BD%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="JS：JavaScript-中有可能模拟出私有变量吗？"><a href="#JS：JavaScript-中有可能模拟出私有变量吗？" class="headerlink" title="JS：JavaScript 中有可能模拟出私有变量吗？"></a>JS：JavaScript 中有可能模拟出私有变量吗？</h1><p>JavaScript 中谈私有属性和私有方法就是扯淡，不知道什么时候提上来真正的私有，我们来看看 JS 是如何根据当前特性来实现私有成员。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JavaScript 实现私有属性必须依赖闭包特性，看以下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueId;</span><br><span class="line">  uniqueId = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prefix + <span class="string">&quot;_&quot;</span> + index++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="comment">//c_0</span></span><br><span class="line">  <span class="built_in">console</span>.log(uniqueId(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">  <span class="comment">//c_1</span></span><br><span class="line">  <span class="built_in">console</span>.log(uniqueId(<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>通常我们所说的或者看到的闭包就是这样子的 — (function() {}) ()，但这不是它的全部或者本质。在定义 uniqueId 这个函数的时候，我们使用了匿名函数表达式（请注意 (function( ){}) 是函数表达式）定义了一个函数且立即执行，把此时这个 function(prefix) {/<em>some code</em>/} 已经生成了函数实例，在函数实例生成的过程中：</p>
<p>1、通俗的讲，将 index 这个外部函数定义的变量记住了。</p>
<p>2、再次我们没法通过什么 this.index 或者 someObj.index 引用到 index，改变其值了，(function( ) { })( )这个一执行完，局部变量 index 在外面没有办法访问到。</p>
<p>3、怎么调得到，只能靠 function(prefix) {/<em>sone code</em>/}，因为我们还能通过它间接的取得或改变 index 值，这就是闭包了。</p>
<p>比较学术的解释：</p>
<p>1、JS 是词法作用域（就是程序上看上去是怎么样就是怎么样），使用一个叫 [[scope]] 的内部属性来标识每个执行上下文的作用域（我们可以读写哪些变量，调用哪些函数）；每个函数执行时都由该 [[scope]] 作用域加上活动对象构成真实的执行上下文。</p>
<p>2、而这个执行上下文 [[scope]] 属性是在函数生成时就指定的了。</p>
<p>3、于是 function(prefix){/<em>some code</em>/} 生成时其内部的 [[scope]] 属性引用了 (function( ){ })( ) 执行上下文的 scope 链；该 scope 链即包含了该函数的 [[scope]] 和活动对象，且活动对象包含了 index 的定义引用。</p>
<p>4、GC 的回收规则，没人用我，我就是垃圾。因此 uniqueId 引用了 function(prefix) {/<em>some code</em>/} 函数实例，而该函数的实例 [[scope]] 引用了 (function( ){ })( ) 执行期的 scope 链，其包含活动对象，即有 index 的引用；还有人引用它，它就不是垃圾，因此闭包就形成了，我们可以通过 uniqueId 函数间接地读取或者修改 index。</p>
<p>总结：其实学术解释和通俗解释都是一个意思，不过闭包其实是相对的，并不是我们不能修改 index，只是需要间接方法。</p>
<h2 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h2><p>构造单例对象的私有属性和私有方法都比较简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aira;</span><br><span class="line">aira = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    <span class="comment">//private variable</span></span><br><span class="line">    __name = <span class="string">&quot;HTC mobile&quot;</span>;</span><br><span class="line">    <span class="comment">//private method</span></span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">    aira = &#123;</span><br><span class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//change private variable inner</span></span><br><span class="line">            __name = <span class="string">&quot;aira&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">hello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//execute private method inner</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> aira;</span><br><span class="line">&#125;)();</span><br><span class="line">aira.init();</span><br><span class="line"><span class="comment">//hello,my name is aira</span></span><br><span class="line">aira.hello();</span><br></pre></td></tr></table></figure>

<p>使用下划线 “_“ 表示私有；aira 手机有一个私有属性 “_name” 和私有方法 “_getName”；我们可以在 init 中修改 “_name”，在 hello 中调用 “_getName”，且在闭包外面无法直接调用和修改这两个成员。这样就可以实现私有变量和私有方法了。</p>
<p>但是确切的说，其实 aira 能够有私有属性和方法仅仅是因为它有一个私有的一个闭包，即 init 和 hello 成员的 [[scope]] 都引用了闭包的活动对象。</p>
<p>然而，一个构造函数（类）的私有属性和方法就是这么简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira;</span><br><span class="line"><span class="comment">//wrap by function</span></span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> phone;</span><br><span class="line">    phone = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> __getName, __name;</span><br><span class="line">        __name = name;</span><br><span class="line">        __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> __name;</span><br><span class="line">        &#125;;</span><br><span class="line">        phone = &#123;</span><br><span class="line">            <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">                __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">hello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> phone;</span><br><span class="line">&#125;;</span><br><span class="line">aira1 = Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line"></span><br><span class="line">aira2 = Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2</span></span><br><span class="line">aira2.hello();</span><br></pre></td></tr></table></figure>

<p>我们先来简单的将单例对象的构造包裹一个函数，实现产生不同的对象。我们可以说 Phone 是一个类，因为它可以产生不同的对象，有类似的功能。同样 aria1 和 aria2 都有自己的闭包，于是都有自己的私有属性和私有方法。</p>
<p>JS 中类的概念就是构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira1, aira2;</span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    __name = name;</span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.init = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">        __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">aira1 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line"></span><br><span class="line">aira2 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2</span></span><br><span class="line">aira2.hello();</span><br></pre></td></tr></table></figure>

<p>Phone 构造函数其实就是闭包的功能，每个 Phone 实例的 init 和 hello 都能引用其构造期间的形成的私有的 “_name” 和 “_getName”。</p>
<p>每个实例都必须由闭包产生私有属性和方法，因此只能在该闭包中定义公共方法暴露出来（比如说 init 和 hello），这就意味着每次构造一个实例我们都必须生成 init 和 hello 的函数实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira;</span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    __name = name;</span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Phone.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">&#125;;</span><br><span class="line">Phone.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">&#125;;</span><br><span class="line">aira = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码是错误的（在 init 中 “_name” 是全局的，hello 中的 “_getName” 方法因为不存在，所以会报错），这就是问题所在，能够引用私有属性和变量的公共方法必须在闭包中定义，然后暴露出来，然而原型方法并不能在闭包中定义。</p>
<p>下面这段代码是私有方法吗？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira1, aira2;</span><br><span class="line">Phone = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __getName, __name;</span><br><span class="line">    __getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        __name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Phone.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">        __name += <span class="string">&quot;#&quot;</span> + number;</span><br><span class="line">    &#125;;</span><br><span class="line">    Phone.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (__getName()));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Phone;</span><br><span class="line">&#125;)();</span><br><span class="line">aira1 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1 right!</span></span><br><span class="line">aira1.hello();</span><br><span class="line">aira2 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2 right!</span></span><br><span class="line">aira2.hello();</span><br><span class="line"><span class="comment">//hello,my name is aira#2 wrong!</span></span><br><span class="line">aira1.hello();</span><br></pre></td></tr></table></figure>

<p>试图用闭包包住构造函数，形成闭包，但是得到的结果是 “_name” 和 “_getName” 其实都是类的私有属性，而不是实例。aira1 和 aira2 共用了 “_name” 和 “_getName”。</p>
<p>再来确定一下什么是私有属性和私有方法，即每个类实例都拥有且只能在类内访问的变量和函数。也就是说变量和方法只能由类的方法来调用。说到这里，我们或许可以尝试一下，不让类外的方法调用类的私有方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inner, outer;</span><br><span class="line">outer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;;</span><br><span class="line">inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  function()&#123;</span></span><br><span class="line"><span class="comment">      inner();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>

<p>从 arguments 的 callee 中可获取当前的执行函数 inner，而 inner 的动态属性 caller 指向了调用 inner 的外层函数 outer，由此看来我们可以使用 arguments.callee.caller 来确定函数的执行环境，实现私有方法和属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Phone, aira1, aira2;</span><br><span class="line"><span class="built_in">Function</span>.prototype.__public = <span class="function"><span class="keyword">function</span> (<span class="params">klass</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.klass = klass;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.__private = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that;</span><br><span class="line">    that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.constructor === <span class="built_in">arguments</span>.callee.caller.klass) &#123;</span><br><span class="line">            <span class="keyword">return</span> that.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&quot;</span> + that + <span class="string">&quot; is a private method!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Phone = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __name;</span><br><span class="line">    __name = name;</span><br><span class="line">    <span class="built_in">this</span>.__getName = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __name;</span><br><span class="line">    &#125;).__private();</span><br><span class="line">    <span class="built_in">this</span>.__setName = (<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        __name = name;</span><br><span class="line">    &#125;).__private();</span><br><span class="line">&#125;;</span><br><span class="line">Phone.prototype.init = (<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.__setName(<span class="built_in">this</span>.__getName() + <span class="string">&quot;#&quot;</span> + number);</span><br><span class="line">&#125;).__public(Phone);</span><br><span class="line">Phone.prototype.hello = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello,my name is &quot;</span> + (<span class="built_in">this</span>.__getName()));</span><br><span class="line">&#125;).__public(Phone);</span><br><span class="line">aira1 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira1.init(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line">aira2 = <span class="keyword">new</span> Phone(<span class="string">&quot;aira&quot;</span>);</span><br><span class="line">aira2.init(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//hello,my name is aira#2</span></span><br><span class="line">aira2.hello();</span><br><span class="line"><span class="comment">//hello,my name is aira#1</span></span><br><span class="line">aira1.hello();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    aira1.__getName();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			Error Object</span></span><br><span class="line"><span class="comment">    				message:&quot;function () &#123;return __name;&#125; is a private method!&quot;</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、我给 Function 原型上添加了两个方法 _public 和 _private 以此来实现私有方法的调用环境测试；</p>
<p>2、其次我无法给私有属性添加检测，所以私有属性直接不可见，使用私有 get，set 方法访问；</p>
<p>3、本身在 aira1 外部调用时，我们还是能看到 _getName 和 _setName 方法，只是不能调用而已；</p>
<p>4、唯一好的一点是原型方法（公共方法）终于可以从构造函数闭包中解放出来了；</p>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS：选择器</title>
    <url>/2021/07/09/CSS%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="CSS：选择器"><a href="#CSS：选择器" class="headerlink" title="CSS：选择器"></a>CSS：选择器</h1><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><p>1、标签选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类选择器 class</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、Id 选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id1</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><em><strong>总结：Id 选择器 &gt; class 选择 &gt; 标签选择器</strong></em></u></p>
<h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><p>1、后代选择器：body 中的所有子孙 p 标签都被设置为红色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、子选择器：body 中的子 p 标签才被设置为红色，孙 p 标签不被设置为红色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、相邻兄弟选择器：只使用类别为 active 并且是他下边一个相邻的 p 标签才被设置为红色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span> + <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、通用选择器：通用兄弟选择器，当前选中元素的向下的所有兄弟元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span> ~ <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>li1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>li2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>li3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*选择ul中的子孙li元素，选中最后一个li*/</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择ul中的子孙li元素，选中第一个li*/</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择当前p标签的父标签，选中父级元素的第一个，并且是当前元素才生效*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定位到当前元素的父元素，并且将父元素中为p标签类型第二个设置为黄色*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>HTML 内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item first&quot;</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item active&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;test&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/a.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/abc.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abcd.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item last&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*存在id属性的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[id]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中id为first的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[id=first]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中class中含有links的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class*=<span class="string">&quot;links&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中href属性中以http开头的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=http]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选中href属性中以pdf结尾的元素*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=pdf]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>=：绝对等于</p>
<p>*=：包含这个元素</p>
<p>^=：以这个开头</p>
<p>$=：以这个结尾</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：Map 和 Set</title>
    <url>/2021/07/01/JS%EF%BC%9AMap%20%E5%92%8C%20Set/</url>
    <content><![CDATA[<h1 id="JS：Map-和-Set"><a href="#JS：Map-和-Set" class="headerlink" title="JS：Map 和 Set"></a>JS：Map 和 Set</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map是JS(ES6)的一种字典数据结构，key值不重复，如果有重复，就会覆盖前面的，任何值都可以作为Map的key，包括对象，字符，数字，NaN，symbol。</p>
<p>Map跟Object很像，但是Object只能用string / symbol作为key，Map可以通过size获取键值个数，而Object只能手动计算。</p>
<p>在JS中，NaN === NaN是false，不过在Map中，NaN却被认为是同一个key：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>但是对于Object的Key，不同的对象，代表的key值不同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().set(&#123;&#125;, <span class="number">1</span>).set(&#123;&#125;, <span class="number">2</span>).size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>Map有以下3种创建方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emptyMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">.set(<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">.set(<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>复制Map：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">.set(<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">.set(<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="keyword">new</span> <span class="built_in">Map</span>(original);</span><br></pre></td></tr></table></figure>

<p>通过 key 拿到 value：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 123</span></span><br><span class="line">map.get(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>其他 Map 的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .has() checks if a Map has an entry with a given key</span></span><br><span class="line">map.has(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .delete() remove entries</span></span><br><span class="line">map.delete(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">map.has(<span class="string">&#x27;foo&#x27;</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .size retrun the number of entries in a Map</span></span><br><span class="line">map1.size; <span class="comment">//2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .clear() removes all entries of a Map</span></span><br><span class="line">map1.clear();</span><br><span class="line">map1.size; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="literal">false</span>, <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">  .set(<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .keys() returns an iterable over the keys of a Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">of</span> map2.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// output: false true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we can use spreading(...) to convert iterable returned by .keys() to an Array</span></span><br><span class="line">[... map2.keys()] <span class="comment">// [false, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .values() quite like .keys(), but for values instead of keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.entries() return an interable over the entries of a Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map2.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">//output:</span></span><br><span class="line">    <span class="comment">//[false, &#x27;no&#x27;]</span></span><br><span class="line">    <span class="comment">//[ture, &#x27;yes&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we can use sperading(...) to convert iterable returned by .entries() to an Array;</span></span><br><span class="line">[...map.entries()] <span class="comment">// [[false, &#x27;no&#x27;], [true, &#x27;yes&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we also can use below way to access key and value</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">    <span class="comment">// output:</span></span><br><span class="line">    <span class="comment">//false, &#x27;no&#x27;</span></span><br><span class="line">    <span class="comment">//true, &#x27;yes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只要 Map 只含有 strings 和 symbols 作为 key，那么就可以直接把这个 Map 转为 Object：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map); <span class="comment">// &#123; a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以把 Object 转换为 Map：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// new Map([[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]])</span></span><br></pre></td></tr></table></figure>

<p>应用：计算字符串中，字符出现的次数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countChars</span>(<span class="params">chars: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> charsCounts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> chars) &#123;</span><br><span class="line">    ch = ch.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> prevCount = charCounts.get(ch);</span><br><span class="line">    charCounts.set(ch, prevCount ? prevCount + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> charsCounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要像数组一样，map 和 filter，那么就必须要把 Map 先转化成为数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> originalMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">		.set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">		.set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">		.set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mappedMap = <span class="keyword">new</span> <span class="built_in">Map</span>( <span class="comment">//step 3</span></span><br><span class="line">		[...originalMap] <span class="comment">// step 1</span></span><br><span class="line">  			.map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v]) <span class="comment">// step 2</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 相当于：new Map([[2, &#x27;_a&#x27;], [4, &#x27;_b&#x27;], [6, &#x27;_c&#x27;]])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredMap = <span class="keyword">new</span> <span class="built_in">Map</span>( <span class="comment">// step 3</span></span><br><span class="line">		[...originalMap] <span class="comment">// step 1</span></span><br><span class="line">  			.filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>) <span class="comment">// step 2</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 相当于：new Map([[1, &#x27;a&#x27;], [2, &#x27;b&#x27;]])</span></span><br></pre></td></tr></table></figure>

<p>如果想要合并两个 Map：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">		.set(<span class="number">1</span>, <span class="string">&#x27;1a&#x27;</span>)</span><br><span class="line">		.set(<span class="number">2</span>, <span class="string">&#x27;1b&#x27;</span>)</span><br><span class="line">		.set(<span class="number">3</span>, <span class="string">&#x27;1c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">		.set(<span class="number">2</span>, <span class="string">&#x27;2b&#x27;</span>)</span><br><span class="line">		.set(<span class="number">3</span>, <span class="string">&#x27;2c&#x27;</span>)</span><br><span class="line">		.set(<span class="number">4</span>, <span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combinedMap = <span class="keyword">new</span> <span class="built_in">Map</span>([...map1, ...map2]);</span><br><span class="line"><span class="comment">// 相当于：new Map([[1, &#x27;1a&#x27;], [2, &#x27;2b&#x27;], [3, &#x27;2c&#x27;], [4, &#x27;2d&#x27;]])</span></span><br></pre></td></tr></table></figure>

<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 跟 Map 非常像，只不过多了以下限制：</p>
<ul>
<li><p>WeakMap 就是一个黑盒子</p>
<ul>
<li>我们不能直接通过 keys / values / entries 来 iterate 或者是 loop WeakMap，并且不能计算它的size。</li>
<li>我们不能清除 WeakMap，如有需要，只能重新创建一个。</li>
</ul>
</li>
<li><p>WeakMap 的 key，必须是 objects</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(<span class="number">123</span>, <span class="string">&#x27;test&#x27;</span>); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure></li>
<li><p>WeakMap 的 key 是弱饮用</p>
<ul>
<li><p>正常来说，如果有对象还被引用，那么就不会被垃圾回收。但是 WeakMap 不一样，在 object 作为 key 的时候，是可以被垃圾回收的，这会导致整个 entry 也被删掉，并且这个没有办法检测到这种行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  vm.set(obj, <span class="string">&#x27;attachedValue&#x27;</span>); <span class="comment">// (A)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (Bc)</span></span><br></pre></td></tr></table></figure>

<p>在 (A) 这一行我们给 obj 这个 key 赋值，但是在 (B) 这一行，obj 这个 entry 就有可能被垃圾回收掉了，但是 vm 还在，并且没有办法手动删掉 vm</p>
</li>
</ul>
<p>应用：</p>
<ul>
<li><p>用 WeakMap 来保存计算结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countOwnKeys</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(obj))  &#123;</span><br><span class="line">    <span class="keyword">return</span> [cache.get(obj), <span class="string">&#x27;cached&#x27;</span>];</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">    cache.set(obj, count);</span><br><span class="line">    <span class="keyword">return</span> [count, <span class="string">&#x27;computed&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用 WeakMap 来保存 private data</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">counter, action</span>)</span> &#123;</span><br><span class="line">        _counter.set(<span class="built_in">this</span>, counter);</span><br><span class="line">        _action.set(<span class="built_in">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = _counter.get(<span class="built_in">this</span>);</span><br><span class="line">        counter--;</span><br><span class="line">        _counter.set(<span class="built_in">this</span>, counter);</span><br><span class="line">        <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">            _action.get(<span class="built_in">this</span>)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WeakMap 的方法有：</p>
</li>
<li><p>new WeakMap( )</p>
</li>
<li><p>.delete( key )</p>
</li>
<li><p>.get( key )</p>
</li>
<li><p>.has( key )</p>
</li>
<li><p>.set( key, value )</p>
</li>
</ul>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 跟数组很像，但是成员的值都是唯一的，没有重复的值，并且 Set 对象允许存储任何类型的值，无论是原始值或者是对象引用。Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<p>有以下三种方式创建 Set：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emptySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">		.add(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">		.add(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">		.add(<span class="string">&#x27;blue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>常用的 Set 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .add() adds an element to a Set</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> set();</span><br><span class="line">set.add(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .has() checks if an elements is a member of a Set</span></span><br><span class="line">set.has(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .delete() removes an element from a Set</span></span><br><span class="line">set.delete(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">set.has(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .size contains the number of elements in a Set</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  .add(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  .add(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">set1.size; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .clear() removes all elements of a Set</span></span><br><span class="line">set1.clear(); </span><br><span class="line">set1.size; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterating over Sets</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> set2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="comment">//outouts:</span></span><br><span class="line">    <span class="comment">//&#x27;red&#x27;</span></span><br><span class="line">    <span class="comment">//&#x27;green&#x27;,</span></span><br><span class="line">    <span class="comment">//&#x27;blue&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use spreading(...) to convert set to array</span></span><br><span class="line"><span class="keyword">const</span> set3 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...set3]; <span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>应用</p>
<p>移除数组中的重复项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set4 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...set4]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>字符串是 iterable，所以也可以作为 Set 的参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]); <span class="comment">// 这两个是一样的</span></span><br></pre></td></tr></table></figure>

<p>NaN 对于 Set 来说也是一个值，对于任何 Object 都是不同的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]);</span><br><span class="line">set.size; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([&#123;&#125;, &#123;&#125;]);</span><br><span class="line">set1.size; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>Union 两个 Set：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]); <span class="comment">// new Set([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>

<p>Intersection 两个 Set：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(</span><br><span class="line">		[...a]</span><br><span class="line">  	.filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x))</span><br><span class="line">); <span class="comment">// new Set([2, 3])</span></span><br></pre></td></tr></table></figure>

<p>Difference 两个 Set：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>(</span><br><span class="line">  [...a]</span><br><span class="line">  .filter(<span class="function"><span class="params">x</span>=&gt;</span> !b.has(x))</span><br><span class="line">); <span class="comment">// new Set([1, 4])</span></span><br></pre></td></tr></table></figure>

<p>Mapping over Set:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> mappedSet = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span>=&gt;</span>x*<span class="number">2</span>)); <span class="comment">// new Set([2,4,6])</span></span><br></pre></td></tr></table></figure>

<p>Filtering Set:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> filteredSet = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">x</span>=&gt;</span>(x%<span class="number">2</span>)===<span class="number">0</span>)); <span class="comment">// new Set([2,4])</span></span><br></pre></td></tr></table></figure>

<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 跟 Set 很像，只不过多了下面的限制：</p>
<ul>
<li>WeakSet 是个黑盒子<ul>
<li>我们不能直接通过 keys / values / entries 来 iterate 或者 loop WeakMap，并且不能计算它的size。</li>
<li>我们不能清除 WeakSet，如有需要，只能重新创建一个。</li>
</ul>
</li>
<li>WeakSet 的 key 是弱引用<ul>
<li>正常来说，如果有对象还被引用，那么就不会 被垃圾回收。但是 WeakSet 不一样，在 object 作为 key 的时候，是可以被垃圾回收的，这会导致整个 entry 也被删掉，并且这个没有办法检测到这种行为</li>
</ul>
</li>
</ul>
<p>WeakSet 的方法有：</p>
<ul>
<li>new WeakSet( )</li>
<li>.delete( value )</li>
<li>.get( value )</li>
<li>.has( value )</li>
<li>.set( value )</li>
</ul>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：从执行上下文视角讲解 this</title>
    <url>/2021/07/01/JS%EF%BC%9A%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%86%E8%A7%92%E8%AE%B2%20this/</url>
    <content><![CDATA[<h1 id="JS：从执行上下文视角讲-this"><a href="#JS：从执行上下文视角讲-this" class="headerlink" title="JS：从执行上下文视角讲 this"></a>JS：从执行上下文视角讲 this</h1><p>观察以下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    <span class="attr">myName</span>:<span class="string">&quot;time.geekbang.com&quot;</span>,</span><br><span class="line">    <span class="attr">printName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myName)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">return</span> bar.printName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line"><span class="keyword">let</span> _printName = foo()</span><br><span class="line">_printName()</span><br><span class="line">bar.printName()</span><br></pre></td></tr></table></figure>

<p>这里其实是个障眼法，只需要确定好函数调用栈就可以轻松地回答，调用了 foo( ) 后，返回的是 bar.printName，后续就跟 foo 函数没有关系了，所以结果就是调用了两次 bar.printName( ) 函数，根据词法作用域，结果都是 “极客邦”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构确定的。</p>
<p>不过按照常理来说，调用 bar.printName 方法时，该方法内部的变量 myName 应该使用 bar 对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的。所以在对象内部的方法中使用对象内部的属性是一种非常普遍的的需求，但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出了另外一套 this 机制。</p>
<p>所以在 JavaScript 中可以使用 this 实现在 printName 函数中访问到 bar 对象中的 myName 属性了。具体的代码，如下显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">printName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-中的-this"><a href="#JavaScript-中的-this" class="headerlink" title="JavaScript 中的 this"></a>JavaScript 中的 this</h2><p>关于 this，我们还是得从执行上下文说起，其实执行上下文中包含了变量环境、词法环境、外部环境，但其实还有一个 this 没有提及，具体可以参考下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/VZ8Dym.jpg" alt="alt"></p>
<p>从图中可以看出，this 是和执行上下文绑定的，也就是说每个执行上下文都有一个 this。执行上下文包含了：全局执行上下文、函数执行上下文、eval执行上下文。</p>
<h2 id="全局执行上下文中的-this"><a href="#全局执行上下文中的-this" class="headerlink" title="全局执行上下文中的 this"></a>全局执行上下文中的 this</h2><p>全局执行上下文中输入 console.log( this )，最终输出的是 window 对象，这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。</p>
<h2 id="函数执行上下文中的-this"><a href="#函数执行上下文中的-this" class="headerlink" title="函数执行上下文中的 this"></a>函数执行上下文中的 this</h2><p>重点分析函数执行上下文，先看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这段代码打印出来的也是 window 对象，这说明在默认情况下调用一个函数，其执行上下文也是指向 window 对象的。但是我们可以设置执行上下文中的 this 来指向其他对象，通常有三种方式来设置函数执行上下文中的 this 值。</p>
<h3 id="1、通过函数的-call-方法设置"><a href="#1、通过函数的-call-方法设置" class="headerlink" title="1、通过函数的 call 方法设置"></a>1、通过函数的 call 方法设置</h3><p>可以通过函数的 call 方法来设置函数执行上下文的 this 指向，比如下面的这段代码，我们就并没有直接调用 foo 函数，而是调用了 foo 的call 函数，并将 bar 对象作为 call 方法的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot; 极客邦 &quot;</span>,</span><br><span class="line">  <span class="attr">test1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar)</span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="built_in">console</span>.log(myName)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，观察输出，就可以发现 foo 函数内部的 this 已经指向了 bar 对象，因为通过打印 bar 对象，可以看出 bar 的 myName 属性已经由 “极客邦” 变为 “极客时间” 了，同时在全局执行上下文中打印 myName，JavaScript 引擎提示该变量未定义。</p>
<p>其实除了 call 方法，还可以使用 bind 和 apply 方法来设置函数执行上下文的 this，它们在使用上还是有一些区别的。</p>
<h3 id="2、通过对象调用方法设置"><a href="#2、通过对象调用方法设置" class="headerlink" title="2、通过对象调用方法设置"></a>2、通过对象调用方法设置</h3><p>要改变函数执行上下文中的 this 指向，除了通过函数的 call 方法来实现以外，还可以通过对象调用的方式，比如下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们定义了一个 myObj 对象，该对象是由一个 name 属性和一个 showThis 方法组成的，然后再通过 myObj 对象来调用 showThis 方法。执行这段代码，你可以看到，最终输出的 this 值是指向 myObj 的。</p>
<p>所以，你可以得出这样的结论：使用对象来调用其内部的方法，该方法的 this 是指向对象本身的。</p>
<p>也可以这样认为 JavaScript 引擎在执行 myObject.showThis( ) 时，将其转化为了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObject.showThis.call(myObj)</span><br></pre></td></tr></table></figure>

<p>接下来我们稍微改变下调用方式，把 showThis 赋给一个全局对象，然后再调用该对象，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot; 极客邦 &quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>执行这段代码，你会发现 this 指向又是全局 window 对象。</p>
<p>所以通过以上两个例子的对比，你可以得出下面这样的结论：</p>
<p>在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。</p>
<p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。</p>
<h3 id="3、通过构造函数中设置"><a href="#3、通过构造函数中设置" class="headerlink" title="3、通过构造函数中设置"></a>3、通过构造函数中设置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;极客时间&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObje = <span class="keyword">new</span> CreateObj();</span><br></pre></td></tr></table></figure>

<p>在这段代码中，使用了 new 创建了对象 myObj。</p>
<p>其实，当执行 new CreateObj( ) 的时候，JavaScript 引擎做了如下四件事：</p>
<ul>
<li>首先创建了一个空对象 tempObj；</li>
<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；</li>
<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>
<li>最后返回 tempObj 对象；</li>
</ul>
<p>为了直观理解，我们用代码来演示一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>

<p>这样，我们就通过 new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。</p>
<h2 id="this-的设计缺陷以及应对方案"><a href="#this-的设计缺陷以及应对方案" class="headerlink" title="this 的设计缺陷以及应对方案"></a>this 的设计缺陷以及应对方案</h2><p>this 并不是一个很好的设计，因为它很多使用方法都冲击人的直觉，在使用过程中比较多坑，下面来看看 this 的设计缺陷</p>
<h3 id="1、嵌套函数中的-this-不会从外层函数中继承"><a href="#1、嵌套函数中的-this-不会从外层函数中继承" class="headerlink" title="1、嵌套函数中的 this 不会从外层函数中继承"></a>1、嵌套函数中的 this 不会从外层函数中继承</h3><p>分析一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>我们在这段代码的 showThis 方法中添加了一个 bar 方法，然后接着在 showThis 函数中调用了 bar 函数，那么现在的问题是：bar 函数中的 this 是什么？</p>
<p>如果是刚刚接触 JavaScript，那么会很自然地觉得，bar 中的 this 应该和其外层 showThis 函数中的 this 是一致的都是指向 myObj 对象，这很符合人的直觉。但是实际情况却并非如此，执行这段代码后，发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象，这就是 JavaScript 中容易让人迷惑的地方之一，也是很多问题的源头。</p>
<p>可以通过一个小技巧来解决这一个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      self.name = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，你会发现它也输出了我们想要的结果，最终 myObj 中的 name 属性值变成了 “极客邦”。其实这个方法的本质就是把 this 体系转换成了作用域体系。</p>
<p>同样的也可以使用 ES6 中的箭头函数来解决这个问题，结合一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，会发现它也输出了我们想要的结果，也就是说箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p>
<p>通过上面的讲解，你应该知道了 this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。解决这个问题，有两种思路：</p>
<ul>
<li>把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。</li>
<li>继续使用 this，但是需要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。</li>
</ul>
<h3 id="2、普通函数中的-this-默认指向全局对象-window"><a href="#2、普通函数中的-this-默认指向全局对象-window" class="headerlink" title="2、普通函数中的 this 默认指向全局对象 window"></a>2、普通函数中的 this 默认指向全局对象 window</h3><p>在默认情况下，调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。</p>
<p>不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式就是说通过 call 方法来实现调用。</p>
<p>这个问题可以通过设置 JavaScript 的 “严格模式” 来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是undefined，这就解决上面的问题了。</p>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：作用域链和闭包</title>
    <url>/2021/07/01/JS%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8CJS%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择"><a href="#JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择" class="headerlink" title="JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择"></a>JS：作用域链和闭包，代码出现相同的变量，JS引擎如何选择</h1><p>理解作用域链时理解闭包的基础，而闭包在 JavaScript 中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。</p>
<p>首先先来看这一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>你觉得这段代码中的 bar 函数和 foo 函数打印出来的是什么吗？</p>
<p>分析代码，当代码执行到 bar 函数内部，调用栈的状态如图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/7amvbs.jpg" alt="alt"></p>
<p>从图中可以看出，全局执行上下文和 foo 函数的执行上下文中都包含变量 myName，那 bar 函数中的 myName应该选择哪一个呢？这里就需要了解作用域链了。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>其实每一个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部因你用哪个称为 outer。</p>
<p>当一段代码使用了一个变量，JavaScript 引擎首先会在“当前执行上下文”中查找该变量，比如上面的那段代码在查找 myName 变量时，如果在当前的变量环境中没有查到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以直接看下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/zRdlhw.jpg" alt="alt"></p>
<p>从图中可以看到，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎就会去全局执行上下文中查找。我们把这个查找的链条就称作为作用域链。</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><em><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong></em></p>
<p>可以直接看下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/zcmf66.jpg" alt="alt"></p>
<p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域 -&gt; bar 函数作用域 -&gt; main 函数作用域 -&gt; 全局作用域。</p>
<p>回过头看上边的代码，foo 函数调用了 bar 函数，但是 bar 函数的外部引用是全局执行上下文。</p>
<p>因为词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个没有定义的变量，那么它们就会到全局作用域中寻找，故，词法作用域是代码阶段就决定好的，和函数的调用没有关系。</p>
<h2 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客世界 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> myName = <span class="string">&quot;Chrome 浏览器 &quot;</span></span><br><span class="line">        <span class="built_in">console</span>.log(test)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">        bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中，对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，调用栈的情况如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/%E4%B8%8B%E8%BD%BD.png" alt="alt"></p>
<p>现在是执行到 bar 函数的 if 语句块之内，需要打印出来的变量 test，那么久需要查找到 test 变量的值，其查找过程我已经在上图中使用了序号1、2、3、4、5标记出来了。</p>
<p>下面我就来解释一下这个过程。首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有 定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>了解了作用域链，接着就可以了解闭包了。关于闭包，理解起来稍微有一点难度。结合以下代码就可以理解什么是闭包了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>首先我们看看当执行到 foo 函数内部的 return innerBar 这行代码时，调用栈的情况你可以参考此图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/uPznOY.jpg" alt="alt"></p>
<p>从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。</p>
<p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数结束了，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/20NJwJ.jpg" alt="alt"></p>
<p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然存在在内存当中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p>
<p>之所以时专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。</p>
<p>最后给闭包完整的定义，在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合统称为闭包。比如外部函数 foo，那么这些变量的集合就称为 foo 函数的闭包。</p>
<p>闭包的使用。当执行到 bar.setName 方法中的 myName = “极客邦” 这句代码时，JavaScript 引擎会沿着 “当前执行上下文 -&gt; foo 函数闭包 -&gt; 全局执行上下文” 的顺序来查找 myName 变量，你可以参考下面调用栈状态图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/RxMYdM.jpg" alt="alt"></p>
<p>从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以当调用 setName 时，会修改 foo 闭包中的 myName 变量的值。</p>
<p>同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。</p>
<p>可以通过 “开发者工具” 来看看闭包的情况，打开 Chrome 的 “开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/cEAEuG.jpg" alt="alt"></p>
<p>从图中可以看出来，当调用 bar.getName 的时候，右边 Scope 就体现了作用域链的情况：Local 就是当前的 getName 函数的作用域，Closure( foo )是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从 “Local -&gt; Closure( foo ) -&gt; Global” 就是一个完整的作用域链。</p>
<p>所以，可以通过 Scope 来查看实际代码作用域链的情况。</p>
<h2 id="闭包的回收"><a href="#闭包的回收" class="headerlink" title="闭包的回收"></a>闭包的回收</h2><p>通常如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但是如果这个闭包以后不再使用就会导致内存泄漏。</p>
<p>所以在使用闭包的时候，尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存比较大的话，那就尽量让它成为一个局部变量。</p>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：块级作用域，let、const 的必要性</title>
    <url>/2021/07/01/JS%EF%BC%9A%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8Cvar%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5let%E3%80%81const/</url>
    <content><![CDATA[<h1 id="JS：块级作用域，var缺陷以及为什么引入let、const"><a href="#JS：块级作用域，var缺陷以及为什么引入let、const" class="headerlink" title="JS：块级作用域，var缺陷以及为什么引入let、const"></a>JS：块级作用域，var缺陷以及为什么引入let、const</h1><h2 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h2><p><strong>作用域是指在程序中定义变量的区域，该位置决定了变量的声明周期，通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</strong></p>
<p>在 ES6 之前，ES 的作用域只有两种，全局作用域和函数作用域。</p>
<ul>
<li>全局作用域中的对象在代码中的任何地方都能访问，其声明周期伴随着页面的声明周期。</li>
<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或函数只能在函数内部被访问。函数执行结束后，函数内部定义的变量就会被销毁。</li>
</ul>
<p>在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则普遍支持块级作用域。块级作用域就是使用一对大括号包裹的代码，比如函数、判断语句、循环语句、甚至单独的一个 { } 都可以被看作一个块级作用域。</p>
<p>为了更好地理解块级作用域，参考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if块</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while块</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//for循环块</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独一个块</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，如果一个语言支持块级作用域，那么其代码块内部定义的变量在代码块外是访问不到的，并且等该代码块执行完成后，代码块中定义的变量会被销毁。</p>
<h2 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h2><p>由于变量提升的问题，使用 JavaScript 来编写和其他语言相同的逻辑的代码，都有可能产生不一样的结果。主要有以下两种原因</p>
<h3 id="1、变量容易在不被察觉的情况下被覆盖掉"><a href="#1、变量容易在不被察觉的情况下被覆盖掉" class="headerlink" title="1、变量容易在不被察觉的情况下被覆盖掉"></a>1、变量容易在不被察觉的情况下被覆盖掉</h3><p>比如我们使用 JavaScript 实现以下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot;极客时间&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> myname = <span class="string">&quot;极客邦&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">&#125;</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure>

<p>打印出来的结果是 undefined 。</p>
<p>直接展示最终的调用栈状态如下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/iZeQCb.jpg" alt="alt"></p>
<p>showName 函数的执行上下文创建后，JavaScript 引擎便开始执行 showName 函数内部的代码了。首先执行的是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myname);</span><br></pre></td></tr></table></figure>

<p>JavaScript 会优先从当前的执行上下文中查找变量，由于变量提升，所以当前执行上下文就包括了变量 myname，并且值是 undefined。所以获取得到的值就是 undefined。</p>
<h3 id="2、本应销毁的变量没有销毁"><a href="#2、本应销毁的变量没有销毁" class="headerlink" title="2、本应销毁的变量没有销毁"></a>2、本应销毁的变量没有销毁</h3><p>再看看这一段误解更大的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>如果使用 C语言或者其他大部分的语言实现类似的代码，在for循环结束之后，i 就已经被销毁了，但是在JavaScript 代码中，i 的值未被销毁，所以最后打印出来的值为 7 。</p>
<h2 id="ES6-如何解决变量提升带来的问题"><a href="#ES6-如何解决变量提升带来的问题" class="headerlink" title="ES6 如何解决变量提升带来的问题"></a>ES6 如何解决变量提升带来的问题</h2><p>为了解决变量提升带来的问题，ES6 引入了 let 和 const 关键字，使得 JavaScript 也像其他语言一般拥有了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">6</span></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">y = <span class="number">9</span> <span class="comment">//报错，const声明的变量不可以修改</span></span><br></pre></td></tr></table></figure>

<p>从这段代码中，可以看出使用 let 关键字的变量可以改变值，使用 const 关键字的变量则不可以改变的。</p>
<p>参考一段存在变量提升的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有两个地方定义了变量 x，由于使用 var 关键字，在编译阶段会生成如下的执行上下文</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/6r82N9.jpg" alt="alt"></p>
<p>最终只生成了一个 x 值，并且函数体内所有对 x 的赋值操作都会直接改变变量环境中的 x 值。所以上述代码最后通过console.log( x )输出的应该是 2 。而其他语言最后一步输出的应该是 1。如果要让他支持块级作用域只需要将 var 关键字改成 let 关键字即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码的输出结果就和我们的预期是一致的。</p>
<h2 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h2><p>观察以下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当执行上面这段代码的时候，JavaScript 引擎线对其进行编译并创建上下文，然后再按照顺序执行代码，关于如何创建上下文已经分析过了，但是现在的情况有点不一样，let 关键字会创建块级作用域，那么 let 关键字如何影响执行上下文的，接下来一步步分析</p>
<p><strong>第一步、编译并创建执行上下文</strong></p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/ZuNPJi.jpg" alt="alt"></p>
<p>通过上图，可以得出结论：</p>
<ul>
<li>函数内部通过 <strong>var</strong> 声明的变量，在编译阶段全被存到变量环境当中。</li>
<li>通过 <strong>let</strong> 声明的变量，在编译阶段会存放到 <strong>词法环境（Lexical Environment）</strong>中。</li>
<li>在函数的作用域内部，通过 <strong>let</strong> 声明的变量没有被存放到词法环境中。</li>
<li>继续执行代码，当执行到代码块中，变量环境中的a已经设置为1，词法环境中的b设置为了2。</li>
</ul>
<p>这时函数的执行上下文就如下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/yjmTSJ.jpg" alt="alt"></p>
<p>从图中可以看出，当进入了函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</p>
<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是最外层的变量，进入了一个作用域中，就会把该作用域内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意一下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>再接下来，当执行到作用域块中的console.log( a )这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方法：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有找到，那么继续在变量环境中查找。</p>
<p>这样一个变量查找的过程就完成了，你可以参考下图：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/ChGluo.jpg" alt="alt"></p>
<p>从上图可以清晰看到查找变量的流程，不过要完整理解查找变量或者查找函数的流程，就需要涉及到作用域链了。</p>
<p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/vpNfIR.jpg" alt="alt"></p>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：展开运算符</title>
    <url>/2021/07/01/JS%EF%BC%9A%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="JS：展开运算符"><a href="#JS：展开运算符" class="headerlink" title="JS：展开运算符"></a>JS：展开运算符</h1><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符 ( . . . )"></a>展开运算符 ( . . . )</h2><p>展开运算符，是 ES6 中的新语法，是把可迭代的对象 ( string, object, 数组 )展开，可以用在函数调用 / 数组构造的时候，将数组表达式 / string 在语法层面展开，还可以将对象表达式按照 key-value 的方式展开。</p>
<p>展开运算符只能用于可迭代对象。</p>
<p><strong>函数调用：</strong></p>
<p>假如你把 . . . 放在函数的参数里，就说明这个参数必须是 interable object，然后这个对象就会被展开成为函数的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> someIterable = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">func(...someIterable);</span><br><span class="line"><span class="comment">// same as func(&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(-<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(...[-<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; <span class="built_in">Math</span>.max(-<span class="number">1</span>, ...[-<span class="number">5</span>, <span class="number">11</span>], <span class="number">3</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr1.push(...arr2); <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>数组构造或字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...numbers, <span class="string">&#x27;4&#x27;</span>, ...<span class="string">&#x27;hello&#x27;</span>, <span class="number">6</span>];) <span class="comment">// Array [1, 2, 3, &quot;4&quot;, &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parts = [<span class="string">&#x27;shoulders&#x27;</span>, <span class="string">&#x27;knees&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> lyrics = [<span class="string">&#x27;head&#x27;</span>, ...parts, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;toes&#x27;</span>]; <span class="comment">//  [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr];</span><br><span class="line">arr2.push(<span class="number">4</span>); <span class="comment">// arr2 此时变成了 [1,2,3,4]. arr不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接多个数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2]; <span class="comment">// [0,1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象拷贝（浅拷贝，并且不包含prototype）和合并</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>:<span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">foo</span>:<span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>:<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> cloneObj = &#123;...obj1&#125;; <span class="comment">// &#123;foo:&#x27;bar&#x27;, x:42&#125;</span></span><br><span class="line"><span class="keyword">var</span> mergeObj = &#123;...obj1, ...obj2&#125;; <span class="comment">// &#123;foo:&#x27;baz&#x27;, x:42, y:13&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>函数参数收集</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 foo([1, 2, 3, 4, 5, 6])</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p><strong>为对象增加属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> basicSquirtle = &#123; <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> fullSquirtle = &#123;</span><br><span class="line">  ...basicSquirtle,</span><br><span class="line">  <span class="attr">species</span>: <span class="string">&#x27;Tiny Turtle&#x27;</span>,</span><br><span class="line">  <span class="attr">evolution</span>: <span class="string">&#x27;Wartortle&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullSquirtle); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, species: &#x27;Tiny Turtle&#x27;, evolution: &#x27;Wartortle&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>复制具有嵌套结构的数据 / 对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span>,</span><br><span class="line">  <span class="attr">abilities</span>: [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain Dish&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon &#125;;</span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">&#x27;Charmander&#x27;</span>;</span><br><span class="line">pokemon.abilities.push(<span class="string">&#x27;Surf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squirtleClone); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, abilities: [ &#x27;Torrent&#x27;, &#x27;Rain Dish&#x27;, &#x27;Surf&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p>当我们修改原对象的 name 属性时，我们的克隆对象的 name 属性没有受到影响，这个符合预期。</p>
<p>但是当我们修改原对象的 abilities 属性时，我们的克隆对象也被修改了。</p>
<p>原因很简单，因为复制过来的 abilities 时一个引用类型，原数据改了，用到它的地方也会跟着改。</p>
<p>知道原因，再解决就很简单了</p>
<p><strong>复制引用类型的数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span>,</span><br><span class="line">  <span class="attr">abilities</span>: [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain Dish&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon, <span class="attr">abilities</span>: [...pokemon.abilities] &#125;;</span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">&#x27;Charmander&#x27;</span>;</span><br><span class="line">pokemon.abilities.push(<span class="string">&#x27;Surf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squirtleClone); </span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: &#123; name: &#x27;Squirtle&#x27;, type: &#x27;Water&#x27;, abilities: [ &#x27;Torrent&#x27;, &#x27;Rain Dish&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>增加条件属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abilities = [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain dish&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPokemon = abilities ? &#123; ...pokemon, abilities &#125; : pokemon;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullPokemon);</span><br></pre></td></tr></table></figure>

<p><strong>短路</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Squirtle&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Water&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abilities = [<span class="string">&#x27;Torrent&#x27;</span>, <span class="string">&#x27;Rain dish&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPokemon = &#123;</span><br><span class="line">  ...pokemon,</span><br><span class="line">  ...(abilities &amp;&amp; &#123; abilities &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullPokemon);</span><br></pre></td></tr></table></figure>

<p>如果 abilities 为 true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullPokemon = &#123;</span><br><span class="line">  ...pokemon,</span><br><span class="line">  ...&#123; abilities &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：JavaScript 继承原理</title>
    <url>/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%20JavaScript%20%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="JS：深入-JavaScript-继承原理"><a href="#JS：深入-JavaScript-继承原理" class="headerlink" title="JS：深入 JavaScript 继承原理"></a>JS：深入 JavaScript 继承原理</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>我们回顾一下 ES6 /  TypeScript /  ES5 类的写法以做对比。首先我们创建一个 GithubUser 类，它拥有一个 login 方法，和一个静态方法 getPublicServices，用于获取 public 的方法列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GithubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getPublicServices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username</span><br><span class="line">        <span class="built_in">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + <span class="built_in">this</span>.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，ES6 这个类的写法有一个弊病，密码 password 应该是 Github 用户一个私有变量，接下来用 TypeScript 重写一下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GithubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getPublicServices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> username: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">private</span> password: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username</span><br><span class="line">        <span class="built_in">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> login(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + <span class="built_in">this</span>.password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来，password 就只能在类的内部访问了。</p>
<p>结合原型讲解那一篇文章讲解的知识，来用 ES5 来实现这个类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// private属性</span></span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="comment">// public属性</span></span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    <span class="comment">// public方法</span></span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">GithubUser.getPublicServices = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>值得注意的是，我们一般都会把共有的方法放在类的原型上，而不会采用 this.login = function () {} 这种写法。因为只有这样，才能让多个实例引用同一个共有方法，从而避免了重复创建方法的浪费。</strong></em></p>
<p>留下两个疑问：</p>
<p>1、如何实现 private 方法</p>
<p>2、能否实现 protected 属性 / 方法 </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果创建了一个 JuejinUser 来继承 GithubUser，那么 JuejinUser 及其实例就可以调用 Github 的login 方法了。首先，先写出这个简单的 JuejinUser 类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO need implementation</span></span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先概述几种继承方法：</p>
<ul>
<li>类式继承</li>
<li>构造函数式继承</li>
<li>组合式继承</li>
<li>原型继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ul>
<h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><p><em><strong>若通过 new Parent( ) 创建了 Child，则 Child.__proto__ = Parent.prototype，而原型链则是顺着 __proto__ 依次向上查找。因此，可以通过修改 子类的原型为父类的实例来实现继承</strong></em></p>
<p>第一直觉的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    JuejinUser.prototype = <span class="keyword">new</span> GithubUser(username, password)</span><br><span class="line">    JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br></pre></td></tr></table></figure>

<p>在浏览器中查看原型链：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/WMixMl.jpg" alt="alt"></p>
<p>从上图可以看出，明显 juejinUser1.__proto__ 并不是 GithubUser 的一个实例。</p>
<p>实际上，JuejinUser.prototype 在定义函数的时候就已经将其指针指向对应的地址，利用构造函数实例化对象的时候，同样地也将 JuejinUser.prototype 当前指向的地址赋给了 juejinUser.__proto__ 这个变量，然而，在构造函数中，将 JuejinUser.prototype 指向了一个新对象的地址，就造成了 JuejinUser.prototype 和 juejinUser.__proto__的指向不一致，一个指向新对象，一个指向旧对象。所以重新赋值一下实例的 __proto__ 就可以解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">    <span class="keyword">const</span> prototype = <span class="keyword">new</span> GithubUser(username, password)</span><br><span class="line">    <span class="comment">// JuejinUser.prototype = prototype // 这一行已经没有意义了</span></span><br><span class="line">    prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.__proto__ = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br></pre></td></tr></table></figure>

<p>接着查看原型链：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/71V7S6.jpg" alt="alt"></p>
<p>原型链已经出来了，问题好想解决了，但实际上还有问题：</p>
<p>1、在原型链上创建了属性（这不是一个好的实践）</p>
<p>2、私自篡改 __proto__，导致 juejinUser1.__proto__ === JuejinUser.prototype 不成立！从而导致了 juejinUser1 instanceof JuejinUser也不成立。</p>
<p>造成这个问题的根本原因就在于，我们在实例化的时候动态修改了原型，那有没有一种方法可以在实例化之前就固定好类的原型的  reference 呢？</p>
<p>事实上，我们可以考虑把类的原型的赋值挪出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时构造函数还未运行，无法访问 username 和 password !!</span></span><br><span class="line">JuejinUser.prototype =  <span class="keyword">new</span> GithubUser() </span><br><span class="line"></span><br><span class="line">prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做又有更明显的缺点：</p>
<p>1、父类过早被创建，导致无法接受子类的动态参数；</p>
<p>2、仍然在原型上创建了属性，此时，多个子类的实例将共享一个父类属性，会互相影响；</p>
<p>举例说明缺点2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.username = <span class="string">&#x27;Unknown&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">JuejinUser.prototype =  <span class="keyword">new</span> GithubUser() </span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> juejinUser2 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;egoist&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  这就是把属性定义在原型链上的致命缺点，你可以直接访问，但修改就是一件难事了！</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// &#x27;Unknown&#x27;</span></span><br><span class="line">juejinUser1.__proto__.username = <span class="string">&#x27;U&#x27;</span> </span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// &#x27;U&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 卧槽，无情地影响了另一个实例!!!</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser2.username) <span class="comment">// &#x27;U&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由此可见，类式继承的两种方式缺陷太多！</p>
<h2 id="构造函数式继承"><a href="#构造函数式继承" class="headerlink" title="构造函数式继承"></a>构造函数式继承</h2><p>通过 call( ) 来实现继承（相应的，你也可以用 apply）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password)</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// ulivz</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.username) <span class="comment">// xxx</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1.login()) <span class="comment">// TypeError: juejinUser1.login is not a function</span></span><br></pre></td></tr></table></figure>

<p>当然，如果继承那么简单，那么本文就没有存在的必要了，本继承方法也有一个明显的缺陷，那就是 <em><strong>构造函数式继承</strong></em> 并没有继承父类原型上的方法。</p>
<h2 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h2><p>既然上述两种方法都各有缺点，又各有所长，能否将其结合起来，这种方式就叫做 <em><strong>组合式继承</strong></em>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">    GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password) <span class="comment">// 第二次执行 GithubUser 的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JuejinUser.prototype = <span class="keyword">new</span> GithubUser(); <span class="comment">// 第二次执行 GithubUser 的构造函数</span></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>虽然这种方式弥补了上述两种方式的一些缺陷，但是仍然存在着问题：</p>
<p>1、子类仍旧无法动态传递参数给父类</p>
<p>2、父类的构造函数被调用了两次</p>
<p>本方法很明显执行了两次父类的构造函数，因此，这也不是我们最终想要的继承方式。</p>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>原型继承实际上是对类式继承的一种封装，只不过其独特之处在于，定义了一个干净的中间类，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改类的原型为o, 于是f的实例都将继承o上的方法</span></span><br><span class="line">    f.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉 ES5 的同学会注意到，这不就是 Object.create( ) 吗？确实可以这样认为。</p>
<p>既然是类式继承的一种封装，其使用方式自然就是如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">JuejinUser.prototype = createObject(GithubUser)</span><br></pre></td></tr></table></figure>

<p>也就是仍然没有解决类式继承的一些问题。</p>
<h2 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h2><p>寄生继承是依托于一个对象而生的一种继承方式，因此称之为寄生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> juejinUserSample = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;ulivz&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">     o.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myComputer = <span class="keyword">new</span> CreateComputer(computer);</span><br></pre></td></tr></table></figure>

<p>由于实际生产中，继承一个单例对象的场景实在是太少了，因此还没有找到最佳的实现方法。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>先上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寄生组合式继承的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承父类的原型</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Object</span>.create(parent.prototype)</span><br><span class="line">    <span class="comment">// 重写子类的原型</span></span><br><span class="line">    child.prototype = p</span><br><span class="line">    <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">    p.constructor = child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GithubUser, 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password </span><br><span class="line">    <span class="built_in">this</span>.username = username </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GithubUser, 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password) <span class="comment">// 继承属性</span></span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型上的方法</span></span><br><span class="line">inherit(JuejinUser, GithubUser)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型上添加新方法</span></span><br><span class="line">JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br></pre></td></tr></table></figure>

<p>浏览器查看结果：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/k1AGHC.jpg" alt="alt"></p>
<p>简单说明一下：</p>
<ul>
<li>子类继承了父类的属性和方法，同时属性没有被创建在原型链上，因此多个子类不会共享同一个属性。</li>
<li>子类可以传递动态参数给父类。</li>
<li>父类构造函数只执行了一次。</li>
</ul>
<p>然而，还是存在一个美中不足的问题：</p>
<ul>
<li>子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖原有原型上的方法，这样的话，如果已经存在的两个类，就不好办了。</li>
</ul>
<h2 id="终极版继承"><a href="#终极版继承" class="headerlink" title="终极版继承"></a>终极版继承</h2><p>为了让代码更清晰，我用 ES6 的一些 API，写出了这个我认为最合理的继承方法：</p>
<ul>
<li>用 Reflect 代替了 Object；</li>
<li>用 Reflect.getPrototypeOf 来代替 ob.__proto__</li>
<li>用 Reflect.ownKeys 来读取所有可枚举 / 不可枚举 / Symbol 的属性</li>
<li>用 Reflect.getOwnPropertyDescriptor 读取属性描述符</li>
<li>用 Reflect.setPrototypeOf 来设置 __proto__</li>
</ul>
<p>源代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * fancy-inherit</span></span><br><span class="line"><span class="comment"> * (c) 2016-2018 ULIVZ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不同于object.assign, 该 merge方法会复制所有的源键</span></span><br><span class="line"><span class="comment">// 不管键名是 Symbol 或字符串，也不管是否可枚举</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fancyShadowMerge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.defineProperty(target, key, <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(source, key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Core</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> objectPrototype = <span class="built_in">Object</span>.prototype</span><br><span class="line">    <span class="comment">// 继承父类的原型</span></span><br><span class="line">    <span class="keyword">const</span> parentPrototype = <span class="built_in">Object</span>.create(parent.prototype)</span><br><span class="line">    <span class="keyword">let</span> childPrototype = child.prototype</span><br><span class="line">    <span class="comment">// 若子类没有继承任何类，直接合并子类原型和父类原型上的所有方法</span></span><br><span class="line">    <span class="comment">// 包含可枚举/不可枚举的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.getPrototypeOf(childPrototype) === objectPrototype) &#123;</span><br><span class="line">        child.prototype = fancyShadowMerge(parentPrototype, childPrototype)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若子类已经继承子某个类</span></span><br><span class="line">        <span class="comment">// 父类的原型将在子类原型链的尽头补全</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">Reflect</span>.getPrototypeOf(childPrototype) !== objectPrototype) &#123;</span><br><span class="line">		childPrototype = <span class="built_in">Reflect</span>.getPrototypeOf(childPrototype)</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="built_in">Reflect</span>.setPrototypeOf(childPrototype, parent.prototype)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">    parentPrototype.constructor = child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GithubUser</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GithubUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _password = password</span><br><span class="line">    <span class="built_in">this</span>.username = username</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GithubUser.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.username + <span class="string">&#x27;要登录Github，密码是&#x27;</span> + _password)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JuejinUser</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JuejinUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    GithubUser.call(<span class="built_in">this</span>, username, password)</span><br><span class="line">    WeiboUser.call(<span class="built_in">this</span>, username, password)</span><br><span class="line">    <span class="built_in">this</span>.articles = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JuejinUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Read article&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeiboUser</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WeiboUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.key = username + password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WeiboUser.prototype.compose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;compose&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先让 JuejinUser 继承 GithubUser，然后就可以用github登录掘金了</span></span><br><span class="line">inherit(JuejinUser, GithubUser) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 再让 JuejinUser 继承 WeiboUser，然后就可以用weibo登录掘金了</span></span><br><span class="line">inherit(JuejinUser, WeiboUser)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> juejinUser1 = <span class="keyword">new</span> JuejinUser(<span class="string">&#x27;ulivz&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1 <span class="keyword">instanceof</span> GithubUser) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(juejinUser1 <span class="keyword">instanceof</span> WeiboUser) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/KQi6Uj.jpg" alt="alt"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>我们可以使用 function 来模拟一个类</li>
<li>JavaScript 类的继承是基于原型的，一个完善的继承方法，其继承过程是相当复杂的</li>
<li>虽然建议实际生产中直接使用 ES6 的继承，但仍建议深入内部继承机制</li>
<li>在 ES6 中，默认所有类都是不可枚举的</li>
</ul>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：执行上下文</title>
    <url>/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20JavaScript%20-%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="JS：深入理解-JavaScript-执行上下文"><a href="#JS：深入理解-JavaScript-执行上下文" class="headerlink" title="JS：深入理解 JavaScript - 执行上下文"></a>JS：深入理解 JavaScript - 执行上下文</h1><p>JS 每次执行回调函数，会把方法以 <strong>执行上下文</strong> 的方式压入 <strong>执行栈</strong> ，执行完会被弹出执行栈。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>而 <strong>执行上下文</strong> 的结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/Wm3r0E.jpg" alt="alt"></p>
<p>从上图可以了解到，执行上下文分为了两个环境，一个是 <strong>变量环境（VariableEnvironment）</strong>，另一个是 <strong>词法环境（LexicalEnvironment）</strong>，其中这两个环境之间的差别就在于，<strong>变量环境</strong> 是登记对应的 <strong>var、function</strong> 的声明。而另外的 <strong>词法环境</strong> 是用来登记对应的 <strong>let、const、class</strong> 等变量声明。<strong>词法环境</strong> 的出现是为了实现块级作用域的同时不影响 <strong>var、function</strong> 声明。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>先看一段代码，观察其输出结果是什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname);</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot;极客时间&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数showName被执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数showName被执行</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>按照顺序执行的逻辑来看，这段代码是无法执行的，但是结果这段代码不但没有报错，并且能够正常输出。</p>
<p>出现这个非正常的现象的原因就在于一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成后，才会进入执行阶段。</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><h3 id="第一部分：变量提升的代码。"><a href="#第一部分：变量提升的代码。" class="headerlink" title="第一部分：变量提升的代码。"></a>第一部分：变量提升的代码。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数showName被执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二部分：执行部分代码。"><a href="#第二部分：执行部分代码。" class="headerlink" title="第二部分：执行部分代码。"></a>第二部分：执行部分代码。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname);</span><br><span class="line">myname = <span class="string">&quot;极客时间&quot;</span></span><br></pre></td></tr></table></figure>

<p>下图就是把 Javascript 的执行流程细化，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/vNRkwQ.jpg" alt="alt"></p>
<p>你可以简单认为变量环境对象是如下结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; <span class="literal">undefined</span>, </span><br><span class="line">     showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>

<p>我们详细分析一下代码是如何生成变量环境对象的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;极客时间&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;函数showName被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第1行和第2行，由于这两行代码不是声明操作，所以JavaScript引擎不会做任何处理；</li>
<li>第3行，由于这行是经过var声明的，因此JavaScript引擎将在环境对象中创建一个名为myname的属性，并使用undefined对其初始化；</li>
<li>第4行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建一个showName的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript的执行堆和执行栈我会在后续文章中介绍）。 这样就生成了变量环境对象。接下来JavaScript引擎会把声明以外的代码编译为字节码，至于字节码的细节，我也会在后面文章中做详细介绍，你可以类比如下的模拟代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line">myname = <span class="string">&#x27;极客时间&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><ul>
<li>当执行到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出“函数showName被执行”结果。</li>
<li>接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。</li>
<li>接下来执行第3行，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”，变量环境如下所示：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; <span class="string">&quot;极客时间&quot;</span>, </span><br><span class="line">     showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：词法环境</title>
    <url>/2021/07/01/JS%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%20-%20%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="JS：深入理解JavaScript-词法环境"><a href="#JS：深入理解JavaScript-词法环境" class="headerlink" title="JS：深入理解JavaScript - 词法环境"></a>JS：深入理解JavaScript - 词法环境</h1><p>JS引擎中的栈桢有一个专业名称叫做**执行上下文 (Execution Context)**，紧接着就是一大串的名词：Lexical Environment Execution Context 变量对象 作用域链 原型链 this 闭包等等。</p>
<h2 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h2><p>V8引擎JS的编译执行过程，大致上分为了三个阶段：</p>
<ul>
<li>第一步：V8刚拿到执行上下文的时候，会将代码从上到下一行一行的先做分词 / 词法分析。分词指的是：比如 var a =    2；这段代码，会被分词成：var a 2和；这样的原子符号；词法分析是指：登记变量声明，函数声明，函数声明的行参。</li>
<li>第二步：在分词结束后，会做代码解析，引擎将token解析翻译成一个AST (抽象语法树)，这一步的时候，如果发现语法错误，就会直接报错，不再往下执行。</li>
<li>第三步：引擎生成 CPU 可以执行的机器码</li>
</ul>
<p>在第一步有个词法分析，它用来登记变量声明，函数声明，函数声明的形参，后续代码执行的时候就知道去哪里拿变量的值和函数了，这个登记的地方就是<strong>Lexical Environment (词法环境)</strong></p>
<p>词法环境有两个组成部分：</p>
<ul>
<li><strong>1：环境记录（Environment Record）</strong>，这个就是真正登记变量的地方<ul>
<li><strong>1.1：声明式环境记录（Declarative Environment Record）</strong>，用来记录直接有标识符定义的元素，比如变量、常量、let、class、module、import以及函数声明。</li>
<li><strong>1.2：对象式环境记录（Object Environment Record）</strong>，主要用于with、global的词法环境。</li>
</ul>
</li>
<li><strong>2：对外部词法环境的引用（outer）</strong>，它是作用域链能够连起来的关键。</li>
</ul>
<p>其中 <strong>声明式环境记录（Declarative Environment Record）</strong>，又分为两种类型：</p>
<ul>
<li><strong>函数环境记录（Function Environment Record）</strong>：用于函数作用域。</li>
<li><strong>模块环境记录（Module Environment Record）</strong>：模块环境记录用于体现一个模块的外部作用域，即模块 export 所在环境</li>
</ul>
<p>词法环境与我们自己写的代码结构相对应，也就是我们自己代码写成什么样子，词法环境就成什么样子。词法环境式在代码定义的时候决定的，跟代码在哪调用没有关系，所以说JavaScript采用的是词法作用域（静态作用域）。</p>
<p>我们来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a * b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure>

<p>它的词法环境关系图如下：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/qvxwBg.jpg" alt="alt"></p>
<p>我们可以用伪代码来模拟上面代码的词法环境：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局词法环境</span></span><br><span class="line">GlobalEnvironment = &#123;</span><br><span class="line">    <span class="attr">outer</span>: <span class="literal">null</span>, <span class="comment">//全局环境的外部环境引用为null</span></span><br><span class="line">    <span class="attr">GlobalEnvironmentRecord</span>: &#123;</span><br><span class="line">        <span class="comment">//全局this绑定指向全局对象</span></span><br><span class="line">        [[GlobalThisValue]]: ObjectEnvironmentRecord[[BindingObject]],</span><br><span class="line">        <span class="comment">//声明式环境记录，除了全局函数和var，其他声明都绑定在这里</span></span><br><span class="line">        <span class="attr">DeclarativeEnvironmentRecord</span>: &#123;</span><br><span class="line">            <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">y</span>: <span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//对象式环境记录，绑定对象为全局对象</span></span><br><span class="line">        <span class="attr">ObjectEnvironmentRecord</span>: &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">foo</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span><br><span class="line"><span class="function">            <span class="title">baz</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="function">            <span class="title">isNaNl</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">            <span class="title">isFinite</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">parseInt</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">parseFloat</span>: &lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">Array</span>: &lt;&lt; <span class="title">construct</span> <span class="function"><span class="keyword">function</span>&gt;&gt;,</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            <span class="title">Object</span>: &lt;&lt; <span class="title">construct</span> <span class="function"><span class="keyword">function</span>&gt;&gt;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            ...</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">            ...</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        &#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">foo</span>函数词法环境</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">fooFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">GlobalEnvironment</span>,//外部词法环境引用指向全局环境</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        <span class="title">bar</span>:&lt;&lt; <span class="function"><span class="keyword">function</span>&gt;&gt; </span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">bar</span>函数词法环境</span></span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">barFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">fooFunctionEnviroment</span>,//外部词法环境引用指向<span class="title">foo</span>函数词法环境</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">        <span class="title">b</span>: 3</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function">//<span class="title">baz</span>函数词法环境</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">bazFunctionEnviroment</span> = </span>&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">outer</span>: <span class="title">GlobalEnvironment</span>,//外部词法环境引用指向全局环境</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">    <span class="title">FunctionEnvironmentRecord</span>: </span>&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">        [[<span class="title">ThisValue</span>]]: <span class="title">GlobalEnvironment</span>,//<span class="title">this</span>绑定指向全局环境</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">        <span class="title">a</span>: 10</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">&#125;</span></span></span></span><br></pre></td></tr></table></figure>

<p>我们可以看到词法环境和我们定义代码定义一一对应，每个词法环境都有一个outer指向上一层的词法环境，当运行上方的代码，函数 bar 的词法环境里没有变量 a，所以就会到它的上一层词法环境去找（foo 词法环境）。foo 函数词法环境中也没有 a。然后沿着 foo词法环境一直往上找，在全局词法环境中找到了 var a = 2，沿着 outer 一层层找变量的值就是作用域链。如果找到第一个就会停止，如果在全局词法环境还是找不到，就会停止查找并返回 null，因为全局词法环境里的 outer 是 null。就会报 ReferenceError。</p>
<h2 id="变量提升-vs-函数提升"><a href="#变量提升-vs-函数提升" class="headerlink" title="变量提升 vs 函数提升"></a>变量提升 vs 函数提升</h2><p>V8 引擎执行代码分为三步，先做分词和词法分析，然后解析生成AST，最后生成机器码执行代码，词法分析时会生成词法环境登记变量，对于变量声明和函数声明，词法环境的处理不一样的。</p>
<p>在词法分析的时候：</p>
<ul>
<li>对于变量声明，<strong>var a = 2；</strong>，<strong>let x = 1；</strong>，给变量分配内存并初始化为 undefined，赋值语句是在第三步生成机器码真正执行代码的时候才执行的。</li>
<li>对于函数声明，**function foo ( ) { . . . }**，会在内存里创建函数对象，并且直接初始化为该函数对象。</li>
</ul>
<p>这就是 JS 的<strong>变量提升和函数提升</strong>，我们来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionDec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functionDec();</span><br></pre></td></tr></table></figure>

<p>最后运行的结果是：undefined</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/5eLpjb.jpg" alt="alt"></p>
<p>如果整个变量就没有定义，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionDec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functionDec();</span><br></pre></td></tr></table></figure>

<p>运行代码，结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Uncaught <span class="built_in">ReferenceError</span>: c is not defined</span><br><span class="line">    at functionDec (&lt;anonymous&gt;:<span class="number">4</span>:<span class="number">17</span>)</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">8</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：深浅拷贝</title>
    <url>/2021/07/06/JS%EF%BC%9A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="JS：深浅拷贝"><a href="#JS：深浅拷贝" class="headerlink" title="JS：深浅拷贝"></a>JS：深浅拷贝</h1><p>先看一下数组的拷贝，通常我们会使用 slice( )、concat( ) 方法实现数组的拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.concat();</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice();</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>slice( )、concat( ) 都是返回一个新的数组，没有改变原来的数组，看起来像是深拷贝。</p>
<p>我们再来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.concat();</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice();</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br></pre></td></tr></table></figure>

<p>这里就可以看到，如果数组里有对象，那么不会拷贝对象的值，只是拷贝对象的引用，原来数据对象的值发生改变，由于拷贝的是对象的引用，新拷贝的数据中对象的值也发生改变，拷贝得不是很彻底，slice( )、concat( ) 是浅拷贝，对于对象，我们通常是通过 assign( ) 方法，或者使用展开运算符 ( . . . ) 来实现拷贝，同样，如果对象中嵌套了对象，也只能实现浅拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;mei&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;<span class="attr">city</span>: <span class="string">&quot;shanghai&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;...obj&#125;;</span><br><span class="line">obj.address.city = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name: &quot;mei&quot;, address:&#123;city: &quot;beijing&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123;name: &quot;mei&quot;, address:&#123;city: &quot;beijing&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="利用-JSON-stringify-实现对数组和对象的深拷贝"><a href="#利用-JSON-stringify-实现对数组和对象的深拷贝" class="headerlink" title="利用 JSON.stringify 实现对数组和对象的深拷贝"></a>利用 JSON.stringify 实现对数组和对象的深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, &#123; value: 5 &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;mei&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;<span class="attr">city</span>: <span class="string">&quot;shanghai&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">obj.address.city = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name: &quot;mei&quot;, address:&#123;city: &quot;shanghai&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>该方法不能对 undefined、symbol、函数进行深度拷贝。</p>
<h2 id="利用递归实现数组和对象深拷贝"><a href="#利用递归实现数组和对象深拷贝" class="headerlink" title="利用递归实现数组和对象深拷贝"></a>利用递归实现数组和对象深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = deepCopy(arr);</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//1, 2, 3, 4, &#123; value: 5 &#125;]</span></span><br></pre></td></tr></table></figure>

<p>对于数组和对象的浅拷贝，去掉递归就可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = shallowCopy(arr);</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS：箭头函数</title>
    <url>/2021/07/06/JS%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="JS：箭头函数"><a href="#JS：箭头函数" class="headerlink" title="JS：箭头函数"></a>JS：箭头函数</h1><p>先来看下 ES6 中箭头函数的基本语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要传入多个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> value * num;</span><br></pre></td></tr></table></figure>

<p>上面箭头函数例子中都省略了 return 关键字和代码的花括号，在箭头函数中如果方法体中只有一行的代码，可以省略关键字和方法的花括号，直接简化成 value =&gt; value。</p>
<p>如果函数的代码块需要多条语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value * num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要返回一个对象，箭头函数的方法体必须放在大括号 ( ) 中，这样做的原因是：没有大括号，JS 引擎没办法区分是正常定义一个对象还是一个箭头函数体：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> (&#123; <span class="attr">value</span>: value, <span class="attr">num</span>: num &#125;); <span class="comment">//正确写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> &#123; <span class="attr">value</span>: value, <span class="attr">num</span>: num &#125;; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure>

<h2 id="与普通函数的区别"><a href="#与普通函数的区别" class="headerlink" title="与普通函数的区别"></a>与普通函数的区别</h2><h3 id="没有-this"><a href="#没有-this" class="headerlink" title="没有 this"></a>没有 this</h3><p>箭头函数式的 this 需要通过查找作用域链来确定，它的 this 是指包在它外面的作用域的 this，我们来看下以下代码中的 this 分别指的是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// windows</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>obj.b 是一个箭头函数，它的 this 是包在外层的词法作用域的 this ，obj 对象不是可执行代码，所以它不是离箭头函数最近的词法作用域，再往外就是全局作用域 window 了，所以 obj.b 的 this 指的是 windows。</p>
<p>再来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomething(event.type);     <span class="comment">// error</span></span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling &quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在调用 pageHandler.init 方法的时候会报错，报错的函数是个回调函数，这个回调函数的 this 指的是全局变量 windows，在全局变量里没有 doSomething 这个方法，所以会报错，有两种方式处理这种错误：</p>
<p>第一种方式就是通过 bind 来指定 this：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomething(event.type)</span><br><span class="line">        &#125;).bind(<span class="built_in">this</span>), <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.bind(this) 中的 this 是指 pageHandler 这个对象，通过 bind 生成一个 this 指向 pageHandler 的新函数，这样执行 init 方法的时候不会报错，看起来有点奇怪。</p>
<p>第二种方式就是通过箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomething();</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把 init 中的回调函数改成了箭头函数，箭头函数的 this 是它最近的作用域链上的 this，也就是 init 这个方法的 this，也就是 pageHandler 这个对象，这样就可以达到目的不报错。</p>
<p><em><strong>需要注意的是，箭头函数不能改变 this 的值，普通函数可以通过 call、apply、bind 来指定 this，但是箭头函数的 this 是不能改变的。</strong></em></p>
<p><em><strong>上面所说，箭头函数的 this 不能改变某种程度上是不准确的，因为箭头函数中的 this 其实是跟随其外一层的函数的 this，所以如果外层函数中的 this 改变了，对应里边的箭头函数中的 this 指向也是跟随着外层的函数的 this 的。</strong></em></p>
<p>观察下方的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pageHandler.init();	<span class="comment">// pageHandler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testFunc = pageHandler.init;</span><br><span class="line">testFunc.init();	<span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<p>上方代码中的两种调用方式，得到的结果却不一样。</p>
<p>第一种方式，通过对象来调用方法，相当于把 pageHandler 绑定到了 init 方法中，然后 init 方法中的 箭头函数中的 this 是跟随 init 方法中的 this，因而箭头函数中的 this 也是指向 pageHandler 的。</p>
<p>第二种方式，通过将对象中的方法赋值给 testFunc 变量，然后在调用 testFunc( )，这时 testFunc 函数中的 this 指针未被指定，因而是默认值 window。 然后 testFunc 方法中的箭头函数中的 this 是跟随外一层的 this 指针，故箭头函数中的 this 也是指向 window 的。</p>
<p>由此可以看出，箭头函数的 this 指针并非完全不能够改变的，因为箭头函数的 this 指向是跟随外一层函数的 this 指针的，所以如果外一层函数的 this 指针改变了，对应的，其可执行代码中的箭头函数的 this 指针也会跟随改变。</p>
<h3 id="没有-arguments"><a href="#没有-arguments" class="headerlink" title="没有 arguments"></a>没有 arguments</h3><p>访问箭头函数的 arguments，其实也是访问包在它外面的非箭头函数的 arguments。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>,<span class="number">2</span>)()); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h3><p>没有 prototype，但是有 __proto__ 指向 function。</p>
]]></content>
      <tags>
        <tag>深入理解JS</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJS：入门和概览</title>
    <url>/2021/07/07/RXJS%EF%BC%9A%E5%85%A5%E9%97%A8%E5%92%8C%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="RXJS：入门和概览"><a href="#RXJS：入门和概览" class="headerlink" title="RXJS：入门和概览"></a>RXJS：入门和概览</h1><p>RxJS 是 Reactive Extensions For JavaScript 的简写，它是一个强大的 JavaScript Reactive 编程库。Reactive 是指响应式编程。</p>
<h2 id="什么是响应式编程"><a href="#什么是响应式编程" class="headerlink" title="什么是响应式编程"></a><strong>什么是响应式编程</strong></h2><p>任何异步事件（比如页面鼠标 click 事件），在响应式编程都是异步事件流。不仅仅是 click、hover 这种事件，任何变量、用户输入、属性、缓存、数据结构等，响应式编程把所有事物都看成是数据流。数据流是类似数组一样的序列，可以像一样，用 merge、map、concat 等方法操作。简单来说就是：把所有事物都事件流化，然后把这些事件流像数组一样去操作，就是响应式编程。</p>
<p>RxJS 提供了各种 API 来创建数据流：</p>
<ul>
<li>单值：of、empty、never</li>
<li>多值：from</li>
<li>定时：interval、timer</li>
<li>从事件创建：fromEvent</li>
<li>从 Promise 创建：fromPromise</li>
<li>自定义创建：create</li>
</ul>
<p>创建出来的数据流，是一种类似数组一样的序列，可以被订阅，也可以用如下 API 操作控制：</p>
<ul>
<li>改变数据形态：map、mapTo、pluck</li>
<li>过滤一些值：filter、skip、first、last、take</li>
<li>时间轴上的操作：delay、timeout、throttle、debounce、audit、bufferTime</li>
<li>累加：reduce、scan</li>
<li>异常处理：throw、catch、retry、finally</li>
<li>条件执行：takeUntil、delayWhen、retryWhen、subscribeOn、ObserveOn</li>
<li>转接：switch</li>
<li>concat，保持原来的序列顺序连接两个数据流</li>
<li>merge，合并序列</li>
<li>race，预设条件为其中一个数据流完成</li>
<li>forkJoin，预设条件为所有数据流都完成</li>
<li>zip，取各来源数据流最后一个值合并为对象</li>
<li>combineLatest，取各来源数据流最后一个值合并为数组</li>
</ul>
<h2 id="异步事件流"><a href="#异步事件流" class="headerlink" title="异步事件流"></a>异步事件流</h2><p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/GIT04l.jpg" alt="alt"></p>
<p>在上图中有如下几种东西：</p>
<ul>
<li>click 事件流</li>
<li>事件流产生的值</li>
<li>错误‘</li>
<li>事件流结束</li>
<li>时间轴</li>
</ul>
<p>点击一个按钮事件，随着时间推移，这个点击事件会产生三个不同的结果：值，发生错误，事件完成。我们可以定义方法用来：捕获值，捕获错误，捕获点击事件结束。在这个过程中，涉及以下几个 RxJS 的基本概念：</p>
<ul>
<li>Observable (可观察对象)：就是点击事件流</li>
<li>Observers (观察者)：就是捕获值 / 错误 / 事件结束的方法 (其实就是回调函数的集合)</li>
<li>Subscription (订阅)：Observable 产生的值都需要经过经过一个 ‘监听’ 传给 Observers，这个就是 Subscription</li>
<li>生产者 (Producer)：就是点击事件，是事件的生产者</li>
</ul>
<p>我们也可以用 ASCII 来描述这个事件流：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">--a---b-c---d---X---|-&gt;</span><br><span class="line"></span><br><span class="line">a b c d 是产生的值</span><br><span class="line">X 是错误</span><br><span class="line">| 是事件结束标志</span><br><span class="line">---&gt; 是时间线</span><br></pre></td></tr></table></figure>

<h2 id="响应式编程的必要性"><a href="#响应式编程的必要性" class="headerlink" title="响应式编程的必要性"></a>响应式编程的必要性</h2><p>例子：页面上有一个按钮，现在需要统计按钮点击次数。</p>
<p>没有 RxJS，代码是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter = counter + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>用 RxJS，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clickStream$ = fromEvent(button, <span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counterStream$ = clickStream$.pipe(</span><br><span class="line">    map(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;),</span><br><span class="line">    scan(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">counterStream$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is the click counter: &quot;</span> + data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>整个事件流可以用 ASCII 描述如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clickStream: ---c----c--c----c------c--&gt;</span><br><span class="line">                   map(c becomes <span class="number">1</span>) </span><br><span class="line">               ---<span class="number">1</span>----<span class="number">1</span>--<span class="number">1</span>----<span class="number">1</span>------<span class="number">1</span>--&gt;</span><br><span class="line">                   scan(+) </span><br><span class="line"><span class="attr">counterStream</span>: ---<span class="number">1</span>----<span class="number">2</span>--<span class="number">3</span>----<span class="number">4</span>------<span class="number">5</span>--&gt;</span><br></pre></td></tr></table></figure>

<p>点击事件可以看成数据流 (clickStream)，在 clickStream 事件流基础上用方法 map 把每次点击事件转化成 1，然后用 scan 把所有的点击次数加起来，当我们执行 map 或者 scan 的时候都会在原来的数据流基础上生产一个新的数据流，原来的数据流不变。</p>
<p>从上面的这个例子还不能看出 RxJS 的强大和优势，我们现在再来看下：统计出双击事件次数，或者多次点击 (两次或两次以上) 都统计为双击次数。如果要用传统代码实现这个需求，肯定要很多变量来声明各种状态而且还要用到 intervals，代码逻辑复杂且容易出错，但是在响应式编程里十分简单，实际只需要四行代码。</p>
<p>我们先用 ASCII 把流程画一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   clickStream: ----c----c-c---c-cc---ccc---c----|-&gt;</span><br><span class="line">                buff(clickStream.throttleTime(250ms))</span><br><span class="line">                ----c----cc-----ccc---ccc---c----|-&gt;</span><br><span class="line">                    map(<span class="string">&#x27;get length of lists&#x27;</span>)</span><br><span class="line">                ----<span class="number">1</span>-----<span class="number">2</span>------<span class="number">3</span>-----<span class="number">3</span>----<span class="number">1</span>----|-&gt;</span><br><span class="line">                    filter(x&gt;=<span class="number">2</span>)                  </span><br><span class="line"><span class="attr">mulClickStream</span>: ----------<span class="number">2</span>------<span class="number">3</span>-----<span class="number">3</span>---------|-&gt;</span><br></pre></td></tr></table></figure>

<p>具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clickStream$ = fromEvent(button, <span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doubleClickStream$ = clickStream$</span><br><span class="line">    .pipe(</span><br><span class="line">        buffer(clickStream$.pipe(throttleTime(<span class="number">250</span>))),</span><br><span class="line">        map(<span class="function"><span class="params">click</span> =&gt;</span> &#123; <span class="keyword">return</span> click.length &#125;),</span><br><span class="line">        filter(<span class="function"><span class="params">num</span> =&gt;</span> num &gt;= <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">doubleClickStream$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;the number of double click is: &quot;</span> + data);;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从上面这个简单的例子，我们可以看到 RxJS 提供大量的操作符，处理不同的业务需求，短短几行就可以涵盖很复杂的代码逻辑，在前端交互非常复杂的系统中，客户端都是基于事件编程的，对事件处理非常多，用 RxJS 比较有优势。当然响应式编程也是支持各种语言的，包括：RxJava、Rx.NET、RxPY、RxGO等。</p>
]]></content>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJS：Cold vs Hot Observables</title>
    <url>/2021/07/09/RxJS%EF%BC%9ACold%20vs%20Hot%20Observables/</url>
    <content><![CDATA[<h1 id="RxJS：Cold-vs-Hot-Observables"><a href="#RxJS：Cold-vs-Hot-Observables" class="headerlink" title="RxJS：Cold vs Hot Observables"></a>RxJS：Cold vs Hot Observables</h1><p>RxJS 中 Observables 分为两种：Cold Observables 和 Hot Observables，这两个的区别：</p>
<ul>
<li>Cold Observables：只有被 observers 订阅的时候，才会开始产生值。是单播的，有多少个订阅就会生成多少个订阅实例，每个订阅都是从第一个产生的值开始接受值，所以每个订阅收到的值都是一样的。</li>
<li>Hot Observables：不管有没有被订阅都会产生值。是多播的，多个订阅共享同一个，是从订阅开始接受到值，每个订阅接收到的值是不同的，取决于它们是从什么时候开始订阅的。</li>
</ul>
<h2 id="Cold-Observables"><a href="#Cold-Observables" class="headerlink" title="Cold Observables"></a>Cold Observables</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = <span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2nd subscriber:&quot;</span> + data) &#125;);</span><br></pre></td></tr></table></figure>

<p>把一个数组转换成 Observables，然后分别用不同的 Subcription 订阅它，在 console.log 结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2nd subscriber:<span class="number">1</span></span><br><span class="line">2nd subscriber:<span class="number">2</span></span><br><span class="line">2nd subscriber:<span class="number">3</span></span><br><span class="line">2nd subscriber:<span class="number">4</span></span><br><span class="line">2nd subscriber:<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>我们把代码改一下，让第二个 Subscription 延迟一秒订阅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = <span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2nd subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">&#125;, <span class="number">1100</span>);</span><br></pre></td></tr></table></figure>

<p>结果还是跟上面一样，没有任何区别。这个是 Cold Observables，代码如下，先忽略 publish，ConnectableObservable，connect，稍后再详细解释。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = <span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).pipe(</span><br><span class="line">    publish()</span><br><span class="line">) <span class="keyword">as</span> ConnectableObservable&lt;any&gt;;</span><br><span class="line">obs$.connect();</span><br><span class="line"></span><br><span class="line">obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">&#125;, <span class="number">2100</span>);</span><br></pre></td></tr></table></figure>

<p>根据 Hot Observables 的定义，期待的效果是第一个订阅收到 1，2，3，4，5；第二个订阅收到 3，4，5。实际上两个订阅都没有接收任何值。因为 Hot Observables 是不管有没有被订阅，都会发送值，数组中有 5 个值，等到开始订阅的时候，这 5 个值已经发送完成了，所以在订阅中接收不到任何值了。</p>
<p>为了看到效果，把数组替换成了 interval，每隔一秒钟就发送一个值，第一个订阅等了一秒开始接受值，第二订阅等了两秒开始接收值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    publish()</span><br><span class="line">) <span class="keyword">as</span> ConnectableObservable&lt;any&gt;;</span><br><span class="line">obs$.connect();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    &#125;, <span class="number">1100</span>);</span><br><span class="line">&#125;, <span class="number">2100</span>);	</span><br></pre></td></tr></table></figure>

<p>效果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">2st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">2st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line">1st subscriber:<span class="number">6</span></span><br><span class="line">2st subscriber:<span class="number">6</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="Cold-Observables-vs-Hot-Observables"><a href="#Cold-Observables-vs-Hot-Observables" class="headerlink" title="Cold Observables vs Hot Observables"></a>Cold Observables vs Hot Observables</h2><ul>
<li>我们可以把 Cold Observables 理解为在手机网易云音乐 APP 上听歌：APP 里的歌曲资源是 Cold Observables，听歌的人是 observers。如果没有人打开 APP 去播放这首歌，这首歌不会自己播放。每个人从自己 APP 打开播放这首歌的时候，先把歌曲从网上下载到本地，每份都是单独的歌曲实例，都是从头开始听，互相不会影响。</li>
<li>而 Hot Observables 可以理解为演唱会：比如我们去看一场演唱会，没有迟到的小伙伴（A）可以从第一首歌开始听，迟到的小伙伴就（B）只能从第二首或者更晚的歌开始听；演唱会就是 Hot Observables，小伙伴 A 和 B 就是 observers。小伙伴 A 和 B 共享同一个演唱会实例，是从订阅开始接受到值，每个订阅接收到的值是不同的，取决于它们是从什么时候开始订阅。</li>
</ul>
<h2 id="如何创建-Hot-Observables"><a href="#如何创建-Hot-Observables" class="headerlink" title="如何创建 Hot Observables"></a>如何创建 Hot Observables</h2><p>在上方的 Hot Observables 代码里，用到了 publish 操作符，ConnectableObservable，以及 connect( ) 方法创建 Hot Observables；看一下对应的方法是什么意思。</p>
<ul>
<li>publish：这个操作符把正常的 Observable (Cold Observables) 转换成 ConnectableObservable。</li>
<li>ConnectableObservable：ConnectableObservable 是多播的共享 Observable，可以同时被多个 observers 共享订阅，是 Hot Observables。ConnectableObservable 是订阅者和真正源头 Observables (上面例子中的 interval，每隔一秒发送一个值，就是源头 Observable) 的中间人。ConnectableObservable 从源头 Observables 接收到值然后再把值转发给订阅者。</li>
<li>connect( )：ConnectableObservable 并不会主动发送值，它有个 connect 方法，通过调用 connect 方法，可以启动共享 ConnectableObservable 发送值。当我们调用 ConnectableObservable.prototype.connect 方法，不管有没有被订阅，都会发送值。订阅者共享同一个实例，订阅者接收到的值取决于它们何时开始订阅。在我们的例子中，第一个订阅等了一秒从 2 开始接收值，第二个订阅等了两秒从 3 开始接收值。</li>
</ul>
<h2 id="connect-vs-refCount"><a href="#connect-vs-refCount" class="headerlink" title="connect vs refCount"></a>connect vs refCount</h2><p>除了 connect，还有一个 refCount 方法，在比较这两个区别之前，我们先看一下 refCount 的用法和效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    publish(),</span><br><span class="line">    refCount()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">1100</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>按之前对 publish 会生成一个 ConnectableObservable，它是一个 Hot Observables，那么预期结果是：第一个订阅者是从 2 开始接收值，第二个订阅者是从 3 开始接收值。</p>
<p>实际的输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">1st subscriber:<span class="number">0</span></span><br><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">2st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">2st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">2st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">2st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line"></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>跟预想的不一样，第一个订阅者从 0 开始接收值，第二个订阅者比第一个订阅者晚了一秒，从 1 开始接收值。</p>
<p>当使用 refCount，是引用计数的 Observable。它表示当第一个订阅者开始订阅的时候，开始发送和产生值；第二个订阅者 (之后的订阅者) 共享第一个订阅者的 Observables 实例，没有订阅者的时候，会自动取消订阅；之后再重新订阅，又从头开始发送值。</p>
<p>它不是 Hot Observables 也不是 Cold Observables，因为它是从有第一个订阅者的时候才开始发送值，没有订阅者的时候会自动取消订阅，而且之后的订阅者共享第一个订阅者的 Observables 实例。它是基于 Hot Observables 与 Cold Observables 之间的 Observables，可以理解为 Warm Observables。</p>
<h2 id="share"><a href="#share" class="headerlink" title="share"></a>share</h2><p>publish 和 refCount 可以生成一个 Warm Observables，实际单独使用 share 操作符也可以达到同样的效果，share 实际上是 publish( ).refCount( ) 的简写，这次把第二个订阅比第一个订阅晚 5 秒再开始订阅，具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    share()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">5100</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">1st subscriber:<span class="number">0</span></span><br><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line">1st subscriber:<span class="number">6</span></span><br><span class="line">2st subscriber:<span class="number">6</span></span><br><span class="line">1st subscriber:<span class="number">7</span></span><br><span class="line">2st subscriber:<span class="number">7</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>和使用 publish( ).refCount( ) 效果完全一样。</p>
<h2 id="shareReplay"><a href="#shareReplay" class="headerlink" title="shareReplay"></a>shareReplay</h2><p>在用 share( ) 的时候，第二个或者更后面的订阅者开始订阅者，都是共享第一个订阅者的 Observables，比如上面的例子中，第二个订阅比第一个订阅晚 5 秒再开始订阅，那么第二个订阅者从 5 开始接收值。但是实际情况中，如果我想让第二个订阅者也能够拿得到前面的值，那怎么办？用 shareReplay( ) 可以实现。具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obs$ = interval(<span class="number">1000</span>).pipe(</span><br><span class="line">    shareReplay(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;1st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        obs$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&quot;2st subscriber:&quot;</span> + data) &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">5100</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">1st subscriber:<span class="number">0</span></span><br><span class="line">1st subscriber:<span class="number">1</span></span><br><span class="line">1st subscriber:<span class="number">2</span></span><br><span class="line">1st subscriber:<span class="number">3</span></span><br><span class="line">1st subscriber:<span class="number">4</span></span><br><span class="line">2st subscriber:<span class="number">4</span></span><br><span class="line">1st subscriber:<span class="number">5</span></span><br><span class="line">2st subscriber:<span class="number">5</span></span><br><span class="line">1st subscriber:<span class="number">6</span></span><br><span class="line">2st subscriber:<span class="number">6</span></span><br><span class="line">1st subscriber:<span class="number">7</span></span><br><span class="line">2st subscriber:<span class="number">7</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>shareReplay(1) 中的 1 表示拿到错过的前一个值，在我们的例子就是第二个订阅从 4 开始接收值。如果改成 shareReplay (2) 就表示从错过的前两个值开始接收值，也就是第二个订阅会从 3 开始接收值。</p>
<p>shareReplay(1) 其实也是 publishReplay(1).refCount( ) 的缩写，用 publishReplay(1).refCount( ) 有同样的效果。</p>
]]></content>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJS：四种 Subjuct 的用法和区别</title>
    <url>/2021/07/07/RxJS%EF%BC%9A%E5%9B%9B%E7%A7%8D-Subjuct-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="RxJS：四种-Subject-的用法和区别"><a href="#RxJS：四种-Subject-的用法和区别" class="headerlink" title="RxJS：四种 Subject 的用法和区别"></a>RxJS：四种 Subject 的用法和区别</h1><p>在 RxJS 中有四种 Subject 分别是：Subject、BehaviorSubject、AsyncSubject、ReplaySubject；这四种 Subject 都是特殊的 Observable。</p>
<p>四种 Subject 与普通 Observable 的区别：</p>
<table>
<thead>
<tr>
<th align="center">Observable</th>
<th align="center">Subject</th>
<th align="center">BehaviorSubject</th>
<th align="center">AsyncSubject</th>
<th align="center">ReplaySubject</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cold</td>
<td align="center">Hot</td>
<td align="center">Hot</td>
<td align="center">Hot</td>
<td align="center">Hot</td>
</tr>
<tr>
<td align="center">数据生成者</td>
<td align="center">数据生成者和消费者</td>
<td align="center">数据生成者和消费者</td>
<td align="center">数据生成者和消费者</td>
<td align="center">数据生成者和消费者</td>
</tr>
<tr>
<td align="center">单播</td>
<td align="center">多播</td>
<td align="center">多播</td>
<td align="center">多播</td>
<td align="center">多播</td>
</tr>
<tr>
<td align="center">每次从头开始把值发给观察者</td>
<td align="center">将值多播给已注册监听该 Subject 的观察者</td>
<td align="center">把最后一个值 (当前值) 发送给观察者 (需要初始值)</td>
<td align="center">执行的最后一个值发送给观察者，相当于 last( )</td>
<td align="center">可以把之前的值发送给观察者 (错过的值)</td>
</tr>
</tbody></table>
<h2 id="Cold-vs-Hot"><a href="#Cold-vs-Hot" class="headerlink" title="Cold vs Hot"></a>Cold vs Hot</h2><p>前面介绍了 Cold Observables 与 Hot Observables 的区别，除了 Observable 之外，这四种 Subject 都是 Hot Observables。</p>
<h2 id="数据生产者-vs-数据消费者"><a href="#数据生产者-vs-数据消费者" class="headerlink" title="数据生产者 vs 数据消费者"></a>数据生产者 vs 数据消费者</h2><ul>
<li><em><strong>数据生产者</strong></em> 是指 Observable (可观察对象)，产生数据的一方</li>
<li><em><strong>数据消费者</strong></em> 是指 Observer (观察者)，接收数据的一方</li>
</ul>
<p>普通的 Observable 只是数据生产者，发送数据。而 Subject、BehaviorSubject、AsyncSubject 和 ReplaySubject 即是生产者有时消费者。比如在 Angular 项目中，我们经常是哟 Subject 在多个 component 中共享数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// messageService.ts</span></span><br><span class="line">private shareData: Subject&lt;string&gt; = <span class="keyword">new</span> Subject&lt;string&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sendData</span>(<span class="params">value: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.shareData.next(value);</span><br><span class="line">&#125;</span><br><span class="line">getData(): Observable&lt;string&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.shareData.asObservable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RxjsSubjectBComponent</span></span><br><span class="line"><span class="comment">// send data from RxjsSubjectBComponent</span></span><br><span class="line">  <span class="built_in">this</span>.messageService.sendData(<span class="string">&quot;this message from subject b&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RxjsSubjectCComponent</span></span><br><span class="line"><span class="comment">// get data in RxjsSubjectCComponent</span></span><br><span class="line"><span class="built_in">this</span>.subscription = <span class="built_in">this</span>.messageService.getData()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = val;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>在这两个 component 中通过定义在 messageService 的 Subject 共享数据，通过 next( ) 方法使得 Subject 是数据生产者 (可观察对象) ，通过 asObservable( ) 使得 Subject 是数据消费者 (Observers)。</p>
<h2 id="单播-vs-多播"><a href="#单播-vs-多播" class="headerlink" title="单播 vs 多播"></a>单播 vs 多播</h2><p>在上面的代码例子中，不仅是 component c 可以订阅拿到数据，其他 component 中也可以订阅拿到数据。比如在 RxjsSubjectAComponent 中定义如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RxjsSubjectAComponent</span></span><br><span class="line"><span class="comment">// get data in RxjsSubjectAComponent</span></span><br><span class="line"><span class="built_in">this</span>.subscription = <span class="built_in">this</span>.messageService.getData()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in componet A and &quot;</span> + val);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>从 RxjsSubjectComponent 发出值，在 RxJSSubjectCComponent 和 RxjsSubjectAComponent 能拿到同样的值，这个就是多播。</p>
<p>普通的 Observables 是 Cold Observables 并且是单播的，其他四种 Subject 是 Hot Observables 并且是多播的。</p>
<p>单播的意思是，每个普通的 Observables 实例都只能被一个观察者订阅，当它被其他观察者订阅的时候，会产生一个新的实例。也就是普通的 Observables 被不同的观察者订阅的时候，会有多个实例，不管观察者是从何时开始订阅，每个实例都是从头开始把值发给对应的观察者。</p>
<h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>Subject 其中的一个变体就是 BehaviorSubject，它有一个“当前值”的概念。它保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”，在定义一个 BehaviorSubject 时需要有初始值。</p>
<p>在 messageService 定义一个 BehaviorSubject，初始值是 1，updateBehaviorSubject 方法把值更新为 2，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//messageService.ts</span></span><br><span class="line">private behaviorSubject: BehaviorSubject&lt;number&gt; = <span class="keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="number">1</span>);</span><br><span class="line">currentBehaviorSubject = <span class="built_in">this</span>.behaviorSubject.asObservable();</span><br><span class="line"><span class="function"><span class="title">updateBehaviorSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.behaviorSubject.next(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 RxjsSubjectBComponent 中调用执行了 updateBehaviorSubject 方法，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RxjsSubjectBComponent</span></span><br><span class="line"><span class="built_in">this</span>.messageService.updateBehaviorSubject();</span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectAComponent 中订阅 BehaviorSubject 的值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription1 = <span class="built_in">this</span>.messageService.currentBehaviorSubject</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectAComponent and Current behavior subject value is  &quot;</span> + val)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.subscription.add(subscription1);</span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectCComponent 中，等 5 秒以后再订阅 BehaviorSubject 的值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription1 = <span class="built_in">this</span>.messageService.currentBehaviorSubject</span><br><span class="line">        .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectCComponent and Current behavior subject value is  &quot;</span> + val)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>运行效果：在 RxJSSubjectAComponent 中会拿到 1 和 2 两个值，在RxJSSubjectCComponent中会拿到 2 这个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectAComponent and Current behavior subject value is  <span class="number">1</span></span><br><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectAComponent and Current behavior subject value is  <span class="number">2</span></span><br><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectCComponent and Current behavior subject value is  <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>如果是正常的 Hot Observable 在 5 秒之后，拿不到任何值，因为在 5 秒内已经将所有值发送出去了，5 秒之后观察者再订阅，没有任何值可以发送了。但是用 BehaviorSubject 保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”，所以 RxJSSubjectCComponent 的订阅者会拿到 2 这个值。</p>
<h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>类似于 BehaviorSubject，可以发送旧值给新的订阅者，但是不仅是“当前值”，还可以是之前的旧值。</p>
<p>在 messageService 定义一个 ReplaySubject，<u>为新的订阅者缓冲 3 个值</u>，sendReplaySubject 方法把 1、2、3、4、5 五个值发送给订阅者，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//messageService.ts</span></span><br><span class="line">private replaySubject: ReplaySubject&lt;number&gt; = <span class="keyword">new</span> ReplaySubject&lt;number&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="function"><span class="title">sendReplaySubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.replaySubject.next(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getReplaySubject(): Observable&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replaySubject.asObservable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectBComponent 中，调用 sendReplaySubject 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.messageService.sendReplaySubject();</span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectAComponent 中，订阅 ReplaySubject 的值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription2 = <span class="built_in">this</span>.messageService.getReplaySubject()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectAComponent and Current Replay subject value is  &quot;</span> + val)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.subscription.add(subscription2);</span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectCComponent 中，等5秒以后在订阅 replaySubject 的值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription2 = <span class="built_in">this</span>.messageService.getReplaySubject()</span><br><span class="line">        .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectCComponent and Current repaly subject value is  &quot;</span> + val)</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">this</span>.subscription.add(subscription2);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>只有当 Observable 执行完成之后 (执行 complete ( ))，它才会将执行的最后一个值发送给观察者。</p>
<p>在 messageService 定义一个 AsyncSubject，sendAsyncSubject 方法把 10001 10002 10003 三个值发给订阅者，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private asyncSubject: AsyncSubject&lt;number&gt; = <span class="keyword">new</span> AsyncSubject&lt;number&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sendAsyncSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.next(<span class="number">10001</span>);</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.next(<span class="number">10002</span>);</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.next(<span class="number">10003</span>);</span><br><span class="line">    <span class="built_in">this</span>.asyncSubject.complete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getAsyncSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.asyncSubject.asObservable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectBComponent 中，调用 sendAsyncSubject 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.messageService.sendAsyncSubject();</span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectAComponent 中，订阅 asyncSubject 的值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription3 = <span class="built_in">this</span>.messageService.getAsyncSubject()</span><br><span class="line">    .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectAComponent and Current Async subject value is  &quot;</span> + val)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.subscription.add(subscription3);</span><br></pre></td></tr></table></figure>

<p>在 RxjsSubjectCComponent 中，等5秒以后在订阅 asyncSubject 的值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription3 = <span class="built_in">this</span>.messageService.getAsyncSubject()</span><br><span class="line">        .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this is in RxjsSubjectCComponent and Current async subject value is  &quot;</span> + val)</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">this</span>.subscription.add(subscription3);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectAComponent and Current Async subject value is  <span class="number">10003</span></span><br><span class="line"><span class="built_in">this</span> is <span class="keyword">in</span> RxjsSubjectCComponent and Current <span class="keyword">async</span> subject value is  <span class="number">10003</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/07/RxJS%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%20RxJS%20%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="RxJS：如何通过-RxJS-实现缓存"><a href="#RxJS：如何通过-RxJS-实现缓存" class="headerlink" title="RxJS：如何通过 RxJS 实现缓存"></a>RxJS：如何通过 RxJS 实现缓存</h1><ul>
<li>Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Cold Observable。</li>
<li>HttpClient Observable 每次被订阅都需要调用 http request，对于共用的 API 返回同样的值，在不同页面重复调用会浪费 http 资源降低性能。</li>
<li>如何通过 ReplaySubject 实现缓存效果，提高性能。</li>
</ul>
<h2 id="HttpClient-返回的-Observables-是-Cold-Observable"><a href="#HttpClient-返回的-Observables-是-Cold-Observable" class="headerlink" title="HttpClient 返回的 Observables 是 Cold Observable"></a>HttpClient 返回的 Observables 是 Cold Observable</h2><p>在 Angular 2.0 以上的版本，都是通过 HttpClient 跟后端 API 交互；所有的 Http 请求方法，比如 get、post、put、delete 都是返回一个 Observable。之前介绍了 Cold Observable 与 Hot Observable 的区别。</p>
<p>那么在 Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Hot Observables 还是 Cold Observables？先写一段代码测试一下，在页面中显示 30 个 GitHub user 的基本信息：</p>
<p>先定义一个 service：RxjsCacheService，在这个 service 中定义一个方法去拿 github 的用户信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/common/http&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;../interface/rxjs-cache.interface&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map, catchError &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">of</span>, Observable &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsCacheService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">users</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.requestUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">requestUsers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// get the latest 30 github users: start from id =2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;(<span class="string">&quot;https://api.github.com/users?since=1&quot;</span>)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">respone</span> =&gt;</span> respone),</span><br><span class="line">                catchError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong &quot;</span> + error)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口 rxjs-cache.interface 定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface User &#123;</span><br><span class="line">    <span class="attr">login</span>: string,</span><br><span class="line">    <span class="attr">id</span>: number,</span><br><span class="line">    <span class="attr">node_id</span>: string,</span><br><span class="line">    <span class="attr">avatar_url</span>: string,</span><br><span class="line">    <span class="attr">gravatar_id</span>: string,</span><br><span class="line">    <span class="attr">url</span>: string,</span><br><span class="line">    <span class="attr">html_url</span>: string,</span><br><span class="line">    <span class="attr">followers_url</span>: string,</span><br><span class="line">    <span class="attr">following_url</span>: string,</span><br><span class="line">    <span class="attr">gists_url</span>: string,</span><br><span class="line">    <span class="attr">starred_url</span>: string,</span><br><span class="line">    <span class="attr">subscriptions_url</span>: string,</span><br><span class="line">    <span class="attr">organizations_url</span>: string,</span><br><span class="line">    <span class="attr">repos_url</span>: string,</span><br><span class="line">    <span class="attr">events_url</span>: string,</span><br><span class="line">    <span class="attr">received_events_url</span>: string,</span><br><span class="line">    <span class="attr">type</span>: string,</span><br><span class="line">    <span class="attr">site_admin</span>: boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个 component：RxjsCacheComponent，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; RxjsCacheService &#125; <span class="keyword">from</span> <span class="string">&quot;./service/rxjs-cache.service&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;./interface/rxjs-cache.interface&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    <span class="attr">templateUrl</span>: <span class="string">&quot;./rxjs-cache.component.html&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsCacheComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private users$: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private rxjsCacheService: RxjsCacheService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users$ = <span class="built_in">this</span>.rxjsCacheService.users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rxjs-cache.component.html 代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>here is the github user lists:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; display: flex;flex-direction: row;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 10%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 50%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行以上代码，在页面上列出了 30 位 Github 用户的用户名和相对应的 Github 地址，从上面的代码还是不能看出 HttpClient 返回的 Observable 是 Hot Observables 还是 Cold Observables。我们把 html 代码改一下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>here is the github user lists:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; display: flex;flex-direction: row;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 10%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 50%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>here is the github user lists2:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let user of users$ |async&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; display: flex;flex-direction: row;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 10%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  &#123; &#123; user.login &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0.9em;margin:10px;width: 50%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>GitHub URL:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123; &#123; user.url &#125; &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>F12 打开浏览器的 DevTools，当前页面会调用两次 GET API，并且两个 user list 列出的 30 位用户的信息一模一样：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/scNswE.jpg" alt="alt"></p>
<p>两个 userList 订阅 users$，生成了两个 Observable 实例并且都是订阅开始之后才开始发送值，<em><strong>也就是说 Angular 中通过 HttpClient 执行 Http Request 返回的 Observable 是 Cold Observable</strong></em>。</p>
<h2 id="性能问题？"><a href="#性能问题？" class="headerlink" title="性能问题？"></a>性能问题？</h2><p>每次调用 API ，都会生成一个新的 Observable 实例，有订阅之后才开始发送值，这也符合现在前端的开发需求。但在实际开发过程中，有时候后端会提供一些公用的常量 API，不同页面都需要用这些常量，按现在的调用 API 的方式，会导致常量 API 在不同的页面重复多次调用，这种方式显然性能不好。</p>
<h2 id="通过-RxJS-实现缓存效果"><a href="#通过-RxJS-实现缓存效果" class="headerlink" title="通过 RxJS 实现缓存效果"></a>通过 RxJS 实现缓存效果</h2><p>ReplaySubject(size) 可以发送之前的旧值给新的订阅者，size 是定义发送具体多少个旧值给新的订阅者。那么在示例代码中可以用 ReplaySubject 实现缓存效果。</p>
<p>shareReplay 这个操作符会自动创建一个 ReplaySubject，一旦 http request 执行一次以后，就会在后续的订阅和源头 Observable 之间建立一个 ReplaySubject，ReplaySubject 是一个多播的 Hot Observable，后续订阅都是从这个中间的 ReplaySubject 拿到最后一个值，从而达到缓存效果。</p>
<p>我们把 RxjsCacheService 改成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">&quot;@angular/common/http&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;../interface/rxjs-cache.interface&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map, catchError, shareReplay &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">of</span>, Observable &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CACHE_SIZE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsCacheService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private cacheUsers$:Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">users</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.cacheUsers$)&#123;</span><br><span class="line">            <span class="built_in">this</span>.cacheUsers$ = <span class="built_in">this</span>.requestUsers()</span><br><span class="line">            .pipe(</span><br><span class="line">                shareReplay(CACHE_SIZE)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.cacheUsers$;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">requestUsers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;(<span class="string">&quot;https://api.github.com/users?since=1&quot;</span>)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">respone</span> =&gt;</span> respone),</span><br><span class="line">                catchError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong &quot;</span> + error)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码发现，页面里两个 user list 都是列出了相同的30位 Github 用户信息，但是只调用了一次 GET API，也就是说第二订阅不是从通过后端 API 拿到用户信息，而是从 ReplaySubject 中拿到的。</p>
<p>整个流程如下：</p>
<p><img src="https://raw.githubusercontent.com/LauGaHo/blog-img/master/uPic/icGsXB.jpg" alt="alt"></p>
<p>页面的第一个 userlist 也就是第一个 consumer，是通过调用API拿到30个用户信息，第二个 userlist 也就是第二个 consumer，直接从 cacheUsers$ 拿到这30个用户信息。cacheUsers$ 是 ReplaySubject(1) 把最后一个旧值（30个用户信息）发送给新的订阅者（第二个 userlist ），从而实现了缓存效果。</p>
]]></content>
  </entry>
  <entry>
    <title>RxJS：通过 RxJS 实现简单的消息通知机制</title>
    <url>/2021/07/09/RxJS%EF%BC%9A%E9%80%9A%E8%BF%87%20RxJS%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="RxJS：通过-RxJS-实现简单的消息通知机制"><a href="#RxJS：通过-RxJS-实现简单的消息通知机制" class="headerlink" title="RxJS：通过 RxJS 实现简单的消息通知机制"></a>RxJS：通过 RxJS 实现简单的消息通知机制</h1><p>在实际开发中，还有一种 API 返回的值随着时间会有变化，这个时候去更新 RxJS 缓存里的值，从用户体验的角度出发，先在页面显示一个消息通知用户数据有更新，让用户选择是否需要更新页面内容，而不是直接在每次缓存更新之后直接刷新页面数据。下面介绍如何基于 RxJS 实现简单的消息通知机制。</p>
<ul>
<li>本文用到的 RxJS 缓存指 Angular 2+ 中结合 HttpClient 和 ReplaySubject 缓存 API Response 数据，后续新的订阅者都可以直接从 ReplaySubject 拿 API Response 数据。</li>
</ul>
<h2 id="更新-RxJS-缓存"><a href="#更新-RxJS-缓存" class="headerlink" title="更新 RxJS 缓存"></a>更新 RxJS 缓存</h2><p>这里直接每隔 10 秒调用一次 API，把新拿到的值赋值给 RxJS 缓存。</p>
<p>还是用 Github 的 get all users API：Github API，每 10 秒调用一次 API 拿到 30 个不同的 Github 用户信息。用 interval 可以实现每隔 10s 调用一次 API，但是会有一个问题，用户在第一次进到页面的时候需要等 10s 才能看到 30 位用户信息。我们希望用户第一次进到页面立马能看到 30 位用户信息，之后是每隔 10s 调用一次 API 更新 30 位 Git 用户信息，timer 操作符可以满足这个要求，timer(0, 10000) 表示首次不用等直接调用 API 拿到 30 位 Git 用户信息，之后每隔 10s 调用一次 API。Service 代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CACHE_SIZE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REFRESH_INTERVAL = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> API_ENDPOINT = <span class="string">&quot;https://api.github.com/users?since=&quot;</span>;</span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsNotificationService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> cacheUsers$: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line">    <span class="keyword">private</span> userStartId: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">users</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.cacheUsers$) &#123;</span><br><span class="line">            <span class="keyword">const</span> timer$ = timer(<span class="number">0</span>, REFRESH_INTERVAL);</span><br><span class="line">            <span class="built_in">this</span>.cacheUsers$ = timer$</span><br><span class="line">                .pipe(</span><br><span class="line">                    switchMap(<span class="function">() =&gt;</span> <span class="built_in">this</span>.requestUsers()),</span><br><span class="line">                    shareReplay(CACHE_SIZE)</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cacheUsers$;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">requestUsers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userStartId = <span class="built_in">this</span>.userStartId + <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.http.get&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;(API_ENDPOINT + <span class="built_in">this</span>.userStartId)</span><br><span class="line">            .pipe(</span><br><span class="line">                map(<span class="function"><span class="params">respone</span> =&gt;</span> respone),</span><br><span class="line">                catchError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong &quot;</span> + error)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个 RxjsNotificationComponent，具体代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">templateUrl</span>: <span class="string">&quot;./rxjs-notification.component.html&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RxjsNotificationComponent</span> </span>&#123;</span><br><span class="line">    <span class="attr">users$</span>: Observable&lt;<span class="built_in">Array</span>&lt;User&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> rxjsNotificationService: RxjsNotificationService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users$ = <span class="built_in">this</span>.rxjsNotificationService.users.pipe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rxjs-notification.component.html 代码如下：</p>
]]></content>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim：基础操作指南</title>
    <url>/2021/07/06/Vim%20%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><ul>
<li>h 或 退格：左移一个字符</li>
<li>l 或 空格：右移一个字符</li>
<li>j：下移一行</li>
<li>k：上移一行</li>
<li>gj：移动到一段内的下一行</li>
<li>gk：移动到一段内的上一行</li>
<li>+或 Enter：移动到下一行第一个非空白字符</li>
<li>-：移动到上一行第一个非空白字符</li>
<li>w：后移一个单词，光标停在下一个单词开头</li>
<li>W：移动到下一个单词开头，但忽略一些标点</li>
<li>e：后移一个单词，光标停在下一个单词的末尾</li>
<li>E：移动到下一个单词的末尾</li>
<li>b：前移一个单词，光标停在单词的开头</li>
<li>B：移动到前一个单词开头，忽略一些标点</li>
<li>ge：前移一个单词，光标停在上一个单词的末尾</li>
<li>gE：同 ge ，不过单词包含相邻的标点</li>
<li>(：前移一句</li>
<li>)：后移一句</li>
<li>{：前移一段</li>
<li>}：后移一段</li>
<li>fc：把光标移动到同一行的下一个 c 字符处</li>
<li>Fc：把光标移动到同一行的上一个 c 字符处</li>
<li>tc：把光标移动到同一行的下一个 c 字符前</li>
<li>Tc：把光标移动到同一行的上一个 c 字符后</li>
</ul>
<p>上面的操作都可以配合 n 使用，比如正常模式下输入 3h，则光标向左移动3个字符。</p>
<ul>
<li>0：移动到行首</li>
<li>g0：移动到所在屏幕行行首</li>
<li>^：移动到本行第一个非空白字符</li>
<li>g^：移动到所在屏幕行第一个非空字符处</li>
<li>$：移动到行尾</li>
<li>g$：移动到所在屏幕行行尾</li>
<li>nl：移动到第 n 列</li>
<li>nG：移动到第 n 行</li>
<li>:n&lt;cr&gt;：移动到第 n 行</li>
<li>:$&lt;cr&gt;：移动到最后一行</li>
<li>H：把光标移到屏幕最顶端一行</li>
<li>M：把光标移到屏幕最底端一行</li>
<li>L：把光标移到屏幕最底端一行</li>
<li>gg：到文件头部</li>
<li>G：到文件尾部</li>
</ul>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="基本插入"><a href="#基本插入" class="headerlink" title="基本插入"></a>基本插入</h3><ul>
<li>i：在光标前插入；一个小技巧：按 8 ，再按 i，进入插入模式，输入 =，按 esc 进入命令模式，就会出现 8 个 =。这在插入分割线时非常有用，如：30 i + &lt;esc&gt; 插入了 30 个 + 组成的分割线</li>
<li>l：在当前行第一个非空字符前插入</li>
<li>gl：在当前行第一列插入</li>
<li>a：在光标后插入</li>
<li>A：在当前行最后插入</li>
<li>o：在下面新建一行插入</li>
<li>O：在上面新建一行插入</li>
<li>:r filename：在当前位置插入另一个文件的内容</li>
<li>:[n] r filename：在第 n 行插入另一个文件的内容</li>
<li>:r !date：在光标处插入当前日期与时间。同理，:r !command 可以将其他 shell 命令的输出插入到当前文档</li>
</ul>
<h3 id="改写插入"><a href="#改写插入" class="headerlink" title="改写插入"></a>改写插入</h3><ul>
<li>c[n]w：改写光标后的 1(n) 个词</li>
<li>c[n]l：改写光标后的 1(n) 个字母</li>
<li>c[n]h：改写光标前的 1(n) 个字母</li>
<li>[n]cc：修改当前 1(n) 行</li>
<li>[n]s：以输入的文本替代光标后的 1(n) 个字符，相当于 c[n]l</li>
<li>[n]S：删除指定数目的行，并以所输入文本替代之</li>
</ul>
<p>注意，类似 cnw、dnw、ynw 的形式同样可以写为 ncw、ndw、nyw</p>
<h2 id="复制、黏贴和剪切"><a href="#复制、黏贴和剪切" class="headerlink" title="复制、黏贴和剪切"></a>复制、黏贴和剪切</h2><ul>
<li>[n]x：剪切光标右边 n 个字符，相当于 d[n]l</li>
<li>[n]X：剪切光标左边 n 个字符，相当于 d[n]h</li>
<li>y：复制可视模式下选中的文本</li>
<li>yy or Y：复制整行文本</li>
<li>y[n]w：复制 1(n) 个词</li>
<li>y[n]l：复制光标右边 1(n) 个字符</li>
<li>y[n]h：复制光标左边 1(n) 个字符</li>
<li>y$：从光标当前位置复制到行尾</li>
<li>y0：从光标当前位置复制到行首</li>
<li>:m,n&lt;cr&gt;：复制 m 行到 n 行的内容</li>
<li>y1G or ygg：复制光标以上的所有行</li>
<li>yG：复制光标以下的所有行</li>
<li>yaw or yas：复制一个词和复制一个句子，即使光标不在词首和句首也没有关系</li>
<li>d：删除 (剪切)，在可视模式下选中的文本</li>
<li>d$ or D：删除 (剪切) 当前位置到行尾的内容</li>
<li>d[n]w：删除 (剪切) 1(n)个单词</li>
<li>d[n]l：删除 (剪切) 光标右边 1(n) 个字符</li>
<li>d[n]h：删除 (剪切) 光标左边 1(n) 个字符</li>
<li>d0：删除 (剪切) 当前位置到行首的内容</li>
<li>[n]dd：删除 (剪切) 1(n) 行</li>
<li>m,nd&lt;cr&gt;：剪切 m 行到 n 行的内容</li>
<li>d1G or dgg：剪切光标以上的所有行</li>
<li>dG：剪切光标以下的所有行</li>
<li>daw 或 das：剪切一个词或者剪切一个句子，即使光标不在词首和句首也没有关系</li>
<li>d/f&lt;cr&gt;：高级组合命令，它将删除当前位置到下一个 f 之间的内容</li>
<li>p：在光标之后黏贴</li>
<li>P：在光标之前黏贴</li>
</ul>
]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
</search>
